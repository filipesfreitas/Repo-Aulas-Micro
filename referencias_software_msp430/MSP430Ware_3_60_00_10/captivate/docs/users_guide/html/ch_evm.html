<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>CapTIvate&trade; Technology Guide: MSP-CAPT-FR2633 Development Kit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <img alt="Logo" width=25% src="ti_hz_2c_pos_rgb_png.png"/>
    <table cellspacing="0" cellpadding="0">
        <tbody>
        <tr style="height: 56px;">
            <td style="padding-left: 0.5em;">
                <div id="projectname">CapTIvate&trade; Technology Guide
                    &#160;<span id="projectnumber">v1.30.10.00</span>
                    <p><a href="http://www.ti.com/tool/msp-capt-fr2633">Purchase the kit now</a>
                    <br><a href="http://www.ti.com/captivate">Go to ti.com/CapTIvate</a></p>
                </div>
            </td>
        </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ch_evm.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">MSP-CAPT-FR2633 Development Kit </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ch_evm_intro"></a>
Introduction</h1>
<p>Capacitive touch evaluation and rapid prototyping has never been faster and easier. Using this modular kit with the CapTIvate&trade; Design Center, you can evaluate the performance of MSP430FR2633 MCU using the capacitive touch demo boards, or develop your own PCB and experience the power of the CapTIvate&trade; Design Center and the ease of real-time sensor tuning, all without writing a single line of code. Free software development tools are also available, including TI's Eclipse-based Code Composer Studio&trade; (CCS) and IAR Embedded Workbench&reg; IAR-KICKSTART. Both of these integrated development environments (IDEs) support EnergyTrace&trade; technology when paired with the MSP430FR2633 MCU Development Kit.</p>
<p>Read through the <a class="el" href="ch_evm.html#ch_evm_overview">overview</a> section to become familiar with all of the hardware in the kit, or jump to the <a class="el" href="ch_evm.html#ch_evm_get_started">getting started</a> section to begin evaluation.</p>
<h2><a class="anchor" id="ch_evm_overview"></a>
Overview</h2>
<p>The MSP-CAPT-FR2633 MCU Development Kit is an easy to use evaluation platform for the MSP430FR2633 microcontroller featuring CapTIvate&trade; Capacitive Touch Technology. It contains everything needed to start developing on the MSP430&trade; ultra-low-power (ULP) FRAM-based microcontroller (MCU) platform, including on-board emulation for programming, debugging and energy measurements. The MSP430FR2633 MCU features a new CapTIvate&trade; Capacitive Touch Technology, supporting self and mutual capacitive sensors, and embedded FRAM (ferroelectric random access memory). FRAM is a non-volatile memory known for its ultra-low power, high endurance, and high-speed write access.</p>
<h2><a class="anchor" id="ch_evm_features"></a>
Key Features</h2>
<ul>
<li>Modular Design<ul>
<li>Different sensing panels may be attached through a common connector.</li>
<li>The programming/debug logic has been split from the target MCU, unlike a typical LaunchPad which has both components on one PCB. This allows for an isolation module to be inserted between the two for testing/tuning, or for the programming/debug module to be used for in-system product development.</li>
<li>The target MCU PCB features BoosterPack headers, allowing it to be used as a BoosterPack for another LaunchPad, such as the MSP-EXP432P401R LaunchPad.</li>
</ul>
</li>
<li>Application Oriented<ul>
<li>The sensing panels included in the kit are designed to mimic real applications.</li>
<li>Evaluating a new application simply involves laying out a basic 1 or 2 layer PCB with a footprint for the sensor connector, or simply laying out electrodes with copper tape and wiring them into the connector.</li>
</ul>
</li>
<li>Easy Access to Data<ul>
<li>EnergyTrace power profiling enables capturing of power profiles without any measurement equipment.</li>
<li>The HID-Bridge communications interface allows easy debug data transfer between the target and a PC over UART or I2C.</li>
</ul>
</li>
</ul>
<h3>What's Included</h3>
<p>The following PCBs are included in the kit:</p>
<ul>
<li><b>CAPTIVATE-FR2633</b> Target MCU Module</li>
<li><b>CAPTIVATE-PGMR</b> eZ-FET with EnergyTrace and HID Communication Bridge</li>
<li><b>CAPTIVATE-ISO</b> UART, I2C, and SBW Isolation Board</li>
<li><b>CAPTIVATE-BSWP</b> Self Capacitance Demo (Out-of-Box Experience)</li>
<li><b>CAPTIVATE-PHONE</b> Mutual Capacitance Demo with Haptics and Guard Channel</li>
<li><b>CAPTIVATE-PROXIMITY</b> Proximity Detection and Gesturing Demo</li>
</ul>
<div class="image">
<img src="evm_kit_contents.png" alt="evm_kit_contents.png"/>
<div class="caption">
Kit Contents</div></div>
  <h3>Additional CapTIvate&trade; Demo Boards</h3>
<p>The follwing PCBs will be available separately, but are compatible with this kit:</p>
<h2>Software Examples</h2>
<p><a class="el" href="ch_evm.html#ch_evm_example_project_locations">Complete CCS and IAR example projects</a> for each demo panel are provided with the CapTIvate&trade; Design Center installation. Example projects are also available with the installation of MSPWare.</p>
<h2>Design Files</h2>
<p>Schematic and layout design files for all of the PCBs in the kit are available below.</p>
<div class="image">
<img src="evm_design_files.png" alt="evm_design_files.png"/>
</div>
 <ul>
<li><a href="http://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/MSP-CAPT-FR2633/latest/index_FDS.html">Download CapTIvate&trade; EVM Design Files Here:</a></li>
</ul>
<hr/>
<h1><a class="anchor" id="ch_evm_get_started"></a>
Getting Started with the MCU Development Kit</h1>
<p>This section details how to get started with the development kit.</p>
<h2><a class="anchor" id="ch_evm_get_started_prework"></a>
Pre-Work</h2>
<p>To get started with the kit, complete the following software and hardware steps:</p>
<p><b>Software Installation</b></p><ol type="1">
<li>Install the CapTIvate&trade; Design Center GUI on your PC, Linux, or MAC computer (note the <a class="el" href="DesignCenter.html#ch_cdc_Intro_sec02">requirements</a>).</li>
<li>Install a development environment (IDE). TI's Code Composer Studio v6.1.0 and IAR Embedded Workbench v6.30 or greater are supported.</li>
</ol>
<p><b>Hardware Setup</b></p><ol type="1">
<li>Connect the CAPTIVATE-FR2633 MCU module and CAPTIVATE-PGMR module together.</li>
<li>Connect the desired sensing panel to the CAPTIVATE-FR2633 module. The out-of-box experience uses the CAPTIVATE-BSWP panel.</li>
<li>Connect the micro-USB cable between the CAPTIVATE-PGMR programmer PCB and your computer</li>
<li>Verify that LED2 and LED5 (power good LED's) on the CAPTIVATE-PGMR module are lit, and that LED4 (HID-Bridge enumeration) is blinking.</li>
</ol>
<p>Refer to the <a class="el" href="ch_FAQ.html#ch_FAQ_DEVKIT">FAQ</a> section for further troubleshooting tips. </p><div class="image">
<img src="evm_demo_setup.png" alt="evm_demo_setup.png"/>
<div class="caption">
Typical Setup</div></div>
 <h2>Out-of-Box Experience</h2>
<p>Be sure that you have completed the <a class="el" href="ch_evm.html#ch_evm_get_started_prework">pre work</a>. The CAPTIVATE-FR2633 module ships pre-programmed with the demo software for the CAPTIVATE-BSWP panel. It is not necessary to program the target device to begin evaluating with that panel. Check out the <a class="el" href="ch_workshop.html">workshop chapter</a> for the out-of-box experience to begin working with the kit!</p>
<h2><a class="anchor" id="ch_evm_get_started_loadingexample"></a>
Running an Example Project</h2>
<p>Be sure that you have completed the <a class="el" href="ch_evm.html#ch_evm_get_started_prework">pre work</a>. To run an example project, it is necessary to do the following:</p>
<ol type="1">
<li>If it is not already connected, connect the desired sensing panel (CAPTIVATE-BSWP, CAPTIVATE-PHONE, CAPTIVATE-PROXIMITY) to the CAPTIVATE-FR2633 module.</li>
<li>Import, build, and program the example software for the specific board that you are using onto the MSP430FR2633 target MCU on the CAPTIVATE-FR2633 module. Follow these steps to <a class="el" href="DesignCenter.html#ch_cdc_LoadAndRunProjects">load and run generated firmware projects</a>. <a class="el" href="ch_evm.html#ch_evm_example_project_locations">Example project locations</a> are described below. <b>Note</b> that the CAPTIVATE-FR2633 module ships pre-programmed for the CAPTIVATE-BSWP sensing panel.</li>
<li>Start the CapTIvate&trade; Design Center using the icon that was installed on your desktop.</li>
<li>Click <em>File</em> -&gt; <em>Project Open</em> from the menu bar and select the desired project directory. <a class="el" href="DesignCenter.html#ch_cdc_UsersGuide_sec02">Click here for help with CapTIvate&trade; Design Center</a>. The project's <a class="el" href="DesignCenter.html#ch_cdc_Intro">main window</a> is the design canvas and is pre-populated with the microcontroller and selected sensors matching the hardware for this demo.</li>
<li><a class="el" href="DesignCenter.html#ch_cdc_LoadAndRunProjects_sec02">Enable Communications</a> in the CapTIvate&trade; Design Center to begin the demonstration.</li>
<li>View the data for different sensors when you approach and touch the panel. Note: If the MCU is in wake-on-proximity mode, there may appear to be no activity. Bring your hand near or touch the board to activate the MCU.</li>
</ol>
<h2><a class="anchor" id="ch_evm_example_project_locations"></a>
Example Project Locations</h2>
<p>During the CapTIvate&trade; Design Center installation process, example projects and MSP430FR2633 firmware projects are placed in their own directory in the user's home directory under "CaptivateDesignCenter/CaptivateDesignCenterWorkspace". On Windows 7, this would be C:/Users/"username"/CaptivateDesignCenter/CaptivateDesignCenterWorkspace.</p>
<hr/>
<h1><a class="anchor" id="ch_evm_get_started_sensorpanels"></a>
Sensor Panel Demonstrations</h1>
<p>This section describes each of the sensor panel demonstrations. For details on the hardware for each panel, visit the <a class="el" href="ch_evm.html#ch_evm_hardware">hardware</a> section.</p>
<h2><a class="anchor" id="ch_evm_get_started_sensorpanels_bswp"></a>
CAPTIVATE-BSWP Demonstration (Out of Box Experience)</h2>
<p>The CAPTIVATE-BSWP sensing panel demonstrates the low power and high sensitivity features of the CapTIvate&trade; technology. The wake-on-proximity state machine is utilized to measure the proximity sensor in LPM3 until a user is close to the panel. When a user is detected, all of the sensors begin scanning at a faster rate. Data is communicated to the CapTIvate&trade; Design Center via the bulk I2C interface.</p>
<div class="image">
<img src="evm_bswp_canvas.png" alt="evm_bswp_canvas.png"/>
<div class="caption">
CAPTIVATE-BSWP Design Canvas</div></div>
  <p>This panel is configured with the following settings:</p><ul>
<li><b>A 33ms active mode scan period (30 Hz).</b> This provides a balance between response time and power consumption when a user is interacting with the panel. Scanning faster (at 20ms/50Hz for example) would provide a faster response time and also has a perceived performance benefit when working with sliders and wheels. Scanning slower (at 50ms/20Hz for example) would provide lower power consumption, but a higher response time.</li>
<li><b>An inactivity timeout of 32 samples.</b> This means that the system will transition from active mode into wake-on-proximity mode after 32 samples without any interaction have passed. This works out to about a 1 second delay. This aggressive transition improves battery life.</li>
<li><b>A 100ms wake-on-proximity mode scan period (10 Hz).</b> This slower scan rate is designed to conserve power while still waking up the panel fast enough to be ready for an approaching user.</li>
<li><b>A wakeup interval of 512 samples.</b> This means that the system will wake from the low-power wake-on-proximity state every 512 samples (about every 50 seconds) even if there is not a proximity detection. This provides a mechanism to periodically update the environmental filters for the other sensors on the PCB.</li>
<li><b>A 2 MHz conversion frequency</b> for all sensors.</li>
<li><b>A total measurement time of 2ms</b> for all sensors.</li>
</ul>
<p>To begin working with this panel, go through the steps for <a class="el" href="ch_evm.html#ch_evm_get_started_loadingexample">running an example project</a> and open the CAPTIVATE-BSWP project.</p>
<p>For an overview of the hardware design, visit the <a class="el" href="ch_evm.html#ch_evm_hardware_bswp">CAPTIVATE-BSWP hardware overview</a>.</p>
<h3><a class="anchor" id="ch_evm_get_started_sensorpanels_bswp_bonus"></a>
CAPTIVATE-BSWP Bonus Software Projects</h3>
<p>In addition to the out-of-box software project, the CAPTIVATE-BSWP panel is also used as the hardware platform for other examples that show off different features of the CapTIvate peripheral and MSP430FR2633 MCU.</p>
<h4><a class="anchor" id="ch_evm_get_started_sensorpanels_bswp_bonus_ulp4btn"></a>
Ultra Low Power Four Buttons Demonstration</h4>
<p>This supplementary example project uses the first 4 buttons on the CAPTIVATE-BSWP panel only. It demonstrates how to achieve extremely low power consumption for a design that only contains 4 buttons.</p>
<p>This project is configured with the following settings:</p><ul>
<li><b>An 83ms active mode scan period (12 Hz).</b></li>
<li><b>An inactivity timeout of 32 samples.</b> This means that the system will transition from active mode into wake-on-proximity mode after 32 samples without any interaction have passed.</li>
<li><b>A 125ms wake-on-proximity mode scan period (8 Hz).</b> This slower scan rate is designed to optimize battery life.</li>
<li><b>A wakeup interval of 2048 samples.</b></li>
<li><b>A 2 MHz conversion frequency</b> for all sensors.</li>
<li><b>A total measurement time of 260us</b> for all sensors.</li>
<li><b>An I-avg of 3uA when no one is touching the panel</b></li>
</ul>
<p>To begin working with this panel, go through the steps for <a class="el" href="ch_evm.html#ch_evm_get_started_loadingexample">running an example project</a> and open the UltraLowPower_FourButtons project.</p>
<p>For a step-by-step workshop of how to reproduce this project from scratch, see the <a class="el" href="ch_design.html#ch_design_low_power_example">low power design example</a> section of the design guide.</p>
<h4><a class="anchor" id="ch_evm_get_started_sensorpanels_bswp_bonus_cso1btn"></a>
Code Size Optimized One Button Demonstration</h4>
<p>This supplementary example project uses the first button on the CAPTIVATE-BSWP panel only. It demonstrates a bare-bones touch application that just controls the state of the two LEDs on the MCU module. When the button is pressed, LED1 will illuminate and stay lit the entire time the button is pressed. At the beginning of each new button press, LED2 will change its state.</p>
<p>This example serves as a reference for how to get down to a basic set of function calls. It achieves this by removing the CAPT_App layer that comes with the other example projects, and replacing it with register-level initialization of the MCU and top-level API calls directly into the CapTIvate library. This organization does not have support for the wake-on-proximity features, but it does have considerably reduced complexity as well as reduced memory requirements. This project easily fits into a small 8kB FRAM / 1kB RAM device variant.</p>
<p>Note: No communications module is included in the project build, so the only feedback will be visual via the LEDs!</p>
<p>The CapTIvate setup code is very basic, as shown below: </p><div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Set up the CapTIvate peripheral</span></div>
<div class="line"><span class="comment">// and timer.  The timer will periodically</span></div>
<div class="line"><span class="comment">// set the g_bConvTimerFlag.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">CAPT_initUI(&amp;g_uiApp);</div>
<div class="line">CAPT_calibrateUI(&amp;g_uiApp);</div>
<div class="line">MAP_CAPT_registerCallback(&amp;button, &amp;buttonHandler);</div>
<div class="line">MAP_CAPT_selectTimerSource(CAPT_TIMER_SRC_ACLK);</div>
<div class="line">MAP_CAPT_writeTimerCompRegister(CAPT_MS_TO_CYCLES(g_uiApp.ui16ActiveModeScanPeriod));</div>
<div class="line">MAP_CAPT_startTimer();</div>
<div class="line">MAP_CAPT_enableISR(CAPT_TIMER_INTERRUPT);</div>
</div><!-- fragment --><p>A simple background loop calls CAPT_updateUI directly and manages the use of the conversion timer interrupt flag variable. </p><div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Start the application</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordflow">while</span>(1)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (g_bConvTimerFlag == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// If it is time to update the button,</span></div>
<div class="line">        <span class="comment">// update it here with the generic library call.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        g_bConvTimerFlag = <span class="keyword">false</span>;</div>
<div class="line">        CAPT_updateUI(&amp;g_uiApp);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Go to sleep when finished.</span></div>
<div class="line">    <span class="comment">// The CapTIvate timer will wake the application from sleep.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    __bis_SR_register(g_uiApp.ui8AppLPM | GIE);</div>
<div class="line">}</div>
</div><!-- fragment --><p>A basic callback sets the LED states whenever the button is updated: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> buttonHandler(tSensor* pSensor)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// If the button is currently being touched,</span></div>
<div class="line">    <span class="comment">// illuminate LED1.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (pSensor-&gt;bSensorTouch==<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        P1OUT |= LED1;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// If a completely new touch was detected,</span></div>
<div class="line">        <span class="comment">// toggle the state of LED2.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span> (pSensor-&gt;bSensorPrevTouch==<span class="keyword">false</span>)</div>
<div class="line">        {</div>
<div class="line">            P1OUT ^= LED2;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        P1OUT &amp;= ~LED1;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This project is configured with the following settings:</p><ul>
<li><b>An 50ms active mode scan period (20 Hz).</b></li>
<li><b>A 2 MHz conversion frequency</b> for all sensors.</li>
<li><b>A total measurement time of 260us</b> for the button.</li>
<li><b>An I-avg of 10uA</b></li>
</ul>
<p>To begin working with this panel, go through the steps for <a class="el" href="ch_evm.html#ch_evm_get_started_loadingexample">running an example project</a> and open the CodeSizeOptimized_OneButton project.</p>
<h2><a class="anchor" id="ch_evm_get_started_sensorpanels_phone"></a>
CAPTIVATE-PHONE Demonstration</h2>
<p>The CAPTIVATE-PHONE sensing panel demonstrates the use of mutual capacitance to realize a high-density panel with many different sensor types using just 12 of the 16 CapTIvate&trade; sensing pins. The panel is designed to mimic a typical office phone application that would have a 12-key numeric keypad, several mode buttons, and several selection sensors. The panel features haptic vibration feedback thanks to a TI DRV2605L haptic driver IC coupled with a Samsung linear resonant actuator (LRA). A guard channel technique is applied to reject palm/arm presses on buttons as well as minor liquid spills. Data is communicated back to the CapTIvate&trade; Design Center via a UART interface.</p>
<div class="image">
<img src="evm_phone_canvas.png" alt="evm_phone_canvas.png"/>
<div class="caption">
CAPTIVATE-PHONE Design Canvas</div></div>
  <p>This panel is configured with the following settings:</p><ul>
<li><b>A 33ms active mode scan period (30 Hz).</b> This provides a balance between response time and power consumption when a user is interacting with the panel. Scanning faster (at 20ms/50Hz for example) would provide a faster response time and also has a perceived performance benefit when working with sliders and wheels. Scanning slower (at 50ms/20Hz for example) would provide lower power consumption, but a higher response time.</li>
<li><b>A 4 MHz conversion clock rate</b> for the mutual capacitance matrix, as mutual capacitance sensors may be scanned at a higher frequency.</li>
<li><b>A 1 MHz conversion clock rate</b> on the self-capacitance guard channel, as there is significant ground loading on this sensor, requiring a slower frequency.</li>
<li><b>A total measurement time of &lt;2.4ms</b> for all sensors.</li>
</ul>
<h3>Haptic Feedback</h3>
<p>This demonstration includes haptics to provide users with mechanical feedback that they did in fact touch a key. The most common and cost-effective actuators are the ERM (eccentric rotating mass) and LRA (linear resonant actuator). The LRA was chosen for this application because it provides a higher quality vibration feel than the ERM. For this reason, LRA's are more common with consumer products. However, there are some advantages to an ERM that are worth discussing here. LRAs have a limited lifetime of "clicks," and thus are not as suitable for long life cycle products as an ERM. Therefore, and ERM makes more sense than an LRA for long-life products such as industrial control panels.</p>
<p>With regard to the driver, The DRV2605L was selected as the driver IC for this demonstration for the following reasons:</p><ul>
<li>It has integrated ROM effect libraries that are pre-licensed from Immersion</li>
<li>It supports both ERM and LRA haptic actuators</li>
<li>It has a simple I2C register interface</li>
</ul>
<p>The demonstration firmware includes an I2C master driver and a DRV26x driver for communicating with the DRV2605L. Setting up the DRV2605L with these modules is accomplished in the Demo_init() function as follows:</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Open the I2C Master driver, which the DRV26x driver will use to</span></div>
<div class="line"><span class="comment">// communicate with the DRV2605L haptic driver IC via I2C.</span></div>
<div class="line"><span class="comment">// Enable the haptic driver by setting P1.0, which is connected</span></div>
<div class="line"><span class="comment">// to the DRV2605L ENABLE pin.  Then, load the configuration for the</span></div>
<div class="line"><span class="comment">// actuator, run an auto-calibration routine, set up for internal trigger</span></div>
<div class="line"><span class="comment">// mode, and select the linear resonant actuator (LRA) effect library.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">I2CMaster_open();</div>
<div class="line">P1OUT |= BIT0;</div>
<div class="line">DRV26x_reset();</div>
<div class="line">DRV26x_exitStandby();</div>
<div class="line">DRV26x_loadActuatorConfig(&amp;DRV26x_actuator_DMJBRN1030);</div>
<div class="line">DRV26x_runAutoCalibration();</div>
<div class="line">DRV26x_setMode(DRV26x_mode_internalTrigger);</div>
<div class="line">DRV26x_selectEffectLibrary(DRV26x_lib_ROM_LRA);</div>
</div><!-- fragment --><p>The <a class="el" href="ch_lib.html#ch_lib_howto_callbacks">callback</a> capability of the CapTIvate&trade; Software Library is utilized to trigger playback of haptic events directly from the library. A sample callback function is shown below. Effects are fired on a "new" touch- if "touch" is true and "previous touch" is false. Note that the callback exits if the guard mask is active. This would be the case if the guard channel was in detect, and the touch on this sensor must be masked.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Demo_numericKeypadHandler(tSensor* pSensor)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// If the guard mask is activated, abort here and do not process</span></div>
<div class="line">    <span class="comment">// any events.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (Demo_guardMaskActive == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// If the sensor has a new touch, fire a &quot;strong click&quot; effect.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> ((pSensor-&gt;bSensorTouch == <span class="keyword">true</span>) </div>
<div class="line">            &amp;&amp; (pSensor-&gt;bSensorPrevTouch == <span class="keyword">false</span>))</div>
<div class="line">    {</div>
<div class="line">        DRV26x_fireROMLibraryEffect(</div>
<div class="line">                DRV26x_effect_strongClick_100P,</div>
<div class="line">                <span class="keyword">true</span></div>
<div class="line">            );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Below is a mapping of the various DRV2605L haptic effects that are mapped to the different sensors:</p>
<table class="doxtable">
<tr>
<th align="left">Sensor</th><th align="left">Element</th><th align="left">Touchdown Effect</th><th align="left">Continued Effect  </th></tr>
<tr>
<td align="left">numericKeypadSensor</td><td align="left">All</td><td align="left">Strong Click (100%)</td><td align="left">None </td></tr>
<tr>
<td align="left">modeKeypadSensor</td><td align="left">Mute Button</td><td align="left">Double Click (100%)</td><td align="left">None </td></tr>
<tr>
<td align="left">modeKeypadSensor</td><td align="left">Speaker Button</td><td align="left">Strong Click (100%)</td><td align="left">None </td></tr>
<tr>
<td align="left">modeKeypadSensor</td><td align="left">Headset Button</td><td align="left">Strong Click (100%)</td><td align="left">None </td></tr>
<tr>
<td align="left">modeKeypadSensor</td><td align="left">End Call Button</td><td align="left">Triple Click (100%)</td><td align="left">None </td></tr>
<tr>
<td align="left">wheelButtonSensor</td><td align="left">Button</td><td align="left">Pulsing Sharp 1 (100%)</td><td align="left">None </td></tr>
<tr>
<td align="left">scrollWheelSensor</td><td align="left">Button</td><td align="left">Buzz 1 (100%)</td><td align="left">Soft Bump (100%) </td></tr>
<tr>
<td align="left">generalPurposeSliderSensor</td><td align="left">Button</td><td align="left">Buzz 1 (100%)</td><td align="left">Soft Bump (100%) </td></tr>
<tr>
<td align="left">volumeSliderSensor</td><td align="left">Button</td><td align="left">Buzz 1 (100%)</td><td align="left">Soft Bump (100%) </td></tr>
<tr>
<td align="left">proxAndGuardSensor</td><td align="left">Button</td><td align="left">Smooth Hum 3 (30%)</td><td align="left">None </td></tr>
</table>
<h3>Guard Channel Integration</h3>
<p>The guard channel is used as a detection mask for all other sensors in the system to provide a level of palm/arm rejection and spill rejection. The guard electrode wraps around the panel between all of the other sensors, and when it is not being measured, it serves as a grounded shield. The data from the guard channel is used to discern the case where a user accidentally puts their whole hand against the sensing panel. In that case, it would be very undesirable for all of the sensors to go into detect. It is also helpful in the event that the panel surface is being wiped down with a cloth or a liquid is spilled onto the panel.</p>
<p>Guard channel tuning requires the following considerations:</p><ol type="1">
<li>Tune the touch threshold to be sensitive enough to trigger a detect when a user is in between keys, but not when a user is correctly touching just one sensor.</li>
<li>Set the touch <a class="el" href="ch_Glossary.html#ch_glossary_debounce">de-bounce</a> <b>in</b> parameter to '0', and the <a class="el" href="ch_Glossary.html#ch_glossary_debounce">de-bounce</a> <b>out</b> parameter to the maximum of '15'. This causes the guard channel to engage immediately in a detect situation, and to remain in detect for 15 samples even after the user has cleared the threshold. This improves the robustness of the mask.</li>
<li>Set the touch <a class="el" href="ch_Glossary.html#ch_glossary_debounce">de-bounce</a> <b>in</b> of all other sensors to at least a value of '1', to ensure that the guard channel mask has one sample to kick in, preventing false touch detections.</li>
<li>Test multiple use-cases and approach angles to the panel to ensure that the guard channel touch detection flag is being set before the other sensors. This is fairly easy to discern with this demonstration because of the haptic feedback.</li>
</ol>
<p>The two LEDs on the CAPTIVATE-FR2633 module indicate the status of the guard channel. When a valid touch is detected on an element, LED1 will illuminate. When the guard channel is active, LED2 will illuminate.</p>
<p>The example callback handler for the guard channel is shown below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Demo_guardChannelHandler(tSensor *pSensor)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// If the guard channel is detecting a touch,</span></div>
<div class="line">    <span class="comment">// set the guard mask active flag to mask all other</span></div>
<div class="line">    <span class="comment">// touch processing.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (pSensor-&gt;bSensorTouch == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        Demo_guardMaskActive = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (pSensor-&gt; bSensorPrevTouch == <span class="keyword">false</span>)</div>
<div class="line">        {</div>
<div class="line">            DRV26x_fireROMLibraryEffect(</div>
<div class="line">                    DRV26x_effect_smoothHum3_30P,</div>
<div class="line">                    <span class="keyword">false</span></div>
<div class="line">                );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// If the guard channel is not detecting a touch,</span></div>
<div class="line">    <span class="comment">// clear the guard mask active flag to allow standard</span></div>
<div class="line">    <span class="comment">// touch processing.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        Demo_guardMaskActive = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the guard channel will not mask the reporting of touch and proximity events on other sensors to the CapTIvate&trade; Design Center. Rather, the mask is application-level and is used to control the haptic effect playback and LED illumination. The data flowing back to the design center provides the true state of each sensor at all times.</p>
<p>To begin working with this panel, go through the steps for <a class="el" href="ch_evm.html#ch_evm_get_started_loadingexample">running an example project</a> and open the CAPTIVATE-PHONE project.</p>
<p>For an overview of the hardware design, view the <a class="el" href="ch_evm.html#ch_evm_hardware_phone">CAPTIVATE-PHONE hardware overview</a>.</p>
<h2><a class="anchor" id="ch_evm_get_started_sensorpanels_prox"></a>
CAPTIVATE-PROXIMITY Demonstration</h2>
<p>This example demonstrates standard distance-detection proximity as well as proximity gesturing. In addition, it demonstrates the use of a driven shield sensor to reduce the parasitic capacitance of large electrodes, improving their sensitivity. The module has 4 total electrodes- 3 on the top layer, and one large electrode around the 3 on the top layer and across the entire bottom layer. The large electrode acts as a shield for parasitic capacitance, while the 3 primary electrodes on the top layer perform the sensing. 6 LED indicators on the top of the module indicate the status of the panel.</p>
<div class="image">
<img src="evm_prox_canvas.png" alt="evm_prox_canvas.png"/>
<div class="caption">
CAPTIVATE-PROXIMITY Design Canvas</div></div>
  <p>This panel is configured with the following settings:</p><ul>
<li><b>A 5ms active mode scan period (~200 Hz).</b> This is a very high scan rate that is biased towards being able to detect quick gestures. Scanning slower (at 20ms/50Hz for example) would provide lower power consumption, but the algorithm would begin to miss states and would potentially miss valid swipe detections.</li>
<li><b>An inactivity timeout of 375 samples.</b> This means that the system will transition from active mode into wake-on-proximity mode after 375 samples without any interaction have passed. This works out to about a 1.5-2 second delay.</li>
<li><b>A 33ms wake-on-proximity mode scan period (30 Hz).</b> Note that this is significantly slower than the 5ms period used in active mode- but it is also faster than the 100ms period used in the CAPTIVATE-BSWP panel. 33ms provides a good balance between fast wake-up to detect gestures, and overall power consumption.</li>
<li><b>A wakeup interval of 512 samples.</b> This means that the system will wake from the low-power wake-on-proximity state every 512 samples (about every 50 seconds) even if there is not a proximity detection. This provides a mechanism to periodically update the environmental filters for the other sensors on the PCB.</li>
<li><b>A 2 MHz conversion frequency</b> for the proximity sensor.</li>
<li><b>A total measurement time of 760us</b> for the proximity sensor.</li>
</ul>
<h3>Proximity Detection</h3>
<p>The 4 amber LEDs indicate prox detection on a given element (left, center, right, shield). Proximity is detected in the 5-10cm range, depending on the angle of approach.</p>
<h3>Swipe Detection</h3>
<p>The two green LEDs indicate whether or not a left or right swipe was detected above the panel. Waving your hand from left to right over the top of the panel triggers a right swipe, and waving from right to left triggers a left swipe. The LEDs are set after a valid swipe pattern is detected, and are cleared as soon as a new gesture is attempted by a new entry into the proximity field.</p>
<p>Gestures are detected through the use of a software state machine. All steps of the software state machine must be satisfied in order for a swipe to be detected.</p>
<table class="doxtable">
<tr>
<th align="left">Step</th><th align="left">Right Swipe Detection</th><th align="left">Left Swipe Detection  </th></tr>
<tr>
<td align="left">0</td><td align="left">No Detection</td><td align="left">No Detection </td></tr>
<tr>
<td align="left">1</td><td align="left">Left</td><td align="left">Right </td></tr>
<tr>
<td align="left">2</td><td align="left">Left Center</td><td align="left">Right Center </td></tr>
<tr>
<td align="left">3</td><td align="left">Left Center Right</td><td align="left">Right Center Left </td></tr>
<tr>
<td align="left">4</td><td align="left">Center Right</td><td align="left">Center Left </td></tr>
<tr>
<td align="left">5</td><td align="left">Right</td><td align="left">Left </td></tr>
</table>
<p>To begin working with this panel, go through the steps for <a class="el" href="ch_evm.html#ch_evm_get_started_loadingexample">running an example project</a> and open the CAPTIVATE-PROXIMITY project.</p>
<p>For an overview of the hardware design, view the <a class="el" href="ch_evm.html#ch_evm_hardware_prox">CAPTIVATE-PROXIMITY hardware overview</a>.</p>
<hr/>
<h1><a class="anchor" id="ch_evm_hardware"></a>
Hardware</h1>
<p>This section provides detailed information about the hardware in the kit.</p>
<h2><a class="anchor" id="ch_evm_kit_fr2633"></a>
CAPTIVATE-FR2633 Processor PCB Overview</h2>
<p>The CAPTIVATE-FR2633 PCB contains the MSP430FR2633 target microcontroller. Signals are brought in and out of the PCB in several different ways:</p><ol type="1">
<li>There is a 20-pin female debug connector on the top of the PCB. This connector provides power, SBW, UART, and I2C connectivity with the CAPTIVATE-PGMR module.</li>
<li>There is a 48-pin female sensor panel connector on the bottom of the PCB. All capacitive sensing IO are brought out to this connector, as well as power and I2C.</li>
<li>There is a 40-pin BoosterPack ecosystem header provision in the PCB, to allow the CAPTIVATE-FR2633 PCB to be a BoosterPack to another LaunchPad.</li>
<li>There is a 2-pin external power header on the right of the PCB, which provides a location to bring in battery power or some other external power source.</li>
</ol>
<p>The connection routing is shown below:</p>
<div class="image">
<img src="evm_fr2633_pcb.png" alt="evm_fr2633_pcb.png"/>
<div class="caption">
CAPTIVATE-FR2633 PCB</div></div>
  <div class="image">
<img src="evm_fr2633_block_diagram.png" alt="evm_fr2633_block_diagram.png"/>
<div class="caption">
CAPTIVATE-FR2633 Signal Flow</div></div>
  <div class="image">
<img src="evm_fr2633_mcu_diagram.png" alt="evm_fr2633_mcu_diagram.png"/>
<div class="caption">
CAPTIVATE-FR2633 MCU Pinout</div></div>
  <h3><a class="anchor" id="ch_evm_kit_fr2633_features"></a>
Features</h3>
<ul>
<li>MSP430FR2633 MCU with CapTIvate&trade; Capacitive Touch Technology<ul>
<li>15.5KB FRAM, 4KB RAM</li>
<li>12KB ROM (BSL, CapTIvate&trade; Software library, HID communications and MSP430-driverlib I2C and UART drivers)</li>
<li>16 CapTIvate&trade; I/O</li>
</ul>
</li>
<li>48-pin Sensor PCB connector<ul>
<li>16 CapTIvate&trade; I/O</li>
<li>5 GPIO</li>
<li>I2C</li>
<li>+3.3V LDO</li>
<li>+5V (VBUS)</li>
<li>Support for future CapTIvate&trade; devices with up to 32 CapTIvate&trade; I/O</li>
</ul>
</li>
<li>20-pin programmer / power/ communications connector<ul>
<li>Spy-Bi-Wire target MCU programming</li>
<li>Serial Communication with HID bridge</li>
<li>(2) +3.3V supply rails</li>
<li>+5V USB</li>
</ul>
</li>
<li>40-pin BoosterPack footprint<ul>
<li>Power, UART, I2C and 3 GPIO</li>
</ul>
</li>
<li>Selectable VCC power jumper J3<ul>
<li>Selectable VCC source from programmer PCB<ul>
<li>+3.3V EnergyTrace&amp;trade for energy measurements</li>
<li>+3.3V LDO provides up to 250mA to target MCU and Sensor PCB connector</li>
</ul>
</li>
<li>External supply or battery</li>
</ul>
</li>
</ul>
<h3>MSP430FR2633 MCU with CapTIvate&trade; Capacitive Touch Technology</h3>
<p>The MSP430FR2633 can operate from 1.8v to 3.6v, features up to 16-MHz system clock and 8-MHz FRAM access, 15.5KB of non-volatile FRAM and 4KB of data RAM. To help maximize the amount of FRAM code memory available to applications, the CapTIvate&trade; Software Touch Library, HID communications and MSP430-Driverlib I2C and UART drivers are provided in the 12KB of ROM and accessible through a simple API. Refer to the <a class="el" href="ch_lib.html">Software Library API</a> for further details.</p>
<p>The CapTIvate&trade; capacitive touch technology supports self and mutual capacitive measurements on 16 I/O pins, with parallel scanning and up to 64 electrodes. This flexibility allows designers the freedom to mix self and mutual type buttons, sliders, wheels and proximity sensors into a single design.</p>
<h3>Sensor PCB Connector (48 pin Female)</h3>
<div class="image">
<img src="evm_female_48P_connector.png" alt="evm_female_48P_connector.png"/>
<div class="caption">
Sensor Connector pinout</div></div>
  <p>The female connector shown above makes available all of the MSP430FR2633 16 CapTIvate&trade; I/O channels, I2C, +3.3V, +5V and several general purpose I/O. The middle row of this connector is reserved for future devices that support up to 32 CapTIvate&trade; I/O channels. On this PCB, all of the pins on row-B are grounded.</p>
<p>For information on the 48-pin Male version of this connector, refer to the <a class="el" href="ch_evm.html#ch_evm_hardware_connector48">Sensor PCB Connector.</a> </p>
<h3>Programming/Power/Communications Connector (20 pin Female)</h3>
<div class="image">
<img src="evm_female_20P_connector.png" alt="evm_female_20P_connector.png"/>
<div class="caption">
Programmer Connector pinout</div></div>
  <p>This female connector shown above is designed to connect with the CAPTIVATE-PGMR programmer PCB. This connector provides power, programming and communications between the two PCBs.</p>
<p><b>BoosterPack Connector Footprint</b> </p>
<p>The CAPTIVATE-FR2633 provides a standard 40-pin BoosterPack connector footprint providing +3.3V, +5V, UART, I2C and 5 GPIO signals. </p><div class="image">
<img src="evm_boosterpack_connector.png" alt="evm_boosterpack_connector.png"/>
<div class="caption">
Programmer Connector pinout</div></div>
  <p>Suggested BoosterPack header/connector</p><ul>
<li>SAMTEC DW-10-15-F-D-210, header, male</li>
<li>SAMTEC SSQ-110-23-G-D, connector, female</li>
</ul>
<p><b>Power</b> </p>
<p>The CAPTIVATE-FR2633 PCB has two power sources available through the 20-pin connector J2 when attached to the CAPTIVATE-PGMR PCB. One source is a +3.3V (VCC_LDO) that provides power to the 48-pin connector J10 for devices such as LED drivers or Haptics drivers on a sensor PCB. The second source is the eZFET&trade; with EnergyTrace&trade; Technology DC/DC +3.3V output (VCC_METERED).</p>
<p><b>Target MCU power</b> </p>
<p>Position the jumper J3 to pins(1-2) to select +3.3v LDO power source for the target MCU.</p>
<p><b>Measuring target MCU power</b> </p>
<p>EnergyTrace&trade; Technology makes it possible to measure the power consumed by the target MCU when using CCS or IAR IDE. Position the jumper J3 to pins(2-3) to select +3.3v METERED power source for the target MCU.</p>
<p><b>Programming/Debug</b> </p>
<p>The MSP430FR2633 MCU on this CAPTIVATE-FR2633 PCB is designed to be programmed and debugged through its Spy-Bi-Wire Interface. The full JTAG connection is not available on this PCB. </p>
<p><b>Note</b> The eZFET&trade; back-channel UART feature is not supported on the CAPTIVATE-FR2633 PCB.</p>
<p><b>Communication</b> </p>
<p>The MSP430FR2633 MCU communicates with a dedicated USB HID Bridge MCU located on the CAPTIVATE-PGMR PCB using UART or I2C communication to send sensor data and status to the CapTIvate Design Center as part of the sensor design and tuning process. A compact communications protocol is provided as part of the CapTIvate&trade; software library along with UART and I2C drivers. Both are located in the MSP430FR2633 ROM to minimize the impact on the FRAM memory footprint. The communications protocol is described in the <a class="el" href="ch_evm.html#ch_evm_hidbridge">HID Bridge Chapter</a>.</p>
<p>When used with CapTIvate&trade; protocol, the UART operates in a full duplex mode using RX and TX pins, and the I2C operates as an I2C Slave using SDA and SCL pins with an additional pin P1.2/IRQ to generate interrupt requests.</p>
<p>Jumpers are provided to allow isolation between the MSP430FR2633 and the 20-pin Programming and Communications connector, if one or more of the I/O pins need to be re-purposed. Pull up resistors for I2C SDA, SCL and IRQ signals are provided on the "isolated" side of jumpers.</p>
<div class="image">
<img src="evm_communication_jumpers.png" alt="evm_communication_jumpers.png"/>
<div class="caption">
Communication Isolation Jumpers</div></div>
  <table class="doxtable">
<tr>
<th align="center">Jumper</th><th align="center">Description</th><th align="center">Alternate Use  </th></tr>
<tr>
<td align="center">TXD</td><td align="center">MSP430FR2633 UART data out</td><td align="center">P1.4 </td></tr>
<tr>
<td align="center">RXD</td><td align="center">MSP430FR2633 UART data in</td><td align="center">P1.5 </td></tr>
<tr>
<td align="center">SDA</td><td align="center">MSP430FR2633 I2C data in/out</td><td align="center">P1.2 </td></tr>
<tr>
<td align="center">SCL</td><td align="center">MSP430FR2633 I2C clock input</td><td align="center">P1.3 </td></tr>
<tr>
<td align="center">IRQ</td><td align="center">MSP430FR2633 I2C slave Interrupt out</td><td align="center">P1.1 </td></tr>
<tr>
<td align="center">SYNC</td><td align="center">MSP430FR2633 CapTIvate&trade; Sync input</td><td align="center">P2.2 </td></tr>
</table>
<p><b>Extended I2C Bus</b> </p>
<p>The I2C signals are also present on the 48-pin sensor PCB connector. The I2C allows the MSP430FR2633 to control I2C slave devices, such as LED or Haptics drivers that might be installed on the sensor PCB.</p>
<p><b>Power Selection</b> </p>
<p>Both VCC_LDO and VCC_METERED are routed to a selection jumper J3 which provides power to the MSP430FR2633 MCU. For most applications the VCC_LDO is recommended as it provides a very well-regulated output. When the VCC_METERED output is selected, power consumed by the MCU can be measured using the EnergyTrace&trade; Feature in the CCS IDE. </p><div class="image">
<img src="evm_power_jumpers.png" alt="evm_power_jumpers.png"/>
<div class="caption">
MSP430 VCC selection</div></div>
  <p><b>External / Battery Power</b> </p>
<p>For battery powered applications, the MSP430FR2633 can be powered from an external 1.8V to 3.6V power source at the external power pads provided on the PCB. This allows the CAPTIVATE-FR2633 PCB and sensor PCB to be evaluated in an environment that is floating from any system or earth ground.</p>
<p><b>Caution</b> When evaluating the MSP430FR2633 with an external power source, jumper J3 on the CAPTIVATE-FR2633 PCB should be completely removed. This prevents any conflicts between VCC_LDO or VCC_METERED from the CAPTIVATE-PGMR PCB and the external power source. However, as part of any normal development/debugging process the CAPTIVATE-PGMR and CAPTIVATE-FR2633 PCBs can be connected through the CAPTIVATE-ISO PCB. Using the CAPTIVATE-ISO PCB allows programming with debug as well as I2C and UART communications with the target MCU.</p>
<hr/>
<h2><a class="anchor" id="ch_evm_hardware_pgmr"></a>
CAPTIVATE-PGMR Programmer PCB Overview</h2>
<p>The CAPTIVATE-PGMR PCB provides debug services. It includes an eZ-FET with EnergyTrace and a HID Bridge for bringing UART and I2C into a host PC.</p>
<div class="image">
<img src="evm_programmer_pcb.png" alt="evm_programmer_pcb.png"/>
<div class="caption">
pcb</div></div>
  <div class="image">
<img src="evm_programmer_block_diagram.png" alt="evm_programmer_block_diagram.png"/>
</div>
 <h3><a class="anchor" id="ch_evm_kit_pgmr_features"></a>
Features</h3>
<ul>
<li>eZFET&trade; with EnergyTrace&trade; Technology<ul>
<li>Simple Spy-Bi-Wire target MCU programming</li>
<li>Can be used to program any MSP430</li>
<li>Separate +3.3 V outputs available for MCU<ul>
<li>EnergyTrace&trade;</li>
<li>Dedicated LDO</li>
</ul>
</li>
</ul>
</li>
<li>20-pin programmer / power/ communications connector<ul>
<li>Spy-Bi-Wire Interface</li>
<li>UART and I2C Serial Communication with target</li>
<li>(2) +3.3V supply rails</li>
<li>+5V USB</li>
</ul>
</li>
<li>USB HID Serial Bridge<ul>
<li>Provides interface between CapTIvate&trade; Design Center and target MCU</li>
<li>Supports UART and I2C</li>
<li>HID - No drivers to install</li>
<li>Supports up to 250k baud</li>
<li>Easy update via BSL</li>
</ul>
</li>
</ul>
<h3>Programming/Power/Communications Connector (20 pin Male)</h3>
<div class="image">
<img src="evm_male_20P_connector.png" alt="evm_male_20P_connector.png"/>
<div class="caption">
Programmer Connector pinout</div></div>
  <p>The male connector shown above is designed to connect with the CAPTIVATE-FR2633 MCU PCB. This connector provides power, programming and communications between the two PCBs.</p>
<p><b>Power</b> </p>
<p>Power to the CAPTIVATE-PGMR PCB is provided through the USB connector at approximately 5VDC. A TI TPS73533 +3.3V, 500mA LDO provides power for all the devices on the CAPTIVATE-PGMR. This +3.3V output is referred to as VCC_LDO and is made available to the MSP430FR2633 target MCU on the CAPTIVATE-FR2633 PCB when attached. The eZFET&trade; with EnergyTrace&trade; Technology also provides a DC/DC +3.3V output. This output is referred to as VCC_METERED and is available only to the target MCU for energy measurements. A jumper on the CAPTIVATE-FR2633 PCB selects between the two sources for the MSP430FR2633.</p>
<p><b>Note:</b> The CAPTIVATE-PGMR is considered a low-power USB device and therefore should draw at most 100mA. The CAPTIVATE-PGMR PCB draws a nominal 60mA. This allows any target to draw up to 40mA.</p>
<p><b>Programming/Debug</b> </p>
<p>The eZFET&trade; provides programming and debugging through its Spy-Bi-Wire Interface.</p>
<p>The eZFET&trade; back-channel UART feature is available on this PCB, however, the CAPTIVATE-FR2633 does not support this feature.</p>
<p><b>Using Spy-Bi-Wire (SBW) programming with CAPTIVATE-ISO PCB</b> Refer to <a class="el" href="ch_evm.html#ch_evm_kit_iso_features">JTAG and SBW Limitations</a></p>
<h3>Target Communication via the USB HID Serial Bridge</h3>
<p>The CAPTIVATE-PGMR PCB features a HID-Bridge which enumerates as a USB HID device and does not require any drivers to be installed on the PC. It supports both I2C and UART interfaces and is factory programmed with a compact communications protocol for sending sensor data and status between the target MCU and the CapTIvate&trade;; Design Center. For detailed information regarding the communications protocol, refer to <a class="el" href="ch_evm.html#ch_evm_hidbridge">HID Bridge Chapter</a>.</p>
<p>Key features include:</p><ul>
<li>Supports UART and I2C interfaces</li>
<li>Factory programmed with CapTIvate&trade; Protocol</li>
<li>No USB drivers needed</li>
<li>Easy firmware updates using USB BSL</li>
<li>For more information, see the <a class="el" href="ch_evm.html#ch_evm_hidbridge">HID Bridge</a> section.</li>
</ul>
<p>The MSP430F5528 Bridge MCU supports firmware updates using USB BSL. To update the existing firmware or load a user-defined firmware image, use the "Python Firmware Upgrade" utility provided with MSP430ware. Depending on where MSP430ware has been installed on your computer, navigate to the "...\MSP430ware...\usblib430\Host_USB_Software\Python_Firmware_Upgrader" directory.</p>
<ul>
<li>Place the MSP430F5528 into BSL mode<ul>
<li>Press and hold RESET button (S300)</li>
<li>Press BSL button (S301)</li>
<li>Release RESET button</li>
<li>Release BSL button</li>
</ul>
</li>
<li>Launch the firmware upgrade utility<ul>
<li>Double-click on the utility icon (the utility will scan the USB bus looking for a specific VID/PID combination of the MSP430F5528 in BSL mode).</li>
<li>If no device is found, repeat the steps above to place the MSP430F5528 into BSL mode and select "File&gt;Rescan Bus" in the utility menu.</li>
<li>When ready, select "File&gt;Open user firmware" from the utility menu to select the firmware image and begin the update process.</li>
</ul>
</li>
</ul>
<hr/>
<h2><a class="anchor" id="ch_evm_hardware_iso"></a>
CAPTIVATE-ISO (Communications Isolation PCB)</h2>
<p>The CAPTIVATE-ISO PCB provides a way to maintain SBW, I2C, and UART communication when the CAPTIVATE-FR2633 target is powered from an external power source such as a battery or another system.</p>
<div class="image">
<img src="evm_iso_pcb.png" alt="evm_iso_pcb.png"/>
<div class="caption">
CAPTIVATE-ISO PCB</div></div>
  <div class="image">
<img src="evm_iso_block_diagram.png" alt="evm_iso_block_diagram.png"/>
<div class="caption">
Block Diagram</div></div>
  <h3><a class="anchor" id="ch_evm_kit_iso_features"></a>
Features</h3>
<ul>
<li>Provides galvanic isolation for SBW programming/debug, I2C and UART communications<ul>
<li>TI low power digital isolators<ul>
<li>ISO1541 for Spy-by-Wire</li>
<li>ISO7131 for UART</li>
<li>ISO1540 for I2C</li>
</ul>
</li>
<li>No shared power or grounds</li>
</ul>
</li>
<li>Use when performing<ul>
<li>Tuning battery powered applications</li>
<li>Conducted noise testing</li>
</ul>
</li>
</ul>
<h3>Isolated JTAG Spy-Bi-Wire</h3>
<p>The CAPTIVATE-ISO PCB provides isolated Spy-Bi-Wire programming and debugging. Due to the added delays in the SBW timing,, it is recommended to use the default medium JTAG/SBW speed or slower. JTAG/SBW speed = FAST is not supported at this time.</p>
<h3>Typical Isolated Setup</h3>
<p>The diagram below illustrates a typical setup using an isolated power supply or battery to power the CAPTIVATE-FR2633 MCU target PCB.</p>
<div class="image">
<img src="evm_iso_pcb_setup.png" alt="evm_iso_pcb_setup.png"/>
<div class="caption">
Typical Setup</div></div>
  <p><b>Important:</b> To guarantee proper operation, power the "Target" side of the CAPTIVATE-ISO PCB with an external power source that meets the VCC minimum operating voltages shown in the table below. These values are provided for convenience only. Please consult the corresponding device's datasheet for more information.</p>
<table class="doxtable">
<tr>
<th align="center">Isolator</th><th align="center">Min Operating VCC  </th></tr>
<tr>
<td align="center">TI ISO1540 </td><td align="center">3.0 </td></tr>
<tr>
<td align="center">TI ISO1541 </td><td align="center">3.0 </td></tr>
<tr>
<td align="center">TI ISO7131 </td><td align="center">2.7 </td></tr>
</table>
<p>The maximum "Target" side voltage should not exceed the MSP430FR2633 VCC maximum operating voltage 3.6 VDC.</p>
<h3>Connectors</h3>
<div class="image">
<img src="evm_iso_pcb_connectors.png" alt="evm_iso_pcb_connectors.png"/>
<div class="caption">
Connectors</div></div>
  <hr/>
<h2><a class="anchor" id="ch_evm_hardware_bswp"></a>
CAPTIVATE-BSWP</h2>
<p>The CAPTIVATE-BSWP is a demonstration sensing panel with buttons, a slider, a wheel, and a proximity sensor. All of the sensors on this panel are self-capacitance sensors. The sensing panel serves the following purposes:</p>
<ol type="1">
<li>Demonstrates low power design principles for a battery powered application</li>
<li>Demonstrates the slider and wheel resolution that is achievable through the use of self capacitance</li>
<li>Serves as a reference layout for the recommended way to design a slider or wheel sensor</li>
<li>Exercises all 16 CapTIvate&trade; sensing IOs on the MSP430FR2633</li>
<li>Demonstrates use of the CapTIvate&trade; wake-on-proximity feature for low power consumption</li>
<li>Demonstrates use of the CapTIvate&trade; Design Center Auto-Assign feature for automatic pin routing</li>
</ol>
<div class="image">
<img src="evm_bswp_pcb.png" alt="evm_bswp_pcb.png"/>
<div class="caption">
CAPTIVATE-BSWP</div></div>
  <h3>Sensor Design and Organization</h3>
<p>The 16 CapTIvate&trade; IOs are fully utilized by this panel. They are organized as shown in the diagram below.</p>
<div class="image">
<img src="evm_bswp_electrodes.png" alt="evm_bswp_electrodes.png"/>
<div class="caption">
Electrode Mapping</div></div>
  <h4>Button Group Sensor with 8 Buttons</h4>
<p>The button group sensor has 8 buttons, or "elements." They are connected to the following IO: CAP0.0, CAP1.0, CAP2.0, CAP3.0, CAP0.1, CAP1.1, CAP2.1, and CAP3.1. Note how the CapTIvate&trade; Design Center auto-assign feature selected two pins from each measurement block. This enables parallel scanning in 2 groups of 4 elements. Basic 10mm diameter circular electrodes were used for the buttons. A ground hatch was utilized underneath the electrodes, but was hollowed out underneath them to improve sensitivity and consequently power consumption, which was a design goal for this panel. For more information on button layouts, see the <a class="el" href="ch_design.html#ch_design_self_buttons">design guide</a>.</p>
<div class="image">
<img src="evm_bswp_buttons.png" alt="evm_bswp_buttons.png"/>
<div class="caption">
Button Layout</div></div>
  <h4>Slider Sensor with 4 Elements</h4>
<p>The slider sensor has 4 elements. They are connected to the following IO: CAP0.2, CAP1.2, CAP2.2, and CAP3.2. Again, one pin was routed from each block to enable parallel scanning of the entire slider. This is very important for achieving the best possible linearity from a slider.</p>
<p>Linearity is defined as the linear accuracy of the reported position of a slider or wheel sensor. It's a measure of how accurately the slider reports back position. For example, a touch in the center of a slider with 1000 points of resolution should return a value in the range of 490-510, not 400 or 600. Additionally, the slider should maintain that accuracy throughout the range of the slider. An example of poor slider performance would be what is called "stair stepping", where the position reported moves quickly, then slowly, then quickly again, all while a touch is moving at a constant rate.</p>
<p>By scanning all 4 slider elements in parallel, three performance improvements are attained. First, because each electrode is driven at the same voltage, there will minimal E-field between the electrodes. This reduces the parasitic capacitance of each electrode. If they had to be scanned sequentially, neighboring electrodes would have to be grounded during a scan- meaning they look like a large parasitic capacitance. By scanning them in parallel, it is possible to tightly pack the electrodes together, optimizing surface area coverage and sensitivity. Second, there is no latency in the scan. With sequential scanning, by the time the 4th electrode is scanned the touch may be in a different location then when the first scan was performed- distorting the raw data that is fed to the position algorithm and reducing the accuracy of the slider to time changing touches. Third, the slider has common mode noise rejection because of the fact that all electrodes are scanned together. If noise effects one channel, it will affect all channels evenly. This has the overall effect of ensuring that a stable position is reported even in the presence of noise.</p>
<div class="image">
<img src="evm_bswp_slider.png" alt="evm_bswp_slider.png"/>
<div class="caption">
Slider Layout</div></div>
  <p>From a layout perspective, the inter-digitation of each element must be as linear as possible to enable linear position tracking. The performance of the slider is only as good as the layout. One feature of this slider is that the outer element is actually split into two pieces, one on each end, connected together to the same pin. The easiest way to think about this configuration is to think of it as a wheel that was "chopped" at the top, and unrolled to be flat. This provides the most linear performance, because the algorithm is going to resolve the slider back to a unit circle.</p>
<p>The proximity sensor that surrounds the slider is grounded during the scan of the slider. This serves to limit the interaction area to the slider, as fringing E-field lines from the edges of the sensor will be reduced because of the grounded sensor nearby.</p>
<h4>Wheel Sensor with 3 Elements</h4>
<p>The wheel has 3 elements. They are connected to the following IO: CAP0.3, CAP1.3, and CAP2.3. The design principles for the wheel are the same as for the slider.</p>
<div class="image">
<img src="evm_bswp_wheel.png" alt="evm_bswp_wheel.png"/>
<div class="caption">
Wheel Layout</div></div>
  <h4>Proximity Sensor with 1 Element</h4>
<p>The proximity has 1 element connected to CAP3.3. The proximity sensor serves as a wake-up sensor for the rest of the panel. It was designed to wrap around the existing sensors already on the panel. By providing surface area around the existing sensors, it can detect when a user is close to any given sensor and use that information to wake the MCU from LPM3.</p>
<div class="image">
<img src="evm_bswp_prox.png" alt="evm_bswp_prox.png"/>
<div class="caption">
Proximity Layout</div></div>
  <p>Note that there is no ground plane underneath of the proximity electrode. This was done intentionally to improve the sensitivity.</p>
<p>To explore the demonstration for this panel, check out the <a class="el" href="ch_evm.html#ch_evm_get_started_sensorpanels_bswp">CAPTIVATE-BSWP demonstration</a> section.</p>
<hr/>
<h2><a class="anchor" id="ch_evm_hardware_phone"></a>
CAPTIVATE-PHONE</h2>
<p>The CAPTIVATE-PHONE is a demonstration sensing panel with 17 buttons, 2 sliders, a wheel, and a proximity/guard sensor. There is also a DRV2605L haptic driver IC with a Samsung linear resonant actuator (LRA) for vibrational feedback. The sensing panel serves the following purposes:</p>
<ol type="1">
<li>Demonstrates how to matrix mutual capacitance sensors for high density and low pin count</li>
<li>Serves as a reference layout for the recommended way to design a mutual capacitance slider or wheel sensor</li>
<li>Demonstrates a hybrid technology approach that has mutual and self capacitance in the same design</li>
<li>Demonstrates the re-purposing of a proximity sensor as a guard channel</li>
<li>Demonstrates a real-world application (desk phone interface)</li>
</ol>
<div class="image">
<img src="evm_phone_pcb.png" alt="evm_phone_pcb.png"/>
<div class="caption">
CAPTIVATE-PHONE</div></div>
  <h3>Sensor Design and Organization</h3>
<p>Only 12 CapTIvate&trade; IOs are used for this demonstration, which has 29 elements! A mutual capacitance matrix made up of 4 Rx lines and 7 Tx lines (11 total pins) forms 28 elements. The 29th element is a self-capacitance guard channel and proximity combo sensor. The guard and proximity sensor is on CAP3.3. The 4 Rx lines are shared between all of the mutual capacitance sensors, and are connected to CAP0.0, CAP1.0, CAP2.0, and CAP3.0. Just like the CAPTIVATE-BSWP panel, selecting one receive line from each measurement block allows for efficient parallel scanning of 4 elements at a time.</p>
<div class="image">
<img src="evm_phone_IO.png" alt="evm_phone_IO.png"/>
<div class="caption">
CAPTIVATE-PHONE</div></div>
  <h4>Numeric Keypad and Mode Keypad</h4>
<p>The CAPTIVATE-PHONE demonstration utilizes the basic mutual capacitance button layout as shown in the <a class="el" href="ch_design.html#ch_design_mutual_buttons">design guide</a>. This geometry is easy to lay out and provides more than adequate sensitivity for this application. Note that the guard channel is routed between the buttons. This will serve as a ground shield while the buttons are being measured.</p>
<div class="image">
<img src="evm_phone_buttons.png" alt="evm_phone_buttons.png"/>
<div class="caption">
Keypad Buttons (Square)</div></div>
  <h4>Wheel Button</h4>
<p>The wheel selection button in the center of the wheel demonstrates how the geometry may also be radial with similar performance. Testing has revealed that E-field lines concentrate at the 90-degree corners of the square geometry, improving sensitivity. However, a radial geometry is still viable and is more applicable to the wheel button case because of the surrounding wheel sensor. Note that there is a ground fill between the wheel itself and the wheel button. This serves to provide shielding for the button, so that a touch on the edge of the wheel does not trigger the button.</p>
<div class="image">
<img src="evm_phone_wheel_button.png" alt="evm_phone_wheel_button.png"/>
<div class="caption">
Wheel Button (Circular)</div></div>
  <h4>Scroll Wheel</h4>
<p>The scroll wheel implementation on this PCB is effectively a condensed self-capacitance wheel for the Rx electrodes, with an inner and outer Tx ring forming the mutual coupling. This topology works quite well for creating a mutual capacitance wheel.</p>
<div class="image">
<img src="evm_phone_wheel.png" alt="evm_phone_wheel.png"/>
<div class="caption">
Scroll Wheel</div></div>
  <p>With slider and wheel design it is extremely important to match the parasitic capacitances as best as possible to ensure the best linearity. In the case of mutual capacitance, this means parasitic <em>mutual</em> capacitance. This type of parasitic shows up wherever Rx's and Tx's are brought close together. Usually it is straightforward to minimize trace parastics, but it can be difficult on larger PCBs such as this, or PCBs that have connectors. Drastic differences in parasitic capacitance lead to differences in sensitivity between electrodes in the slider or wheel, which will negatively impact the linearity. The CapTIvate&trade; technology calibration routine will reduce these effects to a certain extent, but it is always best to start with a good layout. Be aware of where your Rx's and Tx's come close together, and minimize these areas as much as possible by crossing them at 90-degree angles and placing ground between them if they run parallel to each other. This will serve to improve sensitivity as well as linearity.</p>
<h4>Slider Sensors (General Purpose and Volume Slider)</h4>
<p>The CAPTIVATE-PHONE sensing panel has two mutual capacitance sliders of different lengths. Both have 4 elements each based on the 4 shared Rx electrodes. The same layout technique is applied to both sliders, and it is quite easy to implement in most layout packages. Just like the scroll wheel, the Rx electrodes are encapsulated by two Tx tracks. Rather than the complex inter-digitation of the wheel layouts and the self-capacitance slider, a simple triangle design is implemented for this PCB.</p>
<div class="image">
<img src="evm_phone_slider.png" alt="evm_phone_slider.png"/>
<div class="caption">
Slider Sensor</div></div>
  <p>Note that just like the self-capacitance slider on the CAPTIVATE-BSWP panel, the end elements are "half" elements, and they are connected together as if they were one full size element. This technique provides the pest performance from the position algorithm. If a smaller slider is desired, it is acceptable to drop an inner element at implement a 3-element slider using the same approach.</p>
<h4>Proximity and Guard Sensor</h4>
<p>The proximity and guard sensor is simply a fill that flows in between all of the other sensor elements on the PCB. This is the only self-capacitance sensor on the panel.</p>
<h5>Proximity Functionality</h5>
<p>From a proximity perspective, the electrode does not offer large sensing distances because it is directly above the ground hatch on the bottom layer. This creates a large parasitic capacitance on the order of 200pF, and it also reduces the E-field penetration into the area above the panel. A distance of a few centimeters is attainable- but not 5-10cm.</p>
<h5>Guard Channel Functionality</h5>
<p>The guard channel functionality is essentially a re-purposing of the proximity sensor data. Because the proximity/guard electrode wraps around all of the sensors, it can be used as a detection mask for the other sensors. What this means is that when the guard channel reaches a certain level of interaction (the touch threshold), reporting of touches on other sensors is <em>masked</em> by the guard channel detection. This prevents other sensors from triggering if someone puts their whole palm down on the panel, or wants to wipe it down for cleaning purposes.</p>
<p>To explore the demonstration for this panel, check out the <a class="el" href="ch_evm.html#ch_evm_get_started_sensorpanels_phone">CAPTIVATE-PHONE demonstration</a> section.</p>
<hr/>
<h2><a class="anchor" id="ch_evm_hardware_prox"></a>
CAPTIVATE-PROXIMITY</h2>
<p>The CAPTIVATE-PROXIMITY is a demonstration proximity sensing panel with 4 electrodes. There are also 6 status LED indicators on the PCB: 4 for proximity detection, and 2 for gesture detection. The sensing panel serves the following purposes:</p>
<ol type="1">
<li>Demonstrates how to implement proximity gesturing to improve the robustness of a proximity application such as a paper towel dispenser</li>
<li>Serves as a reference layout for the implementation of a driven shield electrode with a CapTIvate&trade; IO to reduce parasitic capacitance</li>
<li>Demonstrates the use of muxed CapTIvate&trade; IOs as active-low LED current sinks.</li>
</ol>
<div class="image">
<img src="evm_proximity_pcb.png" alt="evm_proximity_pcb.png"/>
<div class="caption">
CAPTIVATE-PROXIMITY</div></div>
  <h3>Sensor Design and Organization</h3>
<p>The module's 4 electrodes are connected to CAP0.3, CAP1.3, CAP2.3, and CAP3.3. CAP1.3 is used for the shield electrode, which is a solid plane across the bottom layer of the PCB and a ring around the 3 zones on the top layer of the PCB. CAP0.3, CAP2.3, and CAP3.3 are used to drive the left, center, and right zones, respectively. These three IO's are all dedicated capacitive sensing IO's- they are not muxed with GPIO functionality. As a result, they are not connected to the DVCC IO rail internally. While they have similar sensitivity when compared with muxed IO's, in theory they will be less effected by any switching noise that may be present on that rail due to a PWM, I2C, or other digital signal. All 4 electrodes are measured in parallel (one per sensing block).</p>
<div class="image">
<img src="evm_prox_top.png" alt="evm_prox_top.png"/>
<div class="caption">
Proximity Sensors</div></div>
  <h4>Shield Theory</h4>
<p>Because all four electrodes are driven in parallel off of the same conversion clock, the potential difference between the various electrodes will be small. This means that the E-field between them (and thus, the result parasitic capacitance) will also appear quite small to the electrode. This parasitic reduction directly results in an improvement in overall sensitivity. It should be noted that the shield does not provide immunity to proximity interactions below the shield. If immunity to proximity on one side of an electrode is needed, a light (&lt;20%) ground hatch is a better structure.</p>
<hr/>
 <h2><a class="anchor" id="ch_evm_hardware_connector48"></a>
48-pin Male Sensor PCB Connector Information</h2>
<p>All demo sensor PCBs use the same 48 pin male connector that is commonly available from various manufacturers and suppliers. The following mechanical information will be useful if designing your own PCB to connect to the CAPT-FR2633 PCB. Below is a list of manufacturer part numbers: </p><table class="doxtable">
<tr>
<th align="center">Manufacturer</th><th align="center">Part No</th><th align="center">Digikey No  </th></tr>
<tr>
<td align="center">FCI</td><td align="center">86093487313H55ELF</td><td align="center">609-4951-ND </td></tr>
<tr>
<td align="center">Harting</td><td align="center">09 23 148 6921</td><td align="center">1195-1856-ND </td></tr>
<tr>
<td align="center">Harting</td><td align="center">09 23 148 2921</td><td align="center">1195-1854-ND </td></tr>
</table>
<div class="image">
<img src="evm_sensor_male_connector_schematic.png" alt="evm_sensor_male_connector_schematic.png"/>
<div class="caption">
Sensor Connector pinout</div></div>
  <div class="image">
<img src="evm_male_48P_connector.png" alt="evm_male_48P_connector.png"/>
<div class="caption">
Sensor Connector pinout</div></div>
  <hr/>
<h1><a class="anchor" id="ch_evm_hidbridge"></a>
Using the HID Bridge</h1>
<p>The HID Bridge is a multi-purpose development tool that provides a way to interface platform software (such as a PC GUI) with embedded systems containing basic serial interfaces (such as UART or I2C). The HID Bridge is a firmware product designed to run on an MSP430F5xx MCU with USB support. Typical implementations (such as the CAPTIVATE-PGMR) utilize an MSP430F5528 MCU.</p>
<p>The HID Bridge enables bidirectional transfer of data from a serial interface to a host platform via the USB HID device class. HID provides a unique advantage over other competing interfaces. Unlike USB CDC devices, no COM port identification is necessary on the host and no drivers are required on most modern operating systems. In addition, HID devices are much better suited to hot-swapping (disconnection and re-connection). During embedded system development it is very common to disconnect and re-connect development tools; using HID makes this process seamless.</p>
<div class="image">
<img src="evm_bridge_diagram.png" alt="evm_bridge_diagram.png"/>
<div class="caption">
HID Bridge Diagram</div></div>
  <h3>Supported Modes of Operation</h3>
<p>The HID Bridge provides the following modes of operation:</p>
<ul>
<li>HID to Unformatted Raw UART (bi-directional full-duplex up to 250k baud)</li>
<li>HID to Formatted UART (bi-directional full-duplex up to 250k baud, with intelligent packet identification and framing)</li>
<li>HID to Unformatted Raw I2C Master (Up to 400kbps I2C master)</li>
<li>HID to Formatted I2C Master (Up to 400kbps I2C master, with intelligent packet identification, framing and slave IRQ handling)</li>
</ul>
<h2><a class="anchor" id="ch_evm_hidbridge_interfaces"></a>
HID Bridge Interfaces</h2>
<h3>Host Interface: USB HID Device-Class Implementation</h3>
<p>The bridge enumerates on the USB host as a composite class human interface device (HID). Two HID devices enumerate:</p>
<ul>
<li>HID0, the data transfer interface<ul>
<li>Used for transmission of data between the target and the host</li>
<li>Data is binary formatted</li>
</ul>
</li>
<li>HID1, the HID Bridge configuration console interface<ul>
<li>Used for configuration of the HID Bridge itself via the <a class="el" href="ch_evm.html#ch_evm_hidbridge_commandset">HID Bridge (HB) command set</a></li>
<li>Commands are ASCII string formatted</li>
</ul>
</li>
</ul>
<h3>Target Interface: UART Implementation</h3>
<p>The HID Bridge target UART interface is a bi-directional, full-duplex, two-wire UART interface that supports several common baud rates.</p>
<p>The baud rates supported are: 250kBaud, 115.2kBaud, 38.4kBaud, 19.2kBaud, and 9.6kBaud. The HID Bridge, when configured in UART mode, is constantly listening to the target UART port and may receive data at any time, even while it is transmitting data to the target. The UART baud rate is configurable via the HB command set.</p>
<p>The UART implementation also supports a "byte delay" feature for slow targets. This feature will insert a delay (in ms) between the start-of-transmission of each byte. This can allow a fast (250kBaud) rate to be used, but the bytes will be spaced out to allow the target to have time to service its UART interrupt service routine. When the target is sending data, it can still send at the full 250kBaud rate- but it doesn't have to respond to a data stream at that rate, because bytes will be spaced. The UART delay is configurable via the HB command set.</p>
<h3>Target Interface: I2C Implementation</h3>
<p>When configured in I2C mode, the HID Bridge acts as an I2C bus master that communicates with an I2C slave device.</p>
<p>The HID Bridge initiates writes to the target by initiating a start/write condition to the slave address that is selected, writing the data, and issuing an I2C stop condition.</p>
<p>The slave can request a read by pulling the I2C IRQ line low until the HID Bridge reads out the data from the target. Once the HID Bridge issues a start/read condition to the slave, the slave must release the IRQ line. The first byte read by the master is expected to be a length field that indicates to the HID Bridge how many further bytes it should read from the slave. The master will then continue the read, reading out that many bytes, then issuing a stop condition.</p>
<h2><a class="anchor" id="ch_evm_hidbridge_commandset"></a>
HID Bridge Configuration Command Set</h2>
<p>The HID Bridge is configured by the host platform through the sending and receiving of HID Bridge "HB" commands over the configuration console HID interface. The available configuration commands are described below.</p>
<table class="doxtable">
<tr>
<th align="center">Command</th><th align="center">Description</th><th align="center">Arguments?</th><th align="center">Valid Arguments (1)</th><th align="center">ValidArguments (2)  </th></tr>
<tr>
<td align="center">HB VERSION</td><td align="center">Get the version string.</td><td align="center">None</td><td align="center">-</td><td align="center">- </td></tr>
<tr>
<td align="center">HB PLATFORM</td><td align="center">Get the platform string.</td><td align="center">None</td><td align="center">-</td><td align="center">- </td></tr>
<tr>
<td align="center">HB UPGRADE</td><td align="center">Enter the USB bootloader.</td><td align="center">None</td><td align="center">-</td><td align="center">- </td></tr>
<tr>
<td align="center">HB REBOOT</td><td align="center">Reboot the HID Bridge.</td><td align="center">None</td><td align="center">-</td><td align="center">- </td></tr>
<tr>
<td align="center">HB MODE</td><td align="center">Get/set the operating mode.</td><td align="center">Format, Interface</td><td align="center">RAW, PACKET</td><td align="center">UART, I2C </td></tr>
<tr>
<td align="center">HB SAVECONFIG</td><td align="center">Save the active or default configuration to boot memory.</td><td align="center">Config to save</td><td align="center">ACTIVE, DEFAULT</td><td align="center">- </td></tr>
<tr>
<td align="center">HB UARTBAUD</td><td align="center">Get/set the UART baud rate.</td><td align="center">New baud rate</td><td align="center">250000, 115200, 38400, 19200, 9600</td><td align="center">- </td></tr>
<tr>
<td align="center">HB UARTDELAY</td><td align="center">Get/set the UART byte delay period.</td><td align="center">New delay period</td><td align="center">0 to 1000</td><td align="center">- </td></tr>
<tr>
<td align="center">HB I2CADDRESS</td><td align="center">Get/set the target I2C slave address.</td><td align="center">New address</td><td align="center">0 to 127</td><td align="center">- </td></tr>
<tr>
<td align="center">HB I2CCLOCK</td><td align="center">Get/set the target I2C clock freq.</td><td align="center">New frequency</td><td align="center">100000, 400000</td><td align="center">- </td></tr>
</table>
<p>For the commands that have no arguments, simply send "HB x" where x is the command. For commands with arguments, sending "HB x" where x is the command will echo back the current setting of that command, if supported. If valid parameters are passed (for example, "HB UARTBAUD 250000"), the parameter will be updated to the new value passed.</p>
<p>Note that the Captivate Design Center will automatically send configuration commands on this interface based on the current Design Center project that is open.</p>
<h2><a class="anchor" id="ch_evm_hidbridge_modesofoperation"></a>
HID Bridge Modes of Operation</h2>
<p>The HID bridge supports several different modes of operation as introduced above. The details behind how each mode behaves are described in this section. The operating mode may be set via the HID Bridge command set.</p>
<h3><a class="anchor" id="ch_evm_hidbridge_modesofoperation_packet"></a>
Operating Mode: Packet Mode</h3>
<p>Packet mode requires that data sent over the target interface be formatted in packets according to the following set of transmission rules. The HID Bridge will buffer all data received from the target. It will then identify and frame packets to be sent to the host. When sending packets to the host, each packet will be transmitted in its own HID report. The HID Bridge buffers all packets coming from the host, and applies the relevant transmission rules before sending the packet on to the target.</p>
<p>If any transactions are of the following type, they are subject to the transmission rules:</p><ul>
<li>Packets from the target to the HID Bridge in PACKET/UART Mode</li>
<li>Packets from the HID Bridge to the target in PACKET/UART Mode</li>
<li>Packets from the HID Bridge to the target in PACKET/I2C Mode</li>
</ul>
<p>The transmission rules for the serial interface in packet mode are as follows:</p><ul>
<li>All packets will begin with a 3-byte header, consisting of:<ul>
<li>[0] A SYNC byte at position 0, equal to 55h</li>
<li>[1] A BLANK byte at position 1, that is NOT equal to 55h. Typically , AAh is used.</li>
<li>[2] A LENGTH byte at position 2, that indicates the size of the payload and checksum in bytes (payload length + 2)</li>
</ul>
</li>
<li>All packets may contain a payload up to 60 bytes, which may contain any binary data<ul>
<li>If the SYNC byte (55h) should occur in the payload section, it must be sent twice (byte stuffed) to distinguish it from a true SYNC byte. This repeated byte does NOT count towards the maximum payload size of 60 bytes.</li>
</ul>
</li>
<li>All packets will end with a 2-byte checksum.<ul>
<li>The checksum is calculated as the lower 16 bits of the summation of the payload section, less any stuffed bytes (repeated 55h bytes).</li>
<li>The checksum is send lower byte first, upper byte second.</li>
</ul>
</li>
</ul>
<p>Per these rules, a packet would have the following format: </p><div class="image">
<img src="evm_bridge_serial_com_packet_format.png" alt="evm_bridge_serial_com_packet_format.png"/>
<div class="caption">
Serial Interface Packet with Transmission Rules Applied</div></div>
  <p>All other packet types (the remaining types are listed below), only require that a checksum be appended to the payload.</p><ul>
<li>Packets from the target to the HID Bridge in PACKET/I2C Mode</li>
<li>Packets from the HID Bridge to the host in any mode</li>
</ul>
<p>Note that the HID Bridge strips out the transmission rule overhead (if applied) when sending the payload and checksum on to the host. The SYNC, BLANK, and LENGTH bytes are removed, and any stuffed bytes in the payload section are removed. The checksum is preserved and is sent on. </p><div class="image">
<img src="evm_bridge_usb_hid_packet_format.png" alt="evm_bridge_usb_hid_packet_format.png"/>
<div class="caption">
Base Packet without Transmission Rules</div></div>
  <p>In all cases, when the HID Bridge is in PACKET mode, the checksum field must be valid or data will not be sent on. For example, if a packet is sent from a target to the HID Bridge, and the checksum is invalid, that packet will not be sent on to the host. Likewise, if the host sends a packet to the HID Bridge, and the checksum is invalid, that packet will not be sent on to the target.</p>
<h3><a class="anchor" id="ch_evm_hidbridge_modesofoperation_raw"></a>
Operating Mode: Raw Mode</h3>
<p>When operating in RAW mode, the HID Bridge basically acts as a communication buffer. No formatting is required. Any data received from the target is sent on to the host, and any data received from the host is sent on to the target. There is no HID frame alignment on the host side. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<p>Copyright &#169; 2015, Texas Instruments Incorporated</p>	
    </li>
  </ul>
</div>
</body>
</html>
