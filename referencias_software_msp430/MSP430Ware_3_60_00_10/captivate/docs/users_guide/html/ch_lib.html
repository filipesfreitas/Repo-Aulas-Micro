<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>CapTIvate&trade; Technology Guide: Software Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <img alt="Logo" width=25% src="ti_hz_2c_pos_rgb_png.png"/>
    <table cellspacing="0" cellpadding="0">
        <tbody>
        <tr style="height: 56px;">
            <td style="padding-left: 0.5em;">
                <div id="projectname">CapTIvate&trade; Technology Guide
                    &#160;<span id="projectnumber">v1.30.10.00</span>
                    <p><a href="http://www.ti.com/tool/msp-capt-fr2633">Purchase the kit now</a>
                    <br><a href="http://www.ti.com/captivate">Go to ti.com/CapTIvate</a></p>
                </div>
            </td>
        </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ch_lib.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Software Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ch_lib_intro"></a>
Introduction</h1>
<p>The CapTIvate&trade; Software Library is a collection of target software components designed to help shorten the development process when working with CapTIvate&trade; MCUs. The library is provided and supported by Texas Instruments and is delivered with the CapTIvate&trade; Design Center.</p>
<p>The library provides the following features:</p><ol type="1">
<li><b>Hardware abstraction</b> of the CapTIvate peripheral features</li>
<li><b>Processing</b> of button, slider, wheel, and proximity sensors with simple callback reporting when measurement and processing are complete</li>
<li><b>User interface management</b> to enable a simple top level API that is easy to use</li>
<li><b>Electromagnetic compatibility</b> features for improving noise immunity</li>
<li><b>Communications</b> infrastructure for connecting a CapTIvate&trade; MCU to the CapTIvate&trade; Design Center during tuning or to a host processor in an application</li>
</ol>
<p>These features provide the following main benefits:</p><ol type="1">
<li>Simplification of sensor configuration, measurement, processing and data communication</li>
<li>Faster application development cycles</li>
<li>Seamless integration with the CapTIvate&trade; Design Center development GUI</li>
<li>Reduced code footprint on devices with CapTIvate&trade; software in ROM</li>
</ol>
<p>The library was designed and organized for capacitive user interface applications. However, it may also be used for other applications that require the ability to measure relative changes in capacitance.</p>
<h2><a class="anchor" id="ch_lib_introduction_usingthischapter"></a>
Using This Chapter</h2>
<p>This chapter consists of the following main sections:</p><ol type="1">
<li>The <a class="el" href="ch_lib.html#ch_lib_overview">Overview</a> section introduces the programming model, organization, and architecture of the library.</li>
<li>The <a class="el" href="ch_lib.html#ch_lib_gettingstarted">Getting Started</a> section introduces how to get up and running with the starter project, as well as how to add CapTIvate&trade; to an existing software project.</li>
<li>The <a class="el" href="ch_lib.html#ch_lib_howto">How-To</a> section provides basic code snippets that demonstrate how to do basic things.</li>
<li>The <a class="el" href="ch_lib.html#ch_lib_techdetails">Technical Details</a> section discusses advanced software implementation details.</li>
<li>The <a class="el" href="ch_lib.html#ch_lib_base">Base Module</a>, <a class="el" href="ch_lib.html#ch_lib_advanced">Advanced Module</a>, and <a class="el" href="ch_lib.html#ch_lib_communications">Communications Module</a> sections each provide a detailed description of the respective software module for advanced users.</li>
</ol>
<p>The <a class="el" href="ch_lib.html#ch_lib_gettingstarted">Getting Started</a> and <a class="el" href="ch_lib.html#ch_lib_howto">How-To</a> are the most helpful sections for new users that want to quickly begin developing applications.</p>
<h2><a class="anchor" id="ch_lib_introduction_support"></a>
Device and Tools Support</h2>
<p>The CapTIvate&trade; Software Library can only be used with MSP devices that have CapTIvate&trade; technology.</p>
<p><b>Supported Devices</b></p><ul>
<li>MSP430FR26xx devices with CapTIvate&trade; technology</li>
<li>MSP430FR25xx devices with CapTIvate&trade; technology</li>
</ul>
<p><b>Supported Tool Chains</b></p>
<p>The following development tool chains are supported.</p>
<ul>
<li>TI Code Composer Studio<ul>
<li>IDE version 6.1.0 or higher</li>
<li>MSP430 Emulator Tools 6.2.1.0 or higher</li>
<li>EABI (ELF) output format</li>
</ul>
</li>
<li>IAR Embedded Workbench<ul>
<li>IDE version 6.3 or higher</li>
<li>MSP430 Emulator Tools 6.2.1.0 or higher</li>
</ul>
</li>
</ul>
<p><b>Programming Language</b></p>
<p>The software library is available in C. It follows C99 conventions and uses C99 primitives (uintX).</p>
<h2><a class="anchor" id="ch_lib_introduction_delivery"></a>
Delivery Mechanism</h2>
<p>The CapTIvate&trade; Software Library and CapTIvate&trade; Design Center GUI have linked functionality. Features that exist in the software library are configurable via the Design Center, and data measured via the software library can be communicated back to the Design Center. Because of this, the software library and Design Center are always released together as one software download and installation. The Design Center is the sole point of access to the software library.</p>
<h2><a class="anchor" id="ch_lib_introduction_changecontrol"></a>
Change Control</h2>
<p>Although they are delivered together, the CapTIvate Software Library has its own version tracking and change control. Every major library release comes with change control data in the Software Library API guide that describes any new features that have been added and any changes to existing functionality.</p>
<ul>
<li><a href="../../api_guide/FR2633/html/ch01_Changelog.html">Access the software library change control document</a></li>
<li><a href="../../api_guide/FR2633/html/index.html">Access the software library API guide</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="ch_lib_overview"></a>
Overview</h1>
<p>This section introduces the CapTIvate&trade; Software Library programming model, its organization and its architecture. It also discusses delivery of the library and version control.</p>
<h2><a class="anchor" id="ch_lib_overview_model"></a>
Programming Model</h2>
<p>The CapTIvate&trade; Software Library consists of several software <em>modules</em> and <em>sub-modules</em> that work together to provide various features and abstract complexity. The software library model will be introduced here in a "top-down" approach, starting from the highest point of abstraction and working downward to the lowest point.</p>
<h3>Objects</h3>
<p>The software library function calls operate on C structures which will be referred to in this section as objects. All of the main objects (C type definitions) for the software library are defined in the BASE module inside of the CAPT_Type.h header file. See the <a class="el" href="ch_lib.html#ch_lib_base_types">type definitions</a> section for more details.</p>
<p><b>Generic Capacitive Touch Application</b></p>
<p>Capacitive sensing applications involve the continual measurement and post-processing of one or more capacitive sensors. As such, an application typically has the following flow:</p>
<div class="fragment"><div class="line">Initialize MCU</div>
<div class="line">Initialize user interface</div>
<div class="line">Calibrate user interface</div>
<div class="line"></div>
<div class="line">Loop(Forever)</div>
<div class="line">    If (Time to update = true)</div>
<div class="line">        Then</div>
<div class="line">            Update user interface</div>
<div class="line">            Report user interface status</div>
<div class="line">    End If</div>
</div><!-- fragment --><h4>Top Level Object (User Interface Application)</h4>
<p>The CapTIvate&trade; Software Library utilizes this basic application model as the framework for the top level API and top level object. The top level object in the software library is the <b>user interface application</b>, or <a href="file:///C:/msp430_designcenter/Applications/Captivate/DesignCenter/docs/api_guide/FR2633/html/structtCaptivateApplication.html">tCaptivateApplication</a>. Functions are provided for initializing a user interface, calibrating a user interface, and updating a user interface. These functions are implemented as CAPT_initUI(), CAPT_calibrateUI(), and CAPT_updateUI(), respectively. An application can be created just by using these three functions. This is discussed in the <a class="el" href="ch_lib.html#ch_lib_howto_toplevelapi">Use the Top Level API</a> section.</p>
<p>In order to realize the top level API, the top level object (tCaptivateApplication) holds information about the state of the user interface, how many sensors there are to update, where to find those sensors, and how often to update them.</p>
<h4>Sensor Object</h4>
<p>It then follows that the next object that is needed is a <b>sensor</b> object, or <a href="file:///C:/msp430_designcenter/Applications/Captivate/DesignCenter/docs/api_guide/FR2633/html/structtSensor.html">tSensor</a>. A sensor object is an abstracted user interface control. The software library supports button group, slider, wheel, and proximity sensor types. Every sensor object contains the following information:</p><ol type="1">
<li>Information about which electrodes to measure and how to measure them in parallel (element objects and time cycle objects)</li>
<li>Information about how to configure the CapTIvate&trade; technology peripheral for measurement (conversion control parameters)</li>
<li>Information about how to interpret the data from the measurement (tuning parameters)</li>
</ol>
<p>Various functions can operate on sensor objects directly. For example, it is possible to only update a particular sensor via a call to CAPT_updateSensor() or CAPT_updateSensorWithEMC(). The top level API function CAPT_updateUI() merely calls CAPT_updateSensor() or CAPT_updateSensorWithEMC() for each sensor in the UI application.</p>
<h4>Time Cycle Object</h4>
<p>The sensor object links to <b>time cycle</b> objects. A time cycle object is defined as <a href="file:///C:/msp430_designcenter/Applications/Captivate/DesignCenter/docs/api_guide/FR2633/html/structtCycle.html">tCycle</a>. A time cycle is nothing more than a group of element objects that may be measured in parallel.</p>
<h4>Element Object</h4>
<p>Element objects are the lowest abstraction level, and can be thought of as the software representation of a single electrode, whether it is self or mutual capacitance. Each element contains the following types of information:</p><ol type="1">
<li>Information about the pin(s) the electrode is connected to</li>
<li>Any tuning parameters that are specific to the element (such as a touch threshold)</li>
<li>Any data associated with the element (such as it's current sample or long term average)</li>
<li>Any status flags that are specific to the element (such as touch or proximity status).</li>
</ol>
<h4>Object Tree</h4>
<p>As an example, a basic application with one sensor and 4 elements organized into two time cycles could be represented with the object tree diagram shown below.</p>
<div class="image">
<img src="lib_objecttree_basic.png" alt="lib_objecttree_basic.png"/>
<div class="caption">
Example Application Object Tree</div></div>
  <p>In software, this configuration would have the following structure:</p>
<p><b>Element Definitions</b> </p><div class="fragment"><div class="line"><span class="comment">// Sensor: keypad, Element: E00</span></div>
<div class="line">uint16_t keypad_E00_RawCnts[CAPT_SELF_FREQ_CNT];</div>
<div class="line">tCaptivateElementTuning keypad_E00_Tuning[CAPT_SELF_FREQ_CNT];</div>
<div class="line">tElement keypad_E00 =</div>
<div class="line">{</div>
<div class="line">    .ui8RxPin = 0,</div>
<div class="line">    .ui8RxBlock = 0,</div>
<div class="line">    .ui8TouchThreshold = 10,</div>
<div class="line">    .pRawCount = keypad_E00_RawCnts,</div>
<div class="line">    .pTuning = keypad_E00_Tuning,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Sensor: keypad, Element: E01</span></div>
<div class="line">uint16_t keypad_E01_RawCnts[CAPT_SELF_FREQ_CNT];</div>
<div class="line">tCaptivateElementTuning keypad_E01_Tuning[CAPT_SELF_FREQ_CNT];</div>
<div class="line">tElement keypad_E01 =</div>
<div class="line">{</div>
<div class="line">    .ui8RxPin = 0,</div>
<div class="line">    .ui8RxBlock = 1,</div>
<div class="line">    .ui8TouchThreshold = 10,</div>
<div class="line">    .pRawCount = keypad_E01_RawCnts,</div>
<div class="line">    .pTuning = keypad_E01_Tuning,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Sensor: keypad, Element: E02</span></div>
<div class="line">uint16_t keypad_E02_RawCnts[CAPT_SELF_FREQ_CNT];</div>
<div class="line">tCaptivateElementTuning keypad_E02_Tuning[CAPT_SELF_FREQ_CNT];</div>
<div class="line">tElement keypad_E02 =</div>
<div class="line">{</div>
<div class="line">    .ui8RxPin = 1,</div>
<div class="line">    .ui8RxBlock = 0,</div>
<div class="line">    .ui8TouchThreshold = 10,</div>
<div class="line">    .pRawCount = keypad_E02_RawCnts,</div>
<div class="line">    .pTuning = keypad_E02_Tuning,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Sensor: keypad, Element: E03</span></div>
<div class="line">uint16_t keypad_E03_RawCnts[CAPT_SELF_FREQ_CNT];</div>
<div class="line">tCaptivateElementTuning keypad_E03_Tuning[CAPT_SELF_FREQ_CNT];</div>
<div class="line">tElement keypad_E03 =</div>
<div class="line">{</div>
<div class="line">    .ui8RxPin = 1,</div>
<div class="line">    .ui8RxBlock = 1,</div>
<div class="line">    .ui8TouchThreshold = 10,</div>
<div class="line">    .pRawCount = keypad_E03_RawCnts,</div>
<div class="line">    .pTuning = keypad_E03_Tuning,</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that each element has three components:</p><ol type="1">
<li>An array for storing raw data after a measurement is complete (<b>keypad_E0x_RawCnts[]</b>)</li>
<li>An array for storing element tuning values (<b>keypad_E0x_Tuning[]</b>)</li>
<li>The element data object itself (<b>keypad_E0x</b>)</li>
</ol>
<p>The first component is the raw data array. Whenever an element is updated, the raw conversion results are populated in this array. Normally, the raw data array is an array of one value (keypad_E0x_RawCnts[1]). However, if noise immunity is enabled (EMC features), the raw data array may be larger to store conversion results from a multi-frequency conversion.</p>
<p>The second component is the element's tuning. Each element is calibrated with specific coarse gain, fine gain, and offset subtraction values. To understand what these parameters effect, check out the <a class="el" href="ch_tech.html#ch_tech_Peripheral">CapTIvate peripheral</a> section of the <a class="el" href="ch_tech.html">technology</a> chapter. Just like the raw data array, the tuning is stored in an array as well. If multi-frequency scanning is used to support noise immunity, a tuning is stored for each conversion frequency.</p>
<p>The final component is the element data object (<b>tElement</b>). This object stores the pin definition for the element. An electrode on CAPx.y would be mapped in this way, where 'x' is the CapTIvate&trade; measurement block the electrode is connected to, and 'y' is the pin on that block.</p>
<div class="fragment"><div class="line">.ui8RxPin = y,</div>
<div class="line">.ui8RxBlock = x,</div>
</div><!-- fragment --><p>In addition to the pin connection information, the element object also stores the touch threshold for this element. This specifies the level of interaction required to trigger a touch detection. Each element has its own touch threshold.</p>
<p>Finally, the element object is linked to the raw data and tuning arrays via pointers.</p>
<p><b>Time Cycle Definitions</b> </p><div class="fragment"><div class="line"><span class="comment">// Time Cycle: keypad_C00</span></div>
<div class="line">tElement* keypad_C00_Elements[2] =</div>
<div class="line">{</div>
<div class="line">    &amp;keypad_E00,</div>
<div class="line">    &amp;keypad_E01,</div>
<div class="line">};</div>
<div class="line">tCycle keypad_C00 =</div>
<div class="line">{</div>
<div class="line">    .ui8NrOfElements = 2,</div>
<div class="line">    .pElements = keypad_C00_Elements,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Time Cycle: keypad_C01</span></div>
<div class="line">tElement* keypad_C01_Elements[2] =</div>
<div class="line">{</div>
<div class="line">    &amp;keypad_E02,</div>
<div class="line">    &amp;keypad_E03,</div>
<div class="line">};</div>
<div class="line">tCycle keypad_C01 =</div>
<div class="line">{</div>
<div class="line">    .ui8NrOfElements = 2,</div>
<div class="line">    .pElements = keypad_C01_Elements,</div>
<div class="line">};</div>
</div><!-- fragment --><p>As discussed previously, time cycles are simply a collection of element objects that have the capability of being measured in parallel. Each time cycle is composed of two components:</p>
<ol type="1">
<li>An array of pointers to the elements in the cycle (<b>keypad_C0x_Elements[]</b>)</li>
<li>The cycle object itself (<b>keypad_C0x</b>)</li>
</ol>
<p>The array of element pointers provides the link to the element objects that belong to the cycle. The cycle object links to that array, and also defines how many elements are in the cycle.</p>
<p><b>Sensor Definition</b> </p><div class="fragment"><div class="line"><span class="comment">//Sensor: keypad</span></div>
<div class="line"><span class="keyword">const</span> tCycle* keypad_Cycles[2] =</div>
<div class="line">{</div>
<div class="line">    &amp;keypad_C00,</div>
<div class="line">    &amp;keypad_C01,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">tButtonSensorParams keypad_Params;</div>
<div class="line">tSensor keypad =</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Basic Properties</span></div>
<div class="line">    .TypeOfSensor = eButtonGroup,</div>
<div class="line">    .SensingMethod = eSelf,</div>
<div class="line">    .DirectionOfInterest = eDOIDown,</div>
<div class="line">    .pvCallback = NULL,</div>
<div class="line">    .ui8NrOfCycles = 2,</div>
<div class="line">    .pCycle = keypad_Cycles,</div>
<div class="line">    .pSensorParams = (tGenericSensorParams*)&amp;keypad_Params,</div>
<div class="line">    <span class="comment">// Conversion Control Parameters</span></div>
<div class="line">    .ui16ConversionCount = 500,</div>
<div class="line">    .ui16ConversionGain = 200,</div>
<div class="line">    .ui8FreqDiv = 2,</div>
<div class="line">    .ui8ChargeLength = 0,</div>
<div class="line">    .ui8TransferLength = 0,</div>
<div class="line">    .bModEnable = <span class="keyword">false</span>,</div>
<div class="line">    .ui8BiasControl = 3,</div>
<div class="line">    .bCsDischarge = <span class="keyword">true</span>,</div>
<div class="line">    .bLpmControl = <span class="keyword">false</span>,</div>
<div class="line">    .ui8InputSyncControl = 0,</div>
<div class="line">    .bTimerSyncControl = <span class="keyword">false</span>,</div>
<div class="line">    .bIdleState = <span class="keyword">true</span>,</div>
<div class="line">    <span class="comment">// Tuning  Parameters</span></div>
<div class="line">    .ui16ProxThreshold = 10,</div>
<div class="line">    .ui16NegativeTouchThreshold = 20,</div>
<div class="line">    .ui16ErrorThreshold = 8191,</div>
<div class="line">    .ui16TimeoutThreshold = 1000,</div>
<div class="line">    .ProxDbThreshold.DbIn = 1,</div>
<div class="line">    .ProxDbThreshold.DbOut = 0,</div>
<div class="line">    .TouchDbThreshold.DbIn = 1,</div>
<div class="line">    .TouchDbThreshold.DbOut = 0,</div>
<div class="line">    .bCountFilterEnable = <span class="keyword">true</span>,</div>
<div class="line">    .ui8CntBeta = 1,</div>
<div class="line">    .bSensorHalt = <span class="keyword">false</span>,</div>
<div class="line">    .bPTSensorHalt = <span class="keyword">true</span>,</div>
<div class="line">    .bPTElementHalt = <span class="keyword">true</span>,</div>
<div class="line">    .ui8LTABeta = 7,</div>
<div class="line">    .bReCalibrateEnable = <span class="keyword">true</span>,</div>
<div class="line">};</div>
</div><!-- fragment --><p>The sensor definition has three components:</p>
<ol type="1">
<li>An array of pointers to the cycles in the sensor (<b>keypad_Cycles[]</b>)</li>
<li>The sensor type specific parameters (in this case, a button group) (<b>keypad_Params</b>)</li>
<li>The generic sensor object itself (<b>keypad</b>)</li>
</ol>
<p>The pointer to cycle array allows the sensor to find its child objects (cycles, and through the cycles, the elements). The sensor type specific parameters component stores parameters that are specific to a sensor type. For example, a button group, slider/wheel, and proximity sensor all have different parameter structures.</p>
<p>The remainder of the parameters in the sensor object provides the conversion control and tuning configuration, as set up in the CapTIvate&trade; Design Center.</p>
<p><b>UI Application Definition</b> </p><div class="fragment"><div class="line"><span class="comment">// Application</span></div>
<div class="line">tSensor* g_pCaptivateSensorArray[CAPT_SENSOR_COUNT] =</div>
<div class="line">{</div>
<div class="line">    &amp;keypad,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">tCaptivateApplication g_uiApp =</div>
<div class="line">{</div>
<div class="line">    .state = eUIActive,</div>
<div class="line">    .pSensorList = &amp;g_pCaptivateSensorArray[0],</div>
<div class="line">    .ui8NrOfSensors = CAPT_SENSOR_COUNT,</div>
<div class="line">    .ui8AppLPM = LPM0_bits,</div>
<div class="line">    .bElementDataTxEnable = <span class="keyword">true</span>,</div>
<div class="line">    .bSensorDataTxEnable = <span class="keyword">true</span>,</div>
<div class="line">    .ui16ActiveModeScanPeriod = 33,</div>
<div class="line">    .ui16WakeOnProxModeScanPeriod = 100,</div>
<div class="line">    .ui16InactivityTimeout = 32,</div>
<div class="line">    .ui8WakeupInterval = 5,</div>
<div class="line">};</div>
</div><!-- fragment --><p>The application definition has two components:</p>
<ol type="1">
<li>An array of pointers to the sensors in the application (<b>g_pCaptivateSensorArray[]</b>)</li>
<li>The application object itself (<b>g_uiApp</b>)</li>
</ol>
<p>The array of pointers to sensors allows the top level API to find all of the sensors in the application through the application structure. Note that the application structure also defines the following items:</p><ol type="1">
<li>The low power mode to use during conversions (.ui8AppLPM)</li>
<li>Element and sensor data transmission enable/disable (.bElementDataTxEnable, .bSensorDataTxEnable)</li>
<li>The scan periods to use in active mode (.ui16ActiveModeScanPeriod)</li>
<li>A place holder for wake-on-proximity parameters (.ui16WakeOnProxModeScanPeriod, .ui16InactivityTimeout, .ui8WakeupInterval)</li>
</ol>
<h3>Accessing Measurement Results and Data</h3>
<p>In general, the software library operates on the principle of refreshing data inside of objects, rather than returning results directly via a function call. For example, when a top level API call is made to a function like CAPT_updateUI(), all sensors in the UI and each of those sensor's child elements will have their data structures refreshed. CAPT_updateUI() does not provide any status information directly when returning to the application.</p>
<p>As such, it is the responsibility of the application to directly access the results of a measurement in the appropriate object data structure. A <a class="el" href="ch_lib.html#ch_lib_howto_callbacks">callback function</a> may be registered with any sensor, that will be called whenever a sensor's data is refreshed.</p>
<h2><a class="anchor" id="ch_lib_overview_organization"></a>
Organization and Architecture</h2>
<p>The CapTIvate&trade; Software Library is organized into three major modules by functionality: <b>BASE</b>, <b>ADVANCED</b>, and <b>COMM</b>. Each module has several sub-modules, or "layers". Some of those sub-modules are delivered as source code; others are delivered as object code.</p>
<h3>BASE Module</h3>
<p>The <b>BASE</b> module is the core of the software library. It contains the hardware abstraction layer, the touch layer, the interrupt service routine (ISR), and the type definitions for the library. The touch layer acts as a "hub," providing functions for calibrating, measuring, and processing sensors. For a detailed overview of the <b>BASE</b> module, see the <a class="el" href="ch_lib.html#ch_lib_base">Base Module</a> section.</p>
<h3>ADVANCED Module</h3>
<p>The <b>ADVANCED</b> module provides several processing plug-ins to the <b>BASE</b> module. This includes button processing, slider and wheel processing, and EMC processing for noise immunity. It also contains the manager layer, which serves as the top level API for the library.</p>
<p>The basic software stack is shown below.</p>
<div class="image">
<img src="lib_architecture_nocomm.png" alt="lib_architecture_nocomm.png"/>
<div class="caption">
CapTIvate&trade; Software Library Organization (Without COMMs)</div></div>
  <p>As shown here, from the application space it is only necessary to call the top level API functions in the manager layer to have a functioning application. The touch layer handles pulling in the necessary plug-ins (button, slider/wheel, EMC), so there is no need to call these functions from the application space. For a detailed overview of the <b>ADVANCED</b> module, see the <a class="el" href="ch_lib.html#ch_lib_advanced">Advanced Module</a> section.</p>
<h3>User Configuration</h3>
<p>Every CapTIvate&trade; application has a user configuration that defines all of the objects on the application. This includes the application, sensor, cycle, and element object definitions. This configuration is typically auto-generated by the CapTIvate&trade; Design Center.</p>
<h3>COMM Module</h3>
<p>The <b>COMM</b> module provides communication services to either a host processor or the CapTIvate Design Center. It contains a top level interface layer, a protocol layer, serial drivers, and several data structures. The expanded software stack with the communications module is shown below. For a detailed overview of the <b>COMM</b> module, see the <a class="el" href="ch_lib.html#ch_lib_communications_overview">Communications Module</a> section.</p>
<div class="image">
<img src="lib_architecture.png" alt="lib_architecture.png"/>
<div class="caption">
CapTIvate&trade; Software Library Organization (With COMMs)</div></div>
  <h3>Source Code Directory Structure</h3>
<p>The library source code is organized into sub-directories by module (<b>BASE</b>, <b>ADVANCED</b>, or <b>COMM</b>). In addition to the HAL, Touch, and ISR components, the <b>BASE</b> directory contains the following files:</p>
<ul>
<li><b>captivate.lib</b> This is the CCS library archive. It contains all of the functions that are pre-compiled and delivered as object code for linking against the CCS compiler.</li>
<li><b>captivate.r43</b> This is the IAR library archive. It contains all of the functions that are pre-compiled and delivered as object code for linking against the IAR compiler.</li>
<li><b>lnk_captivate.cmd</b> This linker command file tells the CCS linker about the CapTIvate peripheral address space.</li>
<li><b>rom_captivate.h</b> This is the ROM function header file. It defines the ROM function calls based on the ROM function table.</li>
<li><b>rom_map_captivate.h</b> This is the ROM map header file. It controls which ROM functions are valid for the version of the library that is being compiled. When making ROM calls, it is best to use the MAP_* convention. See the <a class="el" href="ch_lib.html#ch_lib_techdetails_rom">ROM function overview</a> for details on how to call ROM functions.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="ch_lib_gettingstarted"></a>
Getting Started</h1>
<h2><a class="anchor" id="ch_lib_gettingstarted_starterproj"></a>
Starting from Scratch with the Starter Project</h2>
<p>The recommended way to get started with a CapTIvate&trade; software library project is to generate a new starter software project with the CapTIvate&trade; Design Center. To learn how to do this, step through the <a class="el" href="ch_workshop.html#ch_workshop_new_project">new sensor project design workshop</a>.</p>
<p>This section will focus on the features of the starter project itself. The software library starter projected is a ready-to-go application that includes the following software components:</p>
<ol type="1">
<li>The CapTIvate&trade; Software Library</li>
<li>The MSP Peripheral Driver Library (DriverLib), delivered as pre-compiled object code</li>
<li>A board support package, configured for the MSP-CAPT-FR2633 EVM</li>
<li>An example application with wake-on-proximity support built-in</li>
<li>An example main.c</li>
</ol>
<p>The starter project contains everything that is needed to bring up the MCU, calibrate and run a capacitive sensing application per the specified user configuration, and communicate measurement data. It serves as a known-good starting point for new development and tuning. Once an application is tuned, features can be added and removed from the starter application to build toward a final production application.</p>
<h3>Directory Structure</h3>
<p>The directory structure of the starter project is shown below in CCS:</p>
<div class="image">
<img src="starter_project_files.png" alt="starter_project_files.png"/>
<div class="caption">
Starter Project Files</div></div>
  <p>The <em>captivate</em> directory contains the CapTIvate&trade; Software Library. This directory will likely not need to be edited during development.</p>
<p>The <em>captivate_app</em> directory contains the board support package (CAPT_BSP) and the example wake-on-proximity application (CAPT_APP). This directory contains starter files that should be modified to suit the needs of each individual application.</p>
<p>The <em>captivate_config</em> directory contains the automatically generated user configuration files that describe the capacitive sensing application as specified in the CapTIvate&trade; Design Center. The CAPT_UserConfig.c and CAPT_UserConfig.h files in this directory <b>should never be edited manually</b>, as changes made to these files are <b>overwritten if the Design Center is utilized to update the configuration</b>. For this reason, it is best to modify all configuration parameters from inside the Design Center.</p>
<p>The <em>driverlib</em> directory contains the MSP430 peripheral driver library. To lower compilation times, it is delivered as a pre-compiled library archive. It is possible to replace this DriverLib directory with the standard, open-source driver library, if desired.</p>
<h3>Main</h3>
<p>The starter application main.c is shown below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;msp430.h&gt;</span>                      <span class="comment">// Generic MSP430 Device Include</span></div>
<div class="line"><span class="preprocessor">#include &quot;driverlib.h&quot;</span>                   <span class="comment">// MSPWare Driver Library</span></div>
<div class="line"><span class="preprocessor">#include &quot;captivate.h&quot;</span>                   <span class="comment">// CapTIvate Touch Software Library</span></div>
<div class="line"><span class="preprocessor">#include &quot;CAPT_App.h&quot;</span>                    <span class="comment">// CapTIvate Application Code</span></div>
<div class="line"><span class="preprocessor">#include &quot;CAPT_BSP.h&quot;</span>                    <span class="comment">// CapTIvate EVM Board Support Package</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Initialize the MCU</span></div>
<div class="line">    <span class="comment">// BSP_configureMCU() sets up the device IO and clocking</span></div>
<div class="line">    <span class="comment">// The global interrupt enable is set to allow peripherals</span></div>
<div class="line">    <span class="comment">// to wake the MCU.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    WDT_A_hold(WDT_A_BASE);</div>
<div class="line">    BSP_configureMCU();</div>
<div class="line">    __bis_SR_register(GIE);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Start the CapTIvate application</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    CAPT_appStart();</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Background Loop</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Run the captivate application handler.</span></div>
<div class="line">        <span class="comment">// Set LED1 while the app handler is running,</span></div>
<div class="line">        <span class="comment">// and set LED2 if proximity is detected</span></div>
<div class="line">        <span class="comment">// on any sensor.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        LED1_ON;</div>
<div class="line">        <span class="keywordflow">if</span>(CAPT_appHandler()==<span class="keyword">true</span>)</div>
<div class="line">            LED2_ON;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            LED2_OFF;</div>
<div class="line">        LED1_OFF;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// This is a great place to add in any </span></div>
<div class="line">        <span class="comment">// background application code.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        __no_operation();</div>
<div class="line"></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// End of background loop iteration</span></div>
<div class="line">        <span class="comment">// Go to sleep if there is nothing left to do</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        CAPT_appSleep();</div>
<div class="line"></div>
<div class="line">    } <span class="comment">// End background loop</span></div>
<div class="line">} <span class="comment">// End main()</span></div>
</div><!-- fragment --><p>The <b>main()</b> routine disables the watchdog timer, initializes the MCU via the board support package, and starts the capacitive sensing application. It then spends the rest of its time inside the application background loop. LED1 is toggled whenever the application handler is called, and LED2 is set whenever the <b>CAPT_appHandler()</b> function returns true, indicating that any sensor has a proximity detection. After the app handler runs, a call to <b>CAPT_appSleep()</b> will put the MCU to sleep if there are no pending flags that need to be serviced. The CapTIvate&trade; conversion timer interrupt will wake the application each time the user interface needs to be refreshed.</p>
<h3>Board Support Package (CAPT_BSP)</h3>
<p>The board support package configures the MCU for operation with the following parameters:</p><ul>
<li>Watchdog timer is disabled</li>
<li>8 MHz DCO Frequency</li>
<li>8 MHz MCLK for zero wait state FRAM execution, sourced from the DCO</li>
<li>2 MHz SMCLK, sourced from the DCO</li>
<li>32 kHz ACLK, sourced from an external crystal (if connected) or the internal REFO</li>
<li>USCI_A0 and USCI_B0 are muxed to pins to allow for communication</li>
</ul>
<p>The port muxing is configured for the CAPTIVATE-FR2633 processor module. <b>The board support package should be ported to the platform and device used in each application!</b></p>
<h3>Example Application (CAPT_App)</h3>
<p>The example application demonstrates how to enable a generic capacitive sensing application with or without wake-on-proximity. It includes three functions:</p><ul>
<li>CAPT_appStart()</li>
<li>CAPT_appHandler()</li>
<li>CAPT_appSleep()</li>
</ul>
<h4>CAPT_appStart()</h4>
<p>This function provides an example of the functions that need to be called to configure the CapTIvate&trade; Software Library for operation. It handles the following tasks:</p><ol type="1">
<li>Initializing and calibrating the capacitive sensing UI via the CapTIvate&trade; Software Library top level API calls</li>
<li>Configuring and starting the CapTIvate&trade; timer for periodic interrupts</li>
</ol>
<p>As discussed in the <a class="el" href="ch_lib.html#ch_lib_howto_toplevelapi">guide for using the top level API</a>, it is necessary to call <b>CAPT_initUI()</b> and <b>CAPT_calibrateUI()</b> when starting a CapTIvate&trade; software library application. These functions configure the CapTIvate&trade; peripheral and calibrate all of the elements in the UI. If noise immunity (EMC) functionality is going to be used, it is also necessary to load an EMC configuration structure via a call to <b>CAPT_loadEMCConfig()</b>. Note that in the actual example CAPT_appStart() function, the <b>CAPT_loadEMCConfig()</b> function is a compile-time include.</p>
<div class="fragment"><div class="line">CAPT_initUI(&amp;g_uiApp);</div>
<div class="line">CAPT_loadEMCConfig(&amp;g_EMCConfig); <span class="comment">// (Only needed if EMC features are enabled!)</span></div>
<div class="line">CAPT_calibrateUI(&amp;g_uiApp);</div>
</div><!-- fragment --><p>The integrated CapTIvate&trade; conversion timer is a periodic timer that can be used to generate an interrupt or directly trigger a conversion at a specified interval. The timer is configured via HAL function calls, as shown below. Note that these HAL functions are available in ROM on devices with CapTIvate&trade; software in ROM- hence the <b>MAP_</b> calls. For more information on ROM software, see the <a class="el" href="ch_lib.html#ch_lib_techdetails_rom">ROM</a> section.</p>
<div class="fragment"><div class="line">MAP_CAPT_stopTimer();</div>
<div class="line">MAP_CAPT_clearTimer();</div>
<div class="line">MAP_CAPT_selectTimerSource(CAPT_TIMER_SRC_ACLK);</div>
<div class="line">MAP_CAPT_selectTimerSourceDivider(CAPT_TIMER_CLKDIV__1);</div>
<div class="line">MAP_CAPT_writeTimerCompRegister(CAPT_MS_TO_CYCLES(g_uiApp.ui16ActiveModeScanPeriod));</div>
<div class="line">MAP_CAPT_startTimer();</div>
<div class="line">MAP_CAPT_enableISR(CAPT_TIMER_INTERRUPT);</div>
</div><!-- fragment --><p>These setup functions configure the timer to be sourced from ACLK (32 kHz in this starter project). An input divider of 1 is selected, and the compare register is set to the active mode scan period, converted to cycles. The macro <b>CAPT_MS_TO_CYCLES</b> approximates the number of 32 kHz clock cycles needed to produce the desired scan rate by multiplying the saved value (in milliseconds) by 32 (via a 5x bit shift). The timer interrupt is enabled to start the application. When the timer interrupt is asserted by the timer, the CapTIvate&trade; peripheral interrupt handler will run. The interrupt handler is in the BASE layer of the CapTIvate&trade; library, and is available in source code for transparency.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma vector=CAPTIVATE_VECTOR</span></div>
<div class="line">__interrupt <span class="keywordtype">void</span> CAPT_ISR(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span>(__even_in_range(CAPT_getInterruptVector(), CAPT_IV_MAX_COUNT_ERROR))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// End of Conversion Interrupt</span></div>
<div class="line">        <span class="keywordflow">case</span> CAPT_IV_END_OF_CONVERSION:</div>
<div class="line">            g_bEndOfConversionFlag = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Detection Interrupt</span></div>
<div class="line">        <span class="keywordflow">case</span> CAPT_IV_DETECTION:</div>
<div class="line">            g_bDetectionFlag = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Timer Interrupt</span></div>
<div class="line">        <span class="keywordflow">case</span> CAPT_IV_TIMER:</div>
<div class="line">            g_bConvTimerFlag = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Conversion Counter Interrupt</span></div>
<div class="line">        <span class="keywordflow">case</span> CAPT_IV_CONVERSION_COUNTER:</div>
<div class="line">            g_bConvCounterFlag = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Max Count Error Interrupt</span></div>
<div class="line">        <span class="keywordflow">case</span> CAPT_IV_MAX_COUNT_ERROR:</div>
<div class="line">            g_bMaxCountErrorFlag = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    __bic_SR_register_on_exit(LPM3_bits);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The interrupt handler will set the appropriate flag, and it always exits active. Therefore, the application merely needs to monitor the <b>g_bConvTimerFlag</b> boolean value to known when the timer has tripped, meaning that it is time to update the user interface.</p>
<h4>CAPT_appHandler()</h4>
<p>The application handler function must be periodically called from the application background loop, as shown in <b>main.c</b>. At first glance, the function appears quite complex- but really, all the application handler does is manage when the UI needs to be updated (in active mode), as well as manage the transitions between active mode and wake-on-proximity mode.</p>
<p>The application handler makes use of several convenience variables in the CapTIvate&trade; top level application object:</p><ul>
<li>The active mode scan period</li>
<li>The wake on proximity mode scan period</li>
<li>The inactivity time-out</li>
<li>The wakeup interval</li>
</ul>
<p>It may be configured at compile time for two different modes of operation:</p><ol type="1">
<li>Active mode only (No wake-on-proximity state handling). This is the reduced memory footprint option.</li>
<li>Active mode with wake-on-proximity management. This option requires more memory to handle the wake-on-proximity management.</li>
</ol>
<p>The compile time mode is determined by settings in the user configuration header file (CAPT_UserConfig.h in the <em>CAPT_config</em> directory):</p>
<p><b>Active Mode Only Configuration</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#define CAPT_WAKEONPROX_ENABLE  (false)</span></div>
<div class="line"><span class="preprocessor">#define CAPT_WAKEONPROX_SENSOR  (none)</span></div>
</div><!-- fragment --><p><b>Active Mode with Wake-on-Proximity Configuration</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#define CAPT_WAKEONPROX_ENABLE  (true)</span></div>
<div class="line"><span class="preprocessor">#define CAPT_WAKEONPROX_SENSOR  (selected sensor)</span></div>
</div><!-- fragment --><p>These options can and should be configured through the CapTIvate&trade; Design Center. See the <a class="el" href="DesignCenter.html#ch_cdc_UsersGuide_sec03_compile_options">Compile Time Options</a> section for details.</p>
<p>Active mode is characterized by the following behavior:</p><ul>
<li>The CapTIvate&trade; conversion timer is used in interrupt mode to wake the CPU at a specified interval</li>
<li>When the <b>g_bConvTimerFlag</b> is asserted, <b>CAPT_updateUI()</b> is called to refresh all sensors in the UI under CPU control.</li>
</ul>
<p>Wake-on-proximity mode is characterized by the following behavior:</p><ul>
<li>The CapTIvate&trade; conversion timer is used in timer-triggered conversion mode to automatically start a conversion of a single time cycle at a specified interval without any CPU intervention</li>
<li>When any element in the time cycle selected for wake-on-proximity has a proximity threshold crossing or negative touch threshold crossing, the detection flag (<b>g_bDetectionFlag</b>) is asserted and the application switches to active mode</li>
<li>If the conversion counter flag (<b>g_bConvCounterFlag</b>)is asserted, the application switches to active mode</li>
</ul>
<h5>CAPT_appHandler() Compiled for Active Mode Only</h5>
<p>The diagram below describes the behaviour of the application handler when compiled for active mode support only.</p>
<div class="image">
<img src="app_handler_basic.png" alt="app_handler_basic.png"/>
<div class="caption">
CAPT_appHandler() with Active Mode Only Support</div></div>
  <p>When compiled for active mode only, the function is pre-processed down to this basic set of functionality: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> CAPT_appHandler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> bActivity = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (g_bConvTimerFlag == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Clear the conversion timer flag,</span></div>
<div class="line">        <span class="comment">// and update the UI</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        g_bConvTimerFlag = <span class="keyword">false</span>;</div>
<div class="line">        CAPT_updateUI(&amp;g_uiApp);</div>
<div class="line">        bActivity = CAPT_getGlobalUIProximityStatus(&amp;g_uiApp);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> bActivity;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Since the CapTIvate&trade; conversion timer was already configured by <b>CAPT_appStart()</b>, all that is needed is to test the <b>g_bConvTimerFlag</b>. If it is set, then the application handler clears it, updates the UI via <b>CAPT_updateUI()</b>, and checks to see if any elements in the UI have a proximity detection. The function returns true if any element was in proximity, else false.</p>
<p>If communications are enabled, the function also checks for incoming packets as shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> CAPT_appHandler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> bActivity = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (g_bConvTimerFlag == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Clear the conversion timer flag,</span></div>
<div class="line">        <span class="comment">// and update the UI</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        g_bConvTimerFlag = <span class="keyword">false</span>;</div>
<div class="line">        CAPT_updateUI(&amp;g_uiApp);</div>
<div class="line">        bActivity = CAPT_getGlobalUIProximityStatus(&amp;g_uiApp);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// If communications are enabled, check for any incoming packets.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    CAPT_checkForInboundPacket();</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Check to see if the packet requested a re-calibration.</span></div>
<div class="line">    <span class="comment">// If wake-on-prox is enabled and the current application state</span></div>
<div class="line">    <span class="comment">// is wake-on-prox, disable the wake-on-prox feature during the calibration</span></div>
<div class="line">    <span class="comment">// and re-enable it after the calibration.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (CAPT_checkForRecalibrationRequest() == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        CAPT_calibrateUI(&amp;g_uiApp);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> bActivity;</div>
<div class="line">}</div>
</div><!-- fragment --><p>A call is made to <b>CAPT_checkForInboundPacket()</b> to see if any packets have been received that need processing. Some parameter packets (such as a sensor's conversion count) require that a re-calibration take place. The <b>CAPT_checkForRecalibrationRequest()</b> checks to see if a re-calibration request is pending.</p>
<p>Note that if <b>g_bConvTimerFlag</b> is false, the function is essentially non-blocking. This allows the background loop in <b>main()</b> to service other application tasks, while just periodically calling <b>CAPT_appHandler()</b> to see if it is time to do something.</p>
<h5>CAPT_appHandler() Compiled for Active Mode with Wake-on-Proximity Mode</h5>
<p>When compiled with wake-on-proximity mode enabled, the application handler manages transitions between active mode and wake-on-proximity mode. The application starts in active mode, and follows the flow shown below:</p>
<div class="image">
<img src="app_handler_wop.png" alt="app_handler_wop.png"/>
<div class="caption">
CAPT_appHandler() with Wake-on-Proximity Support</div></div>
  <p>The wake-on-proximity feature allows for one time cycle to be measured and processed autonomously with no CPU interaction until a detection, counter interrupt, or error condition occurs. This is useful for applications that have a power key or a proximity sensor that is used to wake up the rest of the system, since that sensor may be scanned with no CPU overhead. When a detection does occur, the handler switches operation to active mode and the entire user interface is scanned under CPU control.</p>
<p>The application remains in active mode under CPU control as long as at least one element is in proximity detect. Once all elements are clear of proximity, the session time-out counter begins counting down. This counter will keep the system in active mode for the specified number of samples before returning into wake-on-proximity mode. The timeout is specified in the application object via the <b>ui16InactivityTimeout</b> parameter.</p>
<p>In addition to waking on a detection, it is also possible to periodically wake up into active mode after a certain number of conversions have taken place in wake-on-proximity mode. This is useful to ensure that all the other sensors in the system have current long term averages (LTAs) to account for environmental drift. The conversion counter interrupt may be used to specify a wakeup period.</p>
<p>These wakeup sources are discussed further in the <a class="el" href="ch_Glossary.html#ch_glossary_system_wakeonprox_mode">wake-on-proximity</a> description.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> CAPT_appHandler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> uint16_t g_ui16UISessionTimeoutCtr = 1;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> bActivity = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">switch</span> (g_uiApp.state)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> eUIActive:</div>
<div class="line">            <span class="keywordflow">if</span> (g_bConvTimerFlag == <span class="keyword">true</span>)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="comment">// Clear the conversion timer flag,</span></div>
<div class="line">                <span class="comment">// and update the UI</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                g_bConvTimerFlag = <span class="keyword">false</span>;</div>
<div class="line">                CAPT_updateUI(&amp;g_uiApp);</div>
<div class="line">                bActivity = CAPT_getGlobalUIProximityStatus(&amp;g_uiApp);</div>
<div class="line"></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="comment">// If autonomous mode is enabled, check to</span></div>
<div class="line">                <span class="comment">// see if autonomous mode should be entered.</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="keywordflow">if</span> (bActivity == <span class="keyword">true</span>)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//</span></div>
<div class="line">                    <span class="comment">// If there is still a prox detection,</span></div>
<div class="line">                    <span class="comment">// reset the session timeout counter.</span></div>
<div class="line">                    <span class="comment">//</span></div>
<div class="line">                    g_ui16UISessionTimeoutCtr = g_uiApp.ui16InactivityTimeout;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (--g_ui16UISessionTimeoutCtr == 0)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">//</span></div>
<div class="line">                    <span class="comment">// If the session has timed out,</span></div>
<div class="line">                    <span class="comment">// enter autonomous mode</span></div>
<div class="line">                    <span class="comment">//</span></div>
<div class="line">                    g_uiApp.state = eUIWakeOnProx;</div>
<div class="line">                    bActivity = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">//</span></div>
<div class="line">                    <span class="comment">// Set the timer period for wake on touch interval</span></div>
<div class="line">                    <span class="comment">//</span></div>
<div class="line">                    MAP_CAPT_disableISR(CAPT_TIMER_INTERRUPT);</div>
<div class="line">                    MAP_CAPT_stopTimer();</div>
<div class="line">                    MAP_CAPT_clearTimer();</div>
<div class="line">                    MAP_CAPT_writeTimerCompRegister(CAPT_MS_TO_CYCLES(g_uiApp.ui16WakeOnProxModeScanPeriod));</div>
<div class="line">                    MAP_CAPT_startTimer();</div>
<div class="line">                    g_bConvTimerFlag = <span class="keyword">false</span>;</div>
<div class="line">                    CAPT_startWakeOnProxMode(</div>
<div class="line">                            &amp;CAPT_WAKEONPROX_SENSOR,</div>
<div class="line">                            0,</div>
<div class="line">                            g_uiApp.ui8WakeupInterval</div>
<div class="line">                        );</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">case</span> eUIWakeOnProx:</div>
<div class="line">            <span class="keywordflow">if</span> (g_bDetectionFlag || g_bConvCounterFlag || g_bMaxCountErrorFlag)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="comment">// If a detection, conversion counter, or max count error flag was set,</span></div>
<div class="line">                <span class="comment">// stop autonomous mode and reload an active session</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                CAPT_stopWakeOnProxMode(&amp;CAPT_WAKEONPROX_SENSOR, 0);</div>
<div class="line">                g_bDetectionFlag = <span class="keyword">false</span>;</div>
<div class="line">                g_bConvCounterFlag = <span class="keyword">false</span>;</div>
<div class="line">                g_bMaxCountErrorFlag = <span class="keyword">false</span>;</div>
<div class="line">                g_uiApp.state = eUIActive;</div>
<div class="line">                g_ui16UISessionTimeoutCtr = g_uiApp.ui16InactivityTimeout;</div>
<div class="line"></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="comment">// Set the timer period for normal scan interval</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                MAP_CAPT_disableISR(CAPT_TIMER_INTERRUPT);</div>
<div class="line">                MAP_CAPT_stopTimer();</div>
<div class="line">                MAP_CAPT_clearTimer();</div>
<div class="line">                MAP_CAPT_writeTimerCompRegister(CAPT_MS_TO_CYCLES(g_uiApp.ui16ActiveModeScanPeriod));</div>
<div class="line">                MAP_CAPT_startTimer();</div>
<div class="line">                CAPT_clearIFG(CAPT_TIMER_INTERRUPT);</div>
<div class="line">                MAP_CAPT_enableISR(CAPT_TIMER_INTERRUPT);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> bActivity;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that it is possible to set a different scan period for wake-on-proximity mode than the period used in active mode. This allows for slow scanning while waiting for proximity, and faster scanning when a user is detected. Scanning less often reduces the overall power consumption.</p>
<p>In addition, the clock source and low power mode used during wake-on-proximity mode may be set to the VLO and LPM4, respectively, for applications that require low power but cannot use a crystal. To enable this combination, define <b>CAPT_WOP_VLO_LPM4</b> at the beginning of CAPT_App.c. When this is defined, the application's low power mode will be set to LPM4 (ACLK off), and the VLO will be selected as the input clock source to the CapTIvate timer.</p>
<p>For more details on designing for low power, see the <a class="el" href="ch_design.html#ch_design_low_power">low power design guide</a>.</p>
<h4>CAPT_appSleep()</h4>
<p>The application sleep function is a safety wrapper that ensures no flags are pending when the application transitions into a low power mode. Safety is achieved by disabling interrupts, testing the flags, and then entering a low power mode while simultaneously re-enabling interrupts. This sequence protects the application from any software race conditions that might occur, such as a flag being set after the flag was tested but before the device entered low power mode.</p>
<div class="fragment"><div class="line">__bic_SR_register(GIE);</div>
<div class="line"><span class="keywordflow">if</span> (!(g_bConvTimerFlag ||g_bDetectionFlag || g_bConvCounterFlag || g_bMaxCountErrorFlag))</div>
<div class="line">{</div>
<div class="line">    __bis_SR_register(g_uiApp.ui8AppLPM | GIE);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    __bis_SR_register(GIE);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Moving Forward</h3>
<p>That's it! The example application in <em>captivate_app</em> is meant to be just that- an example. Feel free to modify it to suit the needs of another application. For details on how to use the CapTIvate&trade; Software Library top level API, see <a class="el" href="ch_lib.html#ch_lib_howto_toplevelapi">Using the Top Level API</a>.</p>
<h2><a class="anchor" id="ch_lib_gettingstarted_existingproj"></a>
Adding CapTIvate to an Existing Project</h2>
<p>If you have an existing application using an MSP MCU and would like to add CapTIvate&trade; capacitive touch sensing capability to that project, this guide will discuss the important steps to take to make the integration as seamless as possible.</p>
<p>This guide also provides details about how to set up a new project from scratch, if the CapTIvate&trade; starter project is not being used.</p>
<h3>Similar Devices</h3>
<p>The CapTIvate&trade; MSP430FR26xx and MSP430FR25xx MCUs have a similar platform architecture as some other MSP430 FRAM devices. As such, porting an existing application from another FRAM device to an MSP430FR26xx or MSP430FR25xx MCU does not require significant effort. MCUs that are very compatible include the MSP430FR4133, MSP430FR2433, and MSP430FR2033.</p>
<h3>Porting Approach</h3>
<p>The best way to begin CapTIvate&trade; software library development, regardless of whether the capacitive sensing functionality will be integrated with another project or not, is to generate a starter project with the CapTIvate&trade; Design Center. This starter project may then be used by itself to quickly bring up a capacitive sensing application and experiment with tuning. Once that process is complete, all that is needed is to bring over the necessary CapTIvate&trade; software components from the starter project into the existing software project.</p>
<p>The <a class="el" href="ch_lib.html#ch_lib_gettingstarted_starterproj">previous section</a> discusses how to generate a starter project. The <a class="el" href="ch_workshop.html#ch_workshop_new_project">new sensor project design workshop</a> also provides a step-by-step overview of the process. Once you have a starter project, you can extract the CapTIvate&trade; software library components from the starter project and integrate them into the existing project.</p>
<h3>Bringing over CapTIvate&trade; Software Components from a Starter Project to an Existing Project</h3>
<p>As an example, this section will discuss bringing over the CapTIvate&trade; software components from a starter project to an existing software project. This example will be discussed in the context of TI's Code Composer Studio (CCS) IDE. The same principles apply to an IAR Embedded Workbench project. In this example, the existing software project will be an empty CCS project, as shown below:</p>
<div class="image">
<img src="existing_project_files_PartA.png" alt="existing_project_files_PartA.png"/>
<div class="caption">
Empty Application</div></div>
  <p><b>main.c</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;msp430.h&gt;</span> </div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    WDTCTL = WDTPW | WDTHOLD;</div>
<div class="line">    PM5CTL0 &amp;= ~LOCKLPM5;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        __no_operation();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>To bring over CapTIvate&trade;, the following steps are required:</p>
<ol type="1">
<li>Copy over the <em>captivate</em>, <em>captivate_config</em>, and <em>driverlib</em> directories and all of their content from the starter project to the existing application</li>
<li>Configure the existing project's compiler settings for CapTIvate&trade;</li>
<li>Configure the existing project's linker settings for CapTIvate&trade;</li>
<li>Add top level API calls to the main application to initialize, calibrate, and begin updating the newly added capacitive sensing interface</li>
<li>[Optional] Optimize the clock system configuration for CapTIvate&trade;</li>
</ol>
<h4>Step 1: Copying the Needed CapTIvate&trade; Files</h4>
<ul>
<li>1a. Copy the <em>captivate</em>, <em>captivate_config</em>, and <em>driverlib</em> directories and all of their content from the starter project to the existing application</li>
<li>1b. Copy the <em>driverlib</em> directory and all of its contents from the starter project to the existing application</li>
</ul>
<p>Below are the directories that need to be copied from the starter project:</p>
<div class="image">
<img src="starter_project_files_transfer.png" alt="starter_project_files_transfer.png"/>
<div class="caption">
Starter Application Files To Copy</div></div>
  <h4>Step 2: Configuring the Existing Project's Compiler Settings for CapTIvate&trade;</h4>
<ul>
<li>2a. Add the <em>captivate</em>, <em>captivate/BASE</em>, <em>captivate/ADVANCED</em>, <em>captivate/COMM</em>, and <em>captivate_config</em> project directories to the existing project's include search path, as shown below. Also add the DriverLib directory <em>driverlib/MSP430FR2x_4xx</em></li>
</ul>
<div class="image">
<img src="lib_existing_project_includes.png" alt="lib_existing_project_includes.png"/>
<div class="caption">
Compiler Include Settings</div></div>
  <ul>
<li>2b. Change the existing project's compiler processor options settings to use the small code, small data memory model. This is required for the project to be compatible with the ROM and object code library.</li>
</ul>
<div class="image">
<img src="lib_existing_project_scsd.png" alt="lib_existing_project_scsd.png"/>
<div class="caption">
Compiler Processor Options</div></div>
  <ul>
<li>2c. Add the following definitions to the project's compiler predefined symbol list:<ul>
<li>TARGET_IS_MSP430FR2633 (To include the CapTIvate&trade; ROM functions)</li>
<li>TARGET_IS_MSP430FR2XX_4XX (To include the DriverLib ROM functions)</li>
</ul>
</li>
</ul>
<div class="image">
<img src="lib_existing_project_defines.png" alt="lib_existing_project_defines.png"/>
<div class="caption">
Compiler Pre-Defined Symbols</div></div>
  <h4>Step 3: Configuring the Existing Project's Linker Settings for CapTIvate&trade;</h4>
<ul>
<li>3a. Add the CapTIvate&trade; library archive to the linker's input. If you are using the pre-compiled DriverLib directory from the starter project, add the DriverLib library archive as well, as shown below.</li>
</ul>
<div class="image">
<img src="lib_existing_project_linker.png" alt="lib_existing_project_linker.png"/>
<div class="caption">
Linker Inputs</div></div>
  <h4>Step 4: Add Top Level API Calls to Begin Using CapTIvate&trade;</h4>
<ul>
<li>4a. Insert calls to initialize and calibrate the user interface once at the beginning of the application. Be sure to also add the include statement for the CapTIvate library.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Step 4a:</span></div>
<div class="line">CAPT_initUI(&amp;g_uiApp);</div>
<div class="line">CAPT_calibrateUI(&amp;g_uiApp);</div>
</div><!-- fragment --><p>If noise immunity (EMC) features are going to be enabled for this design, it is also necessary to link the EMC configuration structure to the EMC module via a call to <b>CAPT_loadEMCConfig()</b>. This must be done before calling <b>CAPT_calibrateUI()</b>, so that the EMC configuration parameters are available during the calibration process.</p>
<div class="fragment"><div class="line"><span class="comment">// Step 4a with EMC:</span></div>
<div class="line">CAPT_initUI(&amp;g_uiApp);</div>
<div class="line">CAPT_loadEMCConfig(&amp;g_EMCConfig);</div>
<div class="line">CAPT_calibrateUI(&amp;g_uiApp);</div>
</div><!-- fragment --><ul>
<li>4b. Configure the CapTIvate&trade; interval timer to periodically set the <b>g_bConvTimerFlag</b> status flag.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Step 4b:</span></div>
<div class="line">MAP_CAPT_selectTimerSource(CAPT_TIMER_SRC_ACLK);</div>
<div class="line">MAP_CAPT_writeTimerCompRegister(CAPT_MS_TO_CYCLES(g_uiApp.ui16ActiveModeScanPeriod));</div>
<div class="line">MAP_CAPT_startTimer();</div>
<div class="line">MAP_CAPT_enableISR(CAPT_TIMER_INTERRUPT);</div>
</div><!-- fragment --><ul>
<li>4c. Begin updating the UI! Add a test in the background loop to see if the conversion timer flag has been set. If it has, clear it and update the user interface via <b>CAPT_updateUI()</b>.</li>
</ul>
<p><b>main.c</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;msp430.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;captivate.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    WDTCTL = WDTPW | WDTHOLD;</div>
<div class="line">    PM5CTL0 &amp;= ~LOCKLPM5;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Step 4a:</span></div>
<div class="line">    CAPT_initUI(&amp;g_uiApp);</div>
<div class="line">    CAPT_calibrateUI(&amp;g_uiApp);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Step 4b:</span></div>
<div class="line">    MAP_CAPT_selectTimerSource(CAPT_TIMER_SRC_ACLK);</div>
<div class="line">    MAP_CAPT_writeTimerCompRegister(CAPT_MS_TO_CYCLES(g_uiApp.ui16ActiveModeScanPeriod));</div>
<div class="line">    MAP_CAPT_startTimer();</div>
<div class="line">    MAP_CAPT_enableISR(CAPT_TIMER_INTERRUPT);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Step 4c:</span></div>
<div class="line">        <span class="keywordflow">if</span> (g_bConvTimerFlag == <span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            g_bConvTimerFlag = <span class="keyword">false</span>;</div>
<div class="line">            CAPT_updateUI(&amp;g_uiApp);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>4d. Check the touch status of the sensor by testing its <b>bSensorTouch</b> flag. This flag will indicate if any element in the sensor has a touch detection. After <b>CAPT_updateUI()</b> is called, all of the sensor and element objects in the UI will have updated status variables.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">while</span>(1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Step 4c:</span></div>
<div class="line">    <span class="keywordflow">if</span> (g_bConvTimerFlag == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        g_bConvTimerFlag = <span class="keyword">false</span>;</div>
<div class="line">        CAPT_updateUI(&amp;g_uiApp);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Step 4d:</span></div>
<div class="line">        <span class="keywordflow">if</span> (keypad.bSensorTouch == <span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            __no_operation();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h4>Step 5: [Optional] Optimizing the Clock System for CapTIvate&trade;</h4>
<p>The default clock frequency for the DCO is approximately 1 MHz. The CapTIvate&trade; Software Library runs most efficiently at 8 MHz. At 8 MHz, no memory access wait states are required, providing an efficient uA/MHz ratio. To increase the DCO clock frequency to 8 MHz, insert calls to DriverLib to configure the clock system as shown below. It is best to configure the clock system before any calls to the CapTIvate&trade; Software Library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MCLK_FREQ 8000000</span></div>
<div class="line"><span class="preprocessor">#define FLLREF_FREQ 32768</span></div>
<div class="line"><span class="preprocessor">#define FLL_RATIO (MCLK_FREQ / FLLREF_FREQ)</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Step 5:</span></div>
<div class="line">CS_initClockSignal(CS_FLLREF, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1);</div>
<div class="line">CS_initClockSignal(CS_ACLK, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1);</div>
<div class="line">CS_initClockSignal(CS_MCLK, CS_DCOCLKDIV_SELECT, CS_CLOCK_DIVIDER_1);</div>
<div class="line">CS_initClockSignal(CS_SMCLK, CS_DCOCLKDIV_SELECT, CS_CLOCK_DIVIDER_4);</div>
<div class="line">CS_initFLLSettle((MCLK_FREQ/1000), FLL_RATIO);</div>
<div class="line"><span class="keywordflow">while</span> (CS_getFaultFlagStatus(CS_DCOFFG | CS_FLLULIFG))</div>
<div class="line">{</div>
<div class="line">    CS_clearFaultFlag(CS_DCOFFG | CS_FLLULIFG);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that SMCLK is configured to run at DCO/4, or 2 MHz. This is the frequency that the CapTIvate&trade; Software Library COMM module expects in order to generate UART baud rates correctly.</p>
<h4>Step 6: [Optional] Muxing IO for Communications</h4>
<p>To add the ability to communicate with the CapTIvate&trade; Design Center, it is necessary to configure the CapTIvate&trade; user configuration for a communication interface (UART or I2C) and mux the appropriate peripheral to device pins. See the appropriate device datasheet and device family user's guide for information on how to mux digital functions to device pins. The starter project also provides an example of how to mux the eUSCI_A0 and eUSCI_B0 peripherals on the MSP430FR2633.</p>
<h4>Completed Example Application</h4>
<p>Below is the completed example:</p>
<p><b>main.c</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;msp430.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;captivate.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;driverlib.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define MCLK_FREQ 8000000</span></div>
<div class="line"><span class="preprocessor">#define FLLREF_FREQ 32768</span></div>
<div class="line"><span class="preprocessor">#define FLL_RATIO (MCLK_FREQ / FLLREF_FREQ)</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    WDTCTL = WDTPW | WDTHOLD;</div>
<div class="line">    PM5CTL0 &amp;= ~LOCKLPM5;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Step 5:</span></div>
<div class="line">    CS_initClockSignal(CS_FLLREF, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1);</div>
<div class="line">    CS_initClockSignal(CS_ACLK, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1);</div>
<div class="line">    CS_initClockSignal(CS_MCLK, CS_DCOCLKDIV_SELECT, CS_CLOCK_DIVIDER_1);</div>
<div class="line">    CS_initClockSignal(CS_SMCLK, CS_DCOCLKDIV_SELECT, CS_CLOCK_DIVIDER_4);</div>
<div class="line">    CS_initFLLSettle((MCLK_FREQ/1000), FLL_RATIO);</div>
<div class="line">    <span class="keywordflow">while</span> (CS_getFaultFlagStatus(CS_DCOFFG | CS_FLLULIFG))</div>
<div class="line">    {</div>
<div class="line">        CS_clearFaultFlag(CS_DCOFFG | CS_FLLULIFG);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Step 4a:</span></div>
<div class="line">    CAPT_initUI(&amp;g_uiApp);</div>
<div class="line">    CAPT_calibrateUI(&amp;g_uiApp);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Step 4b:</span></div>
<div class="line">    MAP_CAPT_selectTimerSource(CAPT_TIMER_SRC_ACLK);</div>
<div class="line">    MAP_CAPT_writeTimerCompRegister(CAPT_MS_TO_CYCLES(g_uiApp.ui16ActiveModeScanPeriod));</div>
<div class="line">    MAP_CAPT_startTimer();</div>
<div class="line">    MAP_CAPT_enableISR(CAPT_TIMER_INTERRUPT);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Step 4c:</span></div>
<div class="line">        <span class="keywordflow">if</span> (g_bConvTimerFlag == <span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            g_bConvTimerFlag = <span class="keyword">false</span>;</div>
<div class="line">            CAPT_updateUI(&amp;g_uiApp);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Step 4d:</span></div>
<div class="line">            <span class="keywordflow">if</span> (keypad.bSensorTouch == <span class="keyword">true</span>)</div>
<div class="line">            {</div>
<div class="line">                __no_operation();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><hr/>
 <h1><a class="anchor" id="ch_lib_howto"></a>
How-To</h1>
<p>The how-to section of the CapTIvate&trade; Software Library chapter contains basic code snippets that demonstrate how to perform a simple task, such as measuring a sensor, checking the status of a sensor, or accessing raw data.</p>
<h2><a class="anchor" id="ch_lib_howto_toplevelapi"></a>
Use the Top Level API</h2>
<p>The top level API of the CapTIvate&trade; Software Library provides a very simple, highly abstracted programming interface to the library. To get an application up and running, it is only necessary to have knowledge of three basic functions: <b>CAPT_initUI()</b>, <b>CAPT_calibrateUI()</b>, and <b>CAPT_updateUI()</b>.</p>
<h3>Scope</h3>
<p>As introduced in the <a class="el" href="ch_lib.html#ch_lib_overview_model">programming model</a> section, the top level API functions operate solely on the top level application object, or <em>tCaptivateApplication</em>. This object contains all of the information that is needed to run the user interface. It contains the links to all of the sensors that are in the UI. It is important to understand that when a top level API function is used, all of the sensors that are associated with the application are affected. For example, calling <b>CAPT_calibrateUI()</b> causes each sensor in the UI to be calibrated.</p>
<h3>Open Source</h3>
<p>The top level API functions are delivered as open source functions in the library, so that the software designer can understand how the functions work. The functions exist in the <em>CAPT_Manager.c</em> and <em>CAPT_Manager.h</em> files, which are a part of the <b>ADVANCED</b> module of the library.</p>
<h3>Setting up an Application</h3>
<p>When setting up an application, it is important to note that there are two types of functions in the top level API:</p><ul>
<li>Initialization functions (Run one time at start-up)</li>
<li>Periodic functions (called periodically while the application is running to do something)</li>
</ul>
<p>The initialization functions are <b>CAPT_initUI()</b> and <b>CAPT_calibrateUI()</b>. <b>CAPT_updateUI()</b> is a periodic function. The initialization functions must be called at the beginning of the application. The behavior of each function is described below.</p>
<h4>CAPT_initUI()</h4>
<p>The CAPT_initUI() function is responsible for the following actions at start-up:</p>
<ol type="1">
<li>Power on the CapTIvate&trade; peripheral</li>
<li>Initialize the CapTIvate&trade; peripheral global settings</li>
<li>Configure each sensor's IO</li>
<li>Initialize each sensor</li>
<li>If communications are enabled, initialize the library's communication (COMM) module</li>
</ol>
<p>Essentially, this function takes care of the one-time settings that do not change once the application is up and running. It should be called one time before any other CapTIvate&trade; library function is called.</p>
<h4>CAPT_calibrateUI()</h4>
<p>The CAPT_calibrateUI() function is responsible for obtaining coarse gain, fine gain, and offset subtraction calibration values for every element in every sensor in the application. Once these calibration values are obtained via this function call, they will be applied every time an element is measured to provide the correct amount of gain and offset. For details on how gain and offset parameters work, see the <a class="el" href="ch_tech.html#ch_tech_Peripheral">peripheral section</a> of the technology guide.</p>
<p>This top-level calibration function is also responsible for determining whether to use the standard calibration routine (<b>CAPT_calibrateSensor()</b>) or the EMC calibration routine (<b>CAPT_calibrateSensorWithEMC()</b>), depending on whether or not noise immunity is enabled. If noise immunity is enabled, the EMC calibration routine provides calibration values at multiple conversion frequencies and performs additional self-test functions.</p>
<p>This function must be called before any UI or sensor update functions are called- otherwise, no calibration values will be present!</p>
<p>In addition to the first call, in certain applications it may be desirable to force a re-calibration at run-time. One example of this scenario is a mobile device that experiences a "negative" or "reverse" touch. If a user is touching a sensor during power-up or reset, the sensor will be calibrated to the touched state rather than the un-touched state. When the user lets go of the sensor, the measurement will change rapidly <em>against</em> the expected direction of change. This can be interpreted as a reverse touch scenario, after which it may be desirable to re-calibrate the entire user interface to ensure a good starting point.</p>
<h4>CAPT_updateUI()</h4>
<p>The CAPT_updateUI() function is responsible for the following actions:</p>
<ol type="1">
<li>Updating each sensor</li>
<li>Testing each sensor for a re-calibration condition</li>
<li>If communications are enabled, attempting transmission of element and/or sensor data via the COMM module</li>
</ol>
<p>This top-level update function is also responsible for determining whether to use the standard update routine (<b>CAPT_updateSensor()</b>)or the EMC update routine (<b>CAPT_updateSensorWithEMC()</b>), depending on whether or not noise immunity is enabled.</p>
<p>This function should be called periodically to update all of the sensors in the system. After this function is called, the following values are updated:</p><ul>
<li>Raw count</li>
<li>Filtered count</li>
<li>Long term average (LTA)</li>
<li>Detect and negative touch flags</li>
<li>Touch and proximity flags</li>
<li>Previous touch flags</li>
<li>Dominant element ID (for a button group)</li>
<li>Position (for a slider or wheel)</li>
<li>Max count error flags and noise state flags</li>
<li>De-bounce counters</li>
</ul>
<p>After the values are updated via a call to <b>CAPT_updateUI()</b>, any value can be checked by referencing it in the appropriate data structure.</p>
<h3>Simple Code Example</h3>
<p>The example below demonstrates the structure of a typical application. For simplicity, this example application continuously measures the UI and does not go to sleep in between scans. To enable scheduled scanning, it is necessary to use a timer to trigger the update, such as the CapTIvate&trade; interval timer.</p>
<div class="fragment"><div class="line"><span class="comment">// Execute one-time setup functions</span></div>
<div class="line">CAPT_initUI(&amp;g_uiApp);</div>
<div class="line">CAPT_calibrateUI(&amp;g_uiApp);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span>(1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Continuously update the UI</span></div>
<div class="line">    CAPT_updateUI(&amp;g_uiApp);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="ch_lib_howto_callbacks"></a>
Register a Callback Function</h2>
<p>Callbacks provide a mechanism for the application to be notified when a sensor has been updated. The application must first register its "callback" function for each sensor before it can receive updates. When the callback is executed, the application can query the sensor's data structure to determine the status of the sensor.</p>
<p>The library function <b>CAPT_registerCallback()</b> provides the registration.</p>
<p><b>Format</b> </p>
<p>Sensor callback functions are passed a pointer to the calling sensor, and they must return void. An example skeleton callback function is shown below: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_button_callback(tSensor* pSensor)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// DO SOMETHING ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Example</b> </p>
<p>This is what it would look like to register the callback function named "my_button_callback" to the sensor BTN0000. </p><div class="fragment"><div class="line">MAP_CAPT_registerCallback(&amp;BTN0000, &amp;my_button_callback);</div>
</div><!-- fragment --><p>Once an application's callback function is registered, the callback is executed each time the corresponding sensor is scanned and processed, regardless if a proximity or touch detection has occurred. Inside the user callback, the application can perform any required sensor data and status post-processing. In a typical button application, this is where the application will check for a proximity, touch detection or slider/wheel position.</p>
<p><b>Example</b> </p>
<p>Here is a typical callback example for a button that checks both when a touch is detected and a release. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_button_callback(tSensor* pSensor)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>((pSensor-&gt;bSensorTouch == <span class="keyword">true</span>) &amp;&amp; (pSensor-&gt;bSensorPrevTouch == <span class="keyword">false</span>))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// BUTTON PRESSED</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// DO SOMETHING ...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>((pSensor-&gt;bSensorTouch == <span class="keyword">false</span>) &amp;&amp; (pSensor-&gt;bSensorPrevTouch == <span class="keyword">true</span>))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// BUTTON RELEASED</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// DO SOMETHING ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here is a callback example for a proximity sensor. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_proximity_callback(tSensor* pSensor)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(pSensor-&gt;bSensorProx == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// PROXIMITY DETECTED</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// DO SOMETHING ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In addition to proximity and touch status, sliders and wheels also provide position status. Here is a typical callback example for a slider or wheel that checks a sensor's position. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_slider_callback(tSensor* pSensor)</div>
<div class="line">{</div>
<div class="line">    uint16_t ui16Position;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// FIRST CHECK IF THERE IS VALID TOUCH</span></div>
<div class="line">    <span class="keywordflow">if</span>(pSensor-&gt;bSensorTouch == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// THEN GET THE CURRENT TOUCH POSITION ON THE SLIDER/WHEEL</span></div>
<div class="line">        ui16Position = (uint16_t)((tSliderSensorParams*)pSensor-&gt;pSensorParams)-&gt;SliderPosition.ui16Natural;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// DO SOMETHING WITH POSITION ...</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="ch_lib_howto_elementstatedata"></a>
Access Element State Data</h2>
<p>Each element in a sensor has a set of boolean state flags that indicate its status. The following flags are provided:</p>
<ul>
<li>Detection</li>
<li>Negative touch detection</li>
<li>Proximity</li>
<li>Touch</li>
<li>Built-in-self-test (BIST) status</li>
<li>Noise status</li>
</ul>
<p>When a sensor is updated (via <b>CAPT_updateUI()</b>, <b>CAPT_updateSensor()</b>, or <b>CAPT_updateSensorWithEMC()</b>), these status flags are updated for every element within the sensor. There are multiple ways to retrieve the data for processing.</p>
<h3>Accessing Element State Data Directly</h3>
<p>It is possible to access element state data directly in an element's data structure. To do this, it is necessary to know the name of the variable in the element. An example is shown below that uses element 0 of a sensor named <em>keypad</em> to control some other function, such as illuminating an LED.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> tElement keypad_E00;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> updateLED(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(keypad_E00.bTouch == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ILLUMINATE LED</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TURN LED OFF</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Accessing Element State Data Indirectly</h3>
<p>Note that in the example above, it was necessary to forward declare keypad_E00. It is also possible to "look up" E00 of the keypad sensor though the parent sensor structure, as shown below. All sensor structures are forward declared in the user configuration header file (<em>CAPT_UserConfig.h</em>), and do not need to be re-declared. The element of interest is accessed via the cycle pointer array and the element pointer array of that cycle.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> updateLED(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(keypad.pCycle[0]-&gt;pElements[0]-&gt;bTouch == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ILLUMINATE LED</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TURN LED OFF</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Generating a Status Bit Field for all Elements in a Sensor</h3>
<p>The above access methods shown are simple and do not require very much memory. However, they only provide data for one element. The library function <b>CAPT_getElementStateBitField()</b> returns a bit field in which each element is represented with a bit position. The bit field supports up to 64 elements. The return type is a 64-bit unsigned integer, which may be casted down to the size that is needed for the application.</p>
<p>Elements are mapped to bit positions starting with the first element of the first cycle to the last element of the last cycle. For example, a sensor with two cycles and two elements in each cycle would have the following mapping:</p><ul>
<li>Return value bit 0 (0x01): Cycle 0 Element 0</li>
<li>Return value bit 1 (0x02): Cycle 0 Element 1</li>
<li>Return value bit 2 (0x04): Cycle 1 Element 0</li>
<li>Return value bit 3 (0x08): Cycle 1 Element 1</li>
</ul>
<p>This function may be used to query any of the element status flags. The example below tests the touch status flag. If element 0 and element 1 (BIT0 and BIT1), or 0x03, are touched, the LED would be illuminated.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> updateLED(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    uint8_t multiTouchState;</div>
<div class="line">    multiTouchState = (uint8_t)CAPT_getElementStateBitField(&amp;keypad, eTouchStatus);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If &#39;0x03&#39;, or element 0 and element 1, are both in detect:</span></div>
<div class="line">    <span class="keywordflow">if</span> (multiTouchState &amp; 0x03)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ILLUMINATE LED</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// LED OFF</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Accessing a Sensor's Global Flags</h3>
<p>Many of the flags that are available at the element level are also available as global flags at the sensor level. The global, sensor-level flags operate as a logical OR of all elements in the sensor. In other words, if any element's flag is set, the sensor's global flag is also set. It this way, it is possible to quickly test one flag to see if anything is happening with a sensor. Then, if something is, the element flags can be used to identify which element(s) threw the flag. In the example below, the LED would be illuminated if any element in the sensor was touched.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> sensorHandler(tSensor* pSensor)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(pSensor-&gt;bSensorTouch == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ILLUMINATE LED</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TURN LED OFF</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In addition to the global sensor touch flag (<em>bSensorTouch</em>), there is also a global sensor previously touched flag (<em>bSensorPrevTouch</em>). This flag is set if <em>bSensorTouch</em> was set on the previous sample. This can be used as a mechanism to determine if a touch is new (meaning someone just touched the button) versus stale (meaning the touch on this sample is a continuation of a previously started touch). This allows for toggling between states, as shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> sensorHandler(tSensor* pSensor)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>((pSensor-&gt;bSensorTouch == <span class="keyword">true</span>) &amp;&amp; (pSensor-&gt;bSensorPrevTouch == <span class="keyword">false</span>))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TOGGLE A FUNCTION</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Element Status Flag Reference Table</h3>
<p>The table below lists the available status flags that all elements have, and the name of the parameter to use when accessing it.</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Element Structure Parameter</th><th align="left">CAPT_getElementStateBitField() Parameter  </th></tr>
<tr>
<td align="left">Touch Detection</td><td align="left">.bTouch</td><td align="left">eTouchStatus </td></tr>
<tr>
<td align="left">Proximity Detection</td><td align="left">.bProx</td><td align="left">eProxStatus </td></tr>
<tr>
<td align="left">Negative Touch Detect</td><td align="left">.bNegativeTouch</td><td align="left">eNegativeTouchStatus </td></tr>
<tr>
<td align="left">Detect</td><td align="left">.bDetect</td><td align="left">eDetectStatus </td></tr>
<tr>
<td align="left">Built-in-self-test Fail</td><td align="left">.bBISTFail</td><td align="left">eBISTStatus </td></tr>
<tr>
<td align="left">Noise Detected</td><td align="left">.bNoiseDetected</td><td align="left">eNoiseStatus </td></tr>
</table>
<p>The <em>detect</em> status is the un-debounced state of the <em>prox</em> status. When an element is in <em>detect</em> but not in <em>prox</em>, this means that the long term average tracking filter is disabled, but the state change into proximity detection is not yet complete because it is currently being de-bounced.</p>
<h2><a class="anchor" id="ch_lib_howto_dominantbutton"></a>
Access the Dominant Button</h2>
<p>Button group sensors output a dominant button ID that corresponds to the element with the highest delta response. This is useful for keypads which do not require multi-touch but would like to have some level of nearby key rejection. For example, if a user is touching in between to keys, the dominant key with the highest delta response will be reported.</p>
<p>When a button group sensor is updated (via <b>CAPT_updateUI()</b>, <b>CAPT_updateSensor()</b>, or <b>CAPT_updateSensorWithEMC()</b>), the dominant element value is updated.</p>
<p>Elements are mapped to IDs starting with the first element of the first cycle to the last element of the last cycle. For example,a sensor with two cycles and two elements in each cycle would have the following mapping:</p><ul>
<li>0: Cycle 0 Element 0</li>
<li>1: Cycle 0 Element 1</li>
<li>2: Cycle 1 Element 0</li>
<li>3: Cycle 1 Element 1</li>
</ul>
<h3>Accessing the Dominant Button Directly</h3>
<p>The example below shows how to directly access the value in the <em>tButtonSensorParams</em> structure. The LED is illuminated if a touch is present and the dominant key is the first element.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> tButtonSensorParams keypadSensor_Params;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> updateLED(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (keypadSensor.bSensorTouch == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (keypadSensor_Params.ui16DominantElement == 0x00)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// ILLUMINATE LED</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// TURN OFF LED</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TURN OFF LED</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Accessing the Dominant Button Indirectly</h3>
<p>Note that in the example above, it was necessary to forward declare keypadSensor_Params. It is also possible to "look up" these parameter structures through the parent sensor structure, as shown below. All sensor structures are forward declared in the user configuration header file (<em>CAPT_UserConfig.h</em>), and do not need to be re-declared. It is necessary to type-cast the parameter structure based on the type of sensor.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> updateLED(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    uint8_t dominantButton;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (keypadSensor.bSensorTouch == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        dominantButton = ((tButtonSensorParams*)(keypadSensor.pSensorParams))-&gt;ui16DominantElement;</div>
<div class="line">        <span class="keywordflow">if</span> (dominantButton == 0x00)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// ILLUMINATE LED</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// TURN OFF LED</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// TURN OFF LED</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Accessing the Dominant Button with a Function Call</h3>
<p>The final way to access the dominant button value is via a function call to <b>CAPT_getDominantButton()</b> or <b>CAPT_getDominantButtonAddr()</b>. The former function returns the ID of the dominant button, while the latter function returns the memory address (essentially a pointer to) the dominant element.</p>
<p>The example below demonstrates accessing the dominant button ID via a function call.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> updateLEDs(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    uint8_t dominantElement;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ((keypadSensor.bSensorTouch==<span class="keyword">true</span>) &amp;&amp; (keypadSensor.bSensorPrevTouch==<span class="keyword">false</span>))</div>
<div class="line">    {</div>
<div class="line">        dominantElement = CAPT_getDominantButton(&amp;keypadSensor);</div>
<div class="line">        <span class="keywordflow">if</span> (dominantElement == 0)</div>
<div class="line">        {</div>
<div class="line">            LED1_OFF;</div>
<div class="line">            LED2_OFF;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dominantElement == 1)</div>
<div class="line">        {</div>
<div class="line">            LED1_ON;</div>
<div class="line">            LED2_OFF;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dominantElement == 2)</div>
<div class="line">        {</div>
<div class="line">            LED1_OFF;</div>
<div class="line">            LED2_ON;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dominantElement == 3)</div>
<div class="line">        {</div>
<div class="line">            LED1_ON;</div>
<div class="line">            LED2_ON;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The example below demonstrates processing of the dominant button based on a pointer to the dominant element.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> tElement keypadSensor_E00;</div>
<div class="line"><span class="keyword">extern</span> tElement keypadSensor_E01;</div>
<div class="line"><span class="keyword">extern</span> tElement keypadSensor_E02;</div>
<div class="line"><span class="keyword">extern</span> tElement keypadSensor_E03;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> updateLEDs(tSensor *sensor)</div>
<div class="line">{</div>
<div class="line">    tElement* dominantElement;</div>
<div class="line">    <span class="keywordflow">if</span> ((keypadSensor.bSensorTouch==<span class="keyword">true</span>) &amp;&amp; (keypadSensor.bSensorPrevTouch==<span class="keyword">false</span>))</div>
<div class="line">    {</div>
<div class="line">        dominantElement = CAPT_getDominantButtonAddr(&amp;keypadSensor);</div>
<div class="line">        <span class="keywordflow">if</span> (dominantElement == &amp;keypadSensor_E00)</div>
<div class="line">        {</div>
<div class="line">            LED1_OFF;</div>
<div class="line">            LED2_OFF;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dominantElement == &amp;keypadSensor_E01)</div>
<div class="line">        {</div>
<div class="line">            LED1_ON;</div>
<div class="line">            LED2_OFF;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dominantElement == &amp;keypadSensor_E02)</div>
<div class="line">        {</div>
<div class="line">            LED1_OFF;</div>
<div class="line">            LED2_ON;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dominantElement == &amp;keypadSensor_E03)</div>
<div class="line">        {</div>
<div class="line">            LED1_ON;</div>
<div class="line">            LED2_ON;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="ch_lib_howto_sliderwheeldata"></a>
Access Slider or Wheel Position Data</h2>
<p>Slider and wheel sensors output a position in addition to touch and proximity status. The position value is available as a IQ16-style value, with 16 integer bits and 16 fractional bits. For almost all applications, the integer bits are the bits of interest, and the fractional bits are merely there to support filtering.</p>
<p>When a slider or wheel sensor is updated (via <b>CAPT_updateUI()</b>, <b>CAPT_updateSensor()</b>, or <b>CAPT_updateSensorWithEMC()</b>), the position value is updated.</p>
<p><b>NOTE:</b> When a slider or wheel sensor is not being touched, a value of 0xFFFF (UINT16_MAX) is reported.</p>
<h3>Accessing the Slider or Wheel Position Directly</h3>
<p>The example below shows how to directly access the slider and wheel position parameters in the <em>tSliderSensorParams</em> and <em>tWheelSensorParams</em> structures, respectively. The application assigns the values to the speakerVolume and optionSelection variables, which are intended to represent functionality in an application.</p>
<div class="fragment"><div class="line">uint16_t speakerVolume;</div>
<div class="line">uint16_t optionSelection;</div>
<div class="line"><span class="keyword">extern</span> tSliderSensorParams volumeSlider_Params;</div>
<div class="line"><span class="keyword">extern</span> tWheelSensorParams scrollWheel_Params;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> updateVolumeAndOptionSelection(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Set the speaker volume to the natural (integer) 16 bit slider position</span></div>
<div class="line">    <span class="keywordflow">if</span> (volumeSlider_Params.SliderPosition.ui16Natural != UINT16_MAX)</div>
<div class="line">    {</div>
<div class="line">        speakerVolume = volumeSlider_Params.SliderPosition.ui16Natural;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the option selection to the natural (integer) 16 bit wheel position</span></div>
<div class="line">    <span class="keywordflow">if</span> (scrollWheel_Params.SliderPosition.ui16Natural != UINT16_MAX)</div>
<div class="line">    {</div>
<div class="line">        optionSelection = scrollWheel_Params.SliderPosition.ui16Natural;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Accessing the Slider or Wheel Position Indirectly</h3>
<p>Note that in the example above, it was necessary to forward declare volumeSlider_Params and scrollWheel_Params. It is also possible to "look up" these parameter structures through the parent sensor structure, as shown below. All sensor structures are forward declared in the user configuration header file (<em>CAPT_UserConfig.h</em>), and do not need to be re-declared. It is necessary to type-cast the parameter structure based on the type of sensor.</p>
<div class="fragment"><div class="line">uint16_t speakerVolume;</div>
<div class="line">uint16_t optionSelection;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> updateVolumeAndOptionSelection(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    uint16_t position;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the speaker volume to the natural (integer) 16 bit slider position</span></div>
<div class="line">    position = ((tSliderSensorParams*)(volumeSlider.pSensorParams))-&gt;SliderPosition.ui16Natural;</div>
<div class="line">    if (position != UINT16_MAX)</div>
<div class="line">    {</div>
<div class="line">        speakerVolume = position;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the option selection to the natural (integer) 16 bit wheel position</span></div>
<div class="line">    position = ((tWheelSensorParams*)(scrollWheel.pSensorParams))-&gt;SliderPosition.ui16Natural;</div>
<div class="line">    if (position != UINT16_MAX)</div>
<div class="line">    {</div>
<div class="line">        optionSelection = position;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that for both slider and wheel parameter structures, the parameter for position is called <em>SliderPosition</em>. This is because both of these sensor types utilize the same processing algorithm.</p>
<h3>Accessing the Slider or Wheel Position with a Function Call</h3>
<p>The final (and simplest) way to access slider or wheel position is via a function call to <b>CAPT_getSensorPosition()</b>. This function will return 0xFFFF (UINT16_MAX) if no touch is present.</p>
<div class="fragment"><div class="line">uint16_t speakerVolume;</div>
<div class="line">uint16_t optionSelection;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> updateVolumeAndOptionSelection(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    uint16_t position;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the speaker volume to the natural (integer) 16 bit slider position</span></div>
<div class="line">    position = CAPT_getSensorPosition(&amp;volumeSlider);</div>
<div class="line">    <span class="keywordflow">if</span> (position != UINT16_MAX)</div>
<div class="line">    {</div>
<div class="line">        speakerVolume = position;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the option selection to the natural (integer) 16 bit wheel position</span></div>
<div class="line">    position = CAPT_getSensorPosition(&amp;scrollWheel);</div>
<div class="line">    <span class="keywordflow">if</span> (position != UINT16_MAX)</div>
<div class="line">    {</div>
<div class="line">        optionSelection = position;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using the function call allows the software implementation to be clearer, at the penalty of function overhead.</p>
<h2><a class="anchor" id="ch_lib_howto_elementmeasdata"></a>
Access Element Measurement Data</h2>
<p>Each element in a sensor has several variables that contain the current measurement data. The following values are provided:</p>
<ul>
<li>Filtered Count (The conversion result)</li>
<li>Long Term Average (LTA) (The baseline reference)</li>
<li>Raw Count(s) (The raw data sample before any processing is applied)</li>
<li>Composite Raw Count (The composite data sample of a multi-frequency or oversampled conversion)</li>
<li>Previous Composite Raw Count (The previous composite data sample of a multi-frequency or oversampled conversion)</li>
</ul>
<p>When a sensor is updated (via <b>CAPT_updateUI()</b>, <b>CAPT_updateSensor()</b>, or <b>CAPT_updateSensorWithEMC()</b>), these variables are updated for every element within the sensor. There are multiple ways to retrieve the data.</p>
<h3>Accessing Element State Data Directly</h3>
<p>It is possible to access element measurement data directly in an element's data structure. To do this, it is necessary to know the name of the variable in the element. An example is shown below that uses element 0 of a sensor named <em>keypad</em>.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> tElement keypad_E00;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> myDataFunction(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    uint16_t data;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Place the filtered count value into the &#39;data&#39; variable.</span></div>
<div class="line">    <span class="comment">// Note that the filtered count value is an IQ16 format variable with 16 integer bits and 16 fractional bits.</span></div>
<div class="line">    <span class="comment">// Typically, only the integer bits are of interest.</span></div>
<div class="line">    data = keypad_E00.filterCount.ui16Natural;</div>
<div class="line">    __no_operation();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Place the long term average into the &#39;data&#39; variable.</span></div>
<div class="line">    <span class="comment">// Note that the LTA is an IQ16 format variable with 16 integer bits and 16 fractional bits.</span></div>
<div class="line">    <span class="comment">// Typically, only the integer bits are of interest.</span></div>
<div class="line">    data = keypad_E00.LTA.ui16Natural;</div>
<div class="line">    __no_operation();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Place the raw count value into the &#39;data&#39; variable.</span></div>
<div class="line">    <span class="comment">// Note that there may be either 1 or 4 raw count variables, depending on whether the conversion</span></div>
<div class="line">    <span class="comment">// type used is single or multi-frequency.</span></div>
<div class="line">    data = keypad_E00.pRawCount[0];</div>
<div class="line">    __no_operation();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If the conversion is multi-frequency, then keypad_E00.pRawCount[0] holds frequency 0&#39;s result,</span></div>
<div class="line">    <span class="comment">// and keypad_E00.pRawCount[3] holds frequency 3&#39;s result.</span></div>
<div class="line">    <span class="comment">// The raw composite result of all 4 frequencies is placed in the keypad_E00.ui16CompositeRawCount variable.</span></div>
<div class="line">    data = keypad_E00.ui16CompositeRawCount;</div>
<div class="line">    __no_operation();</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Accessing Element Measurement Data Indirectly</h3>
<p>Note that in the example above, it was necessary to forward declare keypad_E00. It is also possible to "look up" E00 of the keypad sensor though the parent sensor structure, as shown below. All sensor structures are forward declared in the user configuration header file (<em>CAPT_UserConfig.h</em>), and do not need to be re-declared. The element of interest is accessed via the cycle pointer array and the element pointer array of that cycle.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myDataFunction(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    uint16_t data;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Place the filtered count value into the &#39;data&#39; variable.</span></div>
<div class="line">    <span class="comment">// Note that the filtered count value is an IQ16 format variable with 16 integer bits and 16 fractional bits.</span></div>
<div class="line">    <span class="comment">// Typically, only the integer bits are of interest.</span></div>
<div class="line">    data = keypad.pCycle[0]-&gt;pElements[0]-&gt;filterCount.ui16Natural;</div>
<div class="line">    __no_operation();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="ch_lib_howto_measuresensors"></a>
Update Sensors Independently</h2>
<p>Up until this point, all discussion around measuring sensors has been via the top level API- specifically, the <b>CAPT_updateUI()</b> call. When using the <b>CAPT_updateUI()</b> function call, all sensors in the application are updated. For most applications, this is the desired operation. However, there are cases where it may be desired to update sensors individually or at different rates. This how-to explains the function calls that are used to individually update sensors. There are two function calls available for updating a sensor: <b>CAPT_updateSensor()</b> and <b>CAPT_updateSensorWithEMC()</b>.</p>
<h3>CAPT_updateSensor()</h3>
<p>This is the standard sensor update function. After calling this function, the following values are updated for the passed sensor only:</p>
<ul>
<li>Raw counts</li>
<li>Filtered counts</li>
<li>Long term averages (LTAs)</li>
<li>Detect and negative touch flags</li>
<li>Touch and proximity flags</li>
<li>Previous touch flags</li>
<li>Dominant element ID (for a button group)</li>
<li>Position (for a slider or wheel)</li>
<li>Max count error flags and noise state flags</li>
<li>De-bounce counters</li>
</ul>
<p>Below is the syntax used to call the function. The parameters include a pointer to the sensor to update, and the low power mode bits to set during the conversion process. LPM0, LPM1, LPM2, and LPM3 may be used.</p>
<div class="fragment"><div class="line">CAPT_updateSensor(&amp;keypadSensor, LPM0_bits);</div>
</div><!-- fragment --><h3>CAPT_updateSensorWithEMC()</h3>
<p>The EMC version of the sensor update call provides the same end functionality as the standard call, with the exception that EMC plug-ins from the advanced layer are applied. When this function is used, the EMC configuration structure defines the style of conversion to use. This may mean that multi-frequency scanning and/or oversampling is utilized.</p>
<p>The syntax for the EMC version is identical to the standard version, as shown below. This is to provide a standard call so that application code does not need to change significantly to accommodate switching to an EMC scanning mode. All EMC plug-in configuration is controlled by the EMC configuration structure.</p>
<div class="fragment"><div class="line">CAPT_updateSensorWithEMC(&amp;keypadSensor, LPM0_bits);</div>
</div><!-- fragment --><h3>Important Functionality to Handle</h3>
<p>When the sensor update functions are used rather than the top level API, several other tasks need to be handled by the application, such as testing for a re-calibration condition or transmitting data.</p>
<h4>Testing for Re-Calibration</h4>
<p>Over time, the long term average of a sensor may drift. To ensure that consistent sensitivity is always provided, the software library provides a mechanism to test to see if any element in a sensor has drifted outside of an acceptable boundary. This mechanism is the <b>CAPT_testForRecalibration()</b> function. The <b>CAPT_updateUI()</b> function takes care of handling this when the top level API is used, but if sensors are updated individually then this needs to be handled by the application.</p>
<p>The typical handling method is shown below:</p>
<div class="fragment"><div class="line"><span class="comment">// Update the individual sensor(s)</span></div>
<div class="line">CAPT_updateSensor(&amp;keypadSensor, LPM0_bits);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Test for a re-calibration condition</span></div>
<div class="line"><span class="keywordflow">if</span> (CAPT_testForRecalibration(&amp;keypadSensor) == <span class="keyword">true</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// If a re-calibration is required, perform it now</span></div>
<div class="line">    CAPT_calibrateSensor(&amp;keypadSensor);</div>
<div class="line">}</div>
</div><!-- fragment --><p>For details on how the re-calibration test works, see the <a class="el" href="ch_Glossary.html#ch_glossary_runtime_reCalibration">runtime re-calibration</a> definition.</p>
<h4>Transmitting Sensor and Element Data</h4>
<p>If communication via the COMM module is desired, it is nescessary to add the calls to transmit the sensor and element data for this sensor via the COMM module.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// If the UART or Bulk I2C interface is enabled, write out element</span></div>
<div class="line"><span class="comment">// and sensor data.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#if ((CAPT_INTERFACE==__CAPT_UART_INTERFACE__)||\</span></div>
<div class="line"><span class="preprocessor">        (CAPT_INTERFACE==__CAPT_BULKI2C_INTERFACE__))</span></div>
<div class="line">CAPT_writeElementData(x);</div>
<div class="line">CAPT_writeSensorData(x);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>In this code example, 'x' represents the sensor's integer ID. This ID is the position of the sensor in the global sensor pointer array. This is the array that the COMM module uses to look up sensors.</p>
<p>For the CAPTIVATE-BSWP demo panel, the array looks like this:</p>
<div class="fragment"><div class="line">tSensor* g_pCaptivateSensorArray[CAPT_SENSOR_COUNT] =</div>
<div class="line">{</div>
<div class="line">    &amp;keypadSensor,</div>
<div class="line">    &amp;proximitySensor,</div>
<div class="line">    &amp;sliderSensor,</div>
<div class="line">    &amp;wheelSensor,</div>
<div class="line">};</div>
</div><!-- fragment --><p>Thus, the ID of the keypad sensor would be 0.</p>
<h3>Full Implementation</h3>
<p>Putting it all together, updating a sensor individually would have the following progression: </p><div class="fragment"><div class="line"><span class="comment">// Update the individual sensor(s)</span></div>
<div class="line">CAPT_updateSensor(&amp;keypadSensor, LPM0_bits);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Test for a re-calibration condition</span></div>
<div class="line"><span class="keywordflow">if</span> (CAPT_testForRecalibration(&amp;keypadSensor) == <span class="keyword">true</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// If a re-calibration is required, perform it now</span></div>
<div class="line">    CAPT_calibrateSensor(&amp;keypadSensor);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// If communications are enabled, transmit data now</span></div>
<div class="line"><span class="preprocessor">#if ((CAPT_INTERFACE==__CAPT_UART_INTERFACE__)||\</span></div>
<div class="line"><span class="preprocessor">        (CAPT_INTERFACE==__CAPT_BULKI2C_INTERFACE__))</span></div>
<div class="line">CAPT_writeElementData(0);</div>
<div class="line">CAPT_writeSensorData(0);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h2><a class="anchor" id="ch_lib_howto_measureraw"></a>
Update a Sensor's Raw Data Only</h2>
<p>For certain custom applications it may be desirable to only update a sensor's raw data after a conversion, bypassing all of the high-level processing. For applications that require this, the <b>CAPT_updateSensorRawCount()</b> may be used directly. This function only updates raw count values for each element in the sensor. No processing is performed on the data, and the sensor callback function is not called upon completion of the update. The raw data update function takes two additional parameters that specify details about type of conversion. An example function call is shown below that updates the raw data for a sensor named <em>keypad</em>. For details on the conversion type and oversampling type parameters, see the <a class="el" href="ch_lib.html#ch_lib_base_touch_sensorupdate_raw">CAPT_updateSensorRawCount</a> overview.</p>
<div class="fragment"><div class="line">CAPT_updateSensorRawCount(</div>
<div class="line">        &amp;keypadSensor,      <span class="comment">// Pointer to the sensor to update</span></div>
<div class="line">        eStandard,          <span class="comment">// Conversion type</span></div>
<div class="line">        eNoOversampling,    <span class="comment">// Oversampling type</span></div>
<div class="line">        LPM0_bits           <span class="comment">// Low power mode to use</span></div>
<div class="line">    );</div>
</div><!-- fragment --><p>After the update is complete, results may be looked up in each element's data structure. The following values are updated by this function:</p>
<ul>
<li>Composite Raw Count (The raw result after the specied multi-frequency processing or oversampling)</li>
<li>Previous Composite Raw Count (The composite raw result from the previous sample)</li>
<li>Noise Level (if the conversion was a multi-frequency conversion, the spread between data at frequencies)</li>
<li>Raw Count for Each Frequency (if the conversion was a multi-frequency conversion, else a single frequency)</li>
</ul>
<p>Below is an example of measuring a sensor named <em>keypad</em> without frequency hopping and with an oversampling level of 2. The composite output is read and used to perform some unknown task.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> tElement keypadSensor_E00;       </div>
<div class="line">uint16_t rawSample;     </div>
<div class="line"></div>
<div class="line"><span class="comment">// Perform the update</span></div>
<div class="line">CAPT_updateSensorRawCount(</div>
<div class="line">        &amp;keypadSensor,      <span class="comment">// Pointer to the sensor to update</span></div>
<div class="line">        eStandard,          <span class="comment">// Conversion type</span></div>
<div class="line">        e2xOversampling,    <span class="comment">// Oversampling type</span></div>
<div class="line">        LPM0_bits           <span class="comment">// Low power mode to use</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Read out the data</span></div>
<div class="line">rawSample = keypadSensor_E00.ui16CompositeRawCount;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Do Something ...</span></div>
</div><!-- fragment --><h2><a class="anchor" id="ch_lib_howto_shieldIO"></a>
Enable an IO as a Shield</h2>
<p>In self-capacitance mode, it is possible to enable an extra CapTIvate&trade; sensing IO to fire in phase with other IOs during a conversion. This provides a shielding effect that can reduce the parasitic capacitance of the sensing IOs.</p>
<p>In order to realize a shield IO, the following must be true:</p><ol type="1">
<li>The sensor of interest must be a self-capacitance sensor</li>
<li>The shield must be connected to an IO on a CapTIvate&trade; block that is not shared with the sensor of interest. For example, if the sensor of interest is a proximity sensor on CAP0.0 (block 0, pin 0), the shield may be connected to any pin on CAP1.x, CAP2.x, or CAP3.x- but it may NOT be connected to any pin on CAP0.x, since the proximity sensor (the sensor of interest) is on that block. If a shield is enabled on the same block as the sensor of interest, the effect will be equivalent to a digital "OR" in which the shield and the sensor of interest appear to be connected.</li>
</ol>
<p>To enable an IO as a shield, use the library function <b>CAPT_enableShieldIO()</b> as shown below. This enables CAP1.0 to be a shield structure.</p>
<div class="fragment"><div class="line"><span class="comment">// Enable shield IO before calibration:</span></div>
<div class="line">CAPT_enableShieldIO(1, 0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// If needed, the shield can be disabled:</span></div>
<div class="line">CAPT_disableShieldIO(1, 0);</div>
</div><!-- fragment --><h2><a class="anchor" id="ch_lib_howto_customEMC"></a>
Create a Custom EMC Configuration</h2>
<p>When noise immunity is enabled for a design, or when any of the *WithEMC() function calls are used, the EMC processing plug-ins from the ADVANCED module are applied. The EMC processing plug-ins are configured via a data structure. A default configuration is provided in the user configuration file that works well for most applications. However, if some customization is needed the default structure in the user configuration file may be overridden and a new structure may be provided in the application.</p>
<p>While it is possible to directly edit the structure in the user configuration file, it is best to make the changes elsewhere as the user configuration file is auto-generated by the CapTIvate&trade; Design Center, and any changes will be lost when an update is performed.</p>
<p>To add a custom EMC configuration, create a new EMC configuration data structure by copying the structure from the user configuration file and placing it in the application. It must be re-named with a unique name. The new structure may be placed in the CAPT_App.c file, if desired. Below is an example:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> tEMCConfig myCustomEMCConfig =</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Conversion Style</span></div>
<div class="line">    .selfModeConversionStyle = eMultiFrequency,</div>
<div class="line">    .projModeConversionStyle = eMultiFrequencyWithOutlierRemoval,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Oversampling Style</span></div>
<div class="line">    .selfModeOversamplingStyle = eNoOversampling,</div>
<div class="line">    .projModeOversamplingStyle = eNoOversampling,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Jitter Filter Enable</span></div>
<div class="line">    .bJitterFilterEnable = <span class="keyword">true</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Noise Thresholds and Calibration Noise Limits</span></div>
<div class="line">    .ui8NoiseThreshold = 20,</div>
<div class="line">    .ui16CalibrationNoiseLimit = 10,</div>
<div class="line">    .ui8CalibrationTestSampleSize = 8,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Dynamic Threshold Adjustment Parameters</span></div>
<div class="line">    .bEnableDynamicThresholdAdjustment = <span class="keyword">true</span>,</div>
<div class="line">    .ui8MaxRelThreshAdj = 76,</div>
<div class="line">    .ui8NoiseLevelFilterEntryThresh = 40,</div>
<div class="line">    .ui8NoiseLevelFilterExitThresh = 0,</div>
<div class="line">    .ui8NoiseLevelFilterDown = 6,</div>
<div class="line">    .ui8NoiseLevelFilterUp = 1,</div>
<div class="line">    .coeffA = _IQ31(0.0065),</div>
<div class="line">    .coeffB = _IQ31(0.050)</div>
<div class="line">};</div>
</div><!-- fragment --><p>The structure is not modified at runtime, and thus may be declared as a <em>const</em> object.</p>
<p>In the the <b>CAPT_appStart()</b> function, there is a call to <b>CAPT_loadEMCConfig()</b>. Replace the passed configuration structure with the custom configuration structure.</p>
<p><b>Original</b> </p><div class="fragment"><div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Load the EMC configuration, if this design has</span></div>
<div class="line">    <span class="comment">// noise immunity features enabled.  This function call</span></div>
<div class="line">    <span class="comment">// associates an EMC configuration with the EMC module.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#if (CAPT_CONDUCTED_NOISE_IMMUNITY_ENABLE==true)</span></div>
<div class="line">    CAPT_loadEMCConfig(&amp;g_EMCConfig);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p><b>Modified</b> </p><div class="fragment"><div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Load the EMC configuration, if this design has</span></div>
<div class="line">    <span class="comment">// noise immunity features enabled.  This function call</span></div>
<div class="line">    <span class="comment">// associates an EMC configuration with the EMC module.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#if (CAPT_CONDUCTED_NOISE_IMMUNITY_ENABLE==true)</span></div>
<div class="line">    CAPT_loadEMCConfig(&amp;myCustomEMCConfig);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>Now, the custom configuration may be modified to suit the needs of the application. For details on how to set the parameters in the EMC configuration structure, see the <a class="el" href="ch_lib.html#ch_lib_emc">EMC Module</a> section.</p>
<h2><a class="anchor" id="ch_lib_howto_generalpurposedata"></a>
Stream Unformatted Data to the Design Center GUI</h2>
<p>In addition to the element and sensor data streaming to the CapTIvate&trade; Design Center customizer windows, a mechanism exists to stream miscellaneous user-defined data to a oscilloscope plot with logging capability.</p>
<ul>
<li>The data format is 16-bit unsigned integers.</li>
<li>Up to 29 values may be streamed.</li>
</ul>
<p>To stream data, insert a call to the <b>CAPT_writeGeneralPurposeData()</b> function.</p>
<p>The function expects a pointer to an array of 16-bit unsigned integers, and a length value that specifies how many values there are, up to the maximum of 29.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BUFFER_SIZE (8)</span></div>
<div class="line">uint16_t buffer[BUFFER_SIZE];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Transmit the packet via the general purpose data mechanism</span></div>
<div class="line">CAPT_writeGeneralPurposeData(&amp;buffer[0], BUFFER_SIZE);</div>
</div><!-- fragment --><p>This mechanism is very helpful during development of noise immunity applications, as it allows for streaming of raw data and multi-frequency data. The code snippet below may be registered as a callback function for a sensor. It streams the data of the first element in the sensor with the following format:</p><ol type="1">
<li>LTA</li>
<li>Filtered Count</li>
<li>Abs Thresh</li>
<li>Noise Level</li>
<li>F0 Raw Value</li>
<li>F1 Raw Value</li>
<li>F2 Raw Value</li>
<li>F3 Raw Value</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#define NOISETEST_PACKET_SIZE (8)</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> NoiseTest_callbackHandler(tSensor* pSensor)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> uint16_t packet[NOISETEST_PACKET_SIZE];</div>
<div class="line">    tElement *element;</div>
<div class="line">    uint16_t threshold;</div>
<div class="line">    uint8_t i;</div>
<div class="line">    uint8_t j;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Initialize variables</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    i = 0;</div>
<div class="line">    element = pSensor-&gt;pCycle[0]-&gt;pElements[0];</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Compute the touch threshold</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    threshold = element-&gt;ui8TouchThreshold;</div>
<div class="line">    <span class="keywordflow">if</span> (pSensor-&gt;SensingMethod == eSelf)</div>
<div class="line">    {</div>
<div class="line">        threshold += CAPT_computeRelNoiseComp();</div>
<div class="line">        <span class="keywordflow">if</span> (threshold &gt; CAPT_getMaxRelThreshold())</div>
<div class="line">        {</div>
<div class="line">            threshold = CAPT_getMaxRelThreshold();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    threshold = CAPT_convertRelToAbs(element-&gt;LTA.ui16Natural, threshold);</div>
<div class="line">    <span class="keywordflow">if</span> (pSensor-&gt;DirectionOfInterest == eDOIDown)</div>
<div class="line">    {</div>
<div class="line">        threshold = element-&gt;LTA.ui16Natural - threshold;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        threshold = element-&gt;LTA.ui16Natural + threshold;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Frame the packet</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    packet[i++] = element-&gt;LTA.ui16Natural;</div>
<div class="line">    packet[i++] = element-&gt;filterCount.ui16Natural;</div>
<div class="line">    packet[i++] = threshold;</div>
<div class="line">    packet[i++] = element-&gt;ui16NoiseCount;</div>
<div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;4; j++)</div>
<div class="line">    {</div>
<div class="line">        packet[i++] = element-&gt;pRawCount[j];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Transmit the packet via the general purpose data mechanism</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    CAPT_writeGeneralPurposeData(&amp;packet[0], NOISETEST_PACKET_SIZE);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When communications are enabled, this data will appear in the CapTIvate&trade; Design Center's user data plot. To view the streaming data, add a user data log bean, as shown below:</p>
<div class="image">
<img src="lib_howto_userdataplot.png" alt="lib_howto_userdataplot.png"/>
<div class="caption">
User Data Plot</div></div>
  <hr/>
 <h1><a class="anchor" id="ch_lib_techdetails"></a>
Technical Details</h1>
<p>The CapTIvate&trade; Software Library has certain technical features and requirements, described below.</p>
<h2><a class="anchor" id="ch_lib_techdetails_rom"></a>
Devices with CapTIvate Software in ROM</h2>
<p>Some MSP devices have portions of the CapTIvate&trade; Software Library in ROM, reducing the amount of FRAM or flash memory required for an application. Refer to the device data sheet to determine if a given device has library components in ROM.</p>
<h3>Calling Functions in ROM</h3>
<p>Calling library functions directly from ROM requires the use of two header files that are provided with the library, rom_captivate.h and rom_map_captivate.h. These header files provide a mapping between functions in the software library archive and the same function located in a device's ROM image. Use the function call technique described in the following example to simplify the procedure.</p>
<p><b>Example:</b> </p>
<p>Assume the captivate.lib has been added to the project and header files rom_captivate.h and map_rom_captivate.h are included in the source file where the library function call will be made. To call the library function "foo()", it is recommended to make an implicit ROM call <em>MAP_foo()</em>. The complier parses through the rom_map_captivate.h file to determine if the function resides in ROM, and if it does, will make the ROM call. If this function does not exist in ROM then the compiler will make a call to the pre-compiled library version.</p>
<p>It is possible to explicitly call the function "foo()" from the pre-compiled library using <em>foo()</em>. The linker will pull this function from the pre-compiled library during the link process, adding the function to FRAM program memory. To explicitly call the function "foo()" from ROM, use <em>ROM_foo()</em>. This will force the compiler to make a call to ROM, with no impact on FRAM program memory.</p>
<h2><a class="anchor" id="ch_lib_techdetails_memmodel"></a>
MSP430 CPUX Memory Model</h2>
<p>Smaller memory map devices with the TI MSP430 CPUX core (such as the MSP430FR26xx and MSP430FR25xx devices) have a total memory map that is less than 64kB. Such a memory map is accessible in its entirety with 16 bit pointers. In order to improve execution speed and reduce memory requirements, the ROM functions and pre-compiled library functions are compiled using the small code small data (SCSD) memory model. All CapTIvate&trade; software library projects must be compiled using the small code small data memory model in order to be compatible with the ROM functions and the pre-compiled library. Using the incorrect memory model will result in a linker error.</p>
<hr/>
 <h1><a class="anchor" id="ch_lib_base"></a>
Base Module</h1>
<p>The base module implements the core of the CapTIvate&trade; Software Library. It is responsible for providing the base feature set for initializing, calibrating, measuring and processing capacitive sensors.</p>
<p>The base module contains the following components:</p><ul>
<li>Hardware Abstraction Layer (HAL)</li>
<li>Touch Layer</li>
<li>Interrupt Service Routine (ISR)</li>
<li>CapTIvate&trade; Software Library Type Definitions</li>
</ul>
<h2><a class="anchor" id="ch_lib_base_hal"></a>
HAL</h2>
<p>The hardware abstraction layer provides access to the CapTIvate&trade; peripheral. This includes functions for performing the following tasks:</p>
<ul>
<li>Configuring the CapTIvate&trade; peripheral periodic timer</li>
<li>Handling CapTIvate&trade; peripheral interrupts</li>
<li>Configuring IO for CapTIvate&trade;</li>
<li>Configuring conversion settings</li>
<li>Loading and storing conversion results</li>
</ul>
<h2><a class="anchor" id="ch_lib_base_touch"></a>
Touch</h2>
<p>The touch layer sits on top of the HAL layer and provides the sensor update routines, calibration algorithms, and basic sensor processing algorithms.</p>
<h3><a class="anchor" id="ch_lib_base_touch_sensorupdate"></a>
Sensor Update Routines</h3>
<p>Several sensor update routines are available in the touch module:</p>
<ol type="1">
<li><b>CAPT_updateSensor()</b></li>
<li><b>CAPT_updateSensorWithEMC()</b></li>
<li><b>CAPT_updateSensorRawCount()</b></li>
</ol>
<h4><a class="anchor" id="ch_lib_base_touch_sensorupdate_basic"></a>
CAPT_updateSensor()</h4>
<p>This is the standard, fundamental sensor update routine that is used in most applications. Calling this function will immediately measure all of the elements within the sensor, and perform all of the standard signal processing, including:</p>
<ol type="1">
<li>Applying any IIR count filtering as configured in the sensor structure. This function utilizes the hardware accelerated IIR filtering in the CapTIvate&trade; finite state machine.</li>
<li>Testing of touch, proximity, and negative touch thresholds. This function utilizes the detection capability of the CapTIvate&trade; finite state machine to detect proximity and negative touch events.</li>
<li>Processing of the long term average (LTA) as configured in the sensor structure. This function utilizes the hardware accelerated IIR filtering in the CapTIvate&trade; finite state machine to process the LTA.</li>
<li>Application of touch/proximity de-bounce as configured in the sensor structure.</li>
<li>Testing for re-calibration, if so configured in the sensor structure.</li>
</ol>
<p>The function takes two parameters:</p><ul>
<li>A pointer to the sensor structure to update</li>
<li>The low power mode to use during the conversion</li>
</ul>
<div class="fragment"><div class="line">CAPT_updateSensor(&amp;mySensor,  LPM3_bits);</div>
</div><!-- fragment --><h5>Low Power Mode</h5>
<p>The low power mode may be LPM0 to LPM3. The function returns when all measurements and processing are complete.</p>
<h4><a class="anchor" id="ch_lib_base_touch_sensorupdate_emc"></a>
CAPT_updateSensorWithEMC()</h4>
<p>This function is identical to <b>CAPT_updateSensor()</b>, with the addition of EMC processing components from the EMC module. See the <a class="el" href="ch_lib.html#ch_lib_emc">EMC module</a> for more details.</p>
<h4><a class="anchor" id="ch_lib_base_touch_sensorupdate_raw"></a>
CAPT_updateSensorRawCount()</h4>
<p>This is a basic function that may be used if access to the raw conversion data if that is all that is desired. Using this function bypasses all of the higher-level processing. Filtered count, long term average, and status parameters are not maintained. Only the raw results are populated. However, the function does allow for some low-level signal processing algorithms to be applied.</p>
<p>The function takes 4 parameters:</p><ul>
<li>A pointer to the sensor structure to update</li>
<li>A conversion style specification</li>
<li>An oversampling specification</li>
<li>The low power mode to use during the conversion</li>
</ul>
<div class="fragment"><div class="line">CAPT_updateSensorRawCount(</div>
<div class="line">        &amp;keypadSensor,      <span class="comment">// Pointer to the sensor to update</span></div>
<div class="line">        eStandard,          <span class="comment">// Conversion type</span></div>
<div class="line">        eNoOversampling,    <span class="comment">// Oversampling type</span></div>
<div class="line">        LPM0_bits           <span class="comment">// Low power mode to use</span></div>
<div class="line">    );</div>
</div><!-- fragment --><h5>Conversion Style</h5>
<p>The conversion style control influences the type of conversion used to update the raw values. The output is stored in the *.ui16CompositeRawCount* parameter of each element.</p>
<table class="doxtable">
<tr>
<th align="left">Option</th><th align="left">tRawConversionStyle Enumeration  </th></tr>
<tr>
<td align="left">Standard</td><td align="left">eStandard </td></tr>
<tr>
<td align="left">Multi-Frequency</td><td align="left">eMultiFrequency </td></tr>
<tr>
<td align="left">Multi-Frequency with Outlier Removal</td><td align="left">eMultiFrequencyWithOutlierRemoval </td></tr>
</table>
<ul>
<li><b>Standard conversion</b>, in which each time cycle is measured once. This is the normal conversion style that should be used for most applications.</li>
<li><b>Multi-frequency conversion</b>, in which each time cycle is measured at 4 frequencies and the composite result is the average of the 4 frequencies.</li>
<li><b>Multi-frequency conversion with outlier removal</b>, in which each time cycle is measured at 4 frequencies and the composite result is the average of the 4 frequencies after the largest outlier is removed from the data set. This is useful for mutual capacitance sensors that require conducted noise immunity.</li>
</ul>
<h5>Oversampling</h5>
<p>The oversampling style control allows for the addition of oversampling in binary steps to a conversion. The available options are listed below:</p>
<table class="doxtable">
<tr>
<th align="left">Option</th><th align="left">tOversamplingStyle Enumeration  </th></tr>
<tr>
<td align="left">No Oversampling</td><td align="left">eNoOversampling </td></tr>
<tr>
<td align="left">Double</td><td align="left">e2xOversampling </td></tr>
<tr>
<td align="left">Quadruple</td><td align="left">e4xOversampling </td></tr>
<tr>
<td align="left">8x </td><td align="left">e8xOversampling </td></tr>
<tr>
<td align="left">16x </td><td align="left">e16xOversampling </td></tr>
<tr>
<td align="left">32x </td><td align="left">e32xOversampling </td></tr>
</table>
<p>When no oversampling is applied, each time cycle is sampled once and that value is used as the conversion result. When a level of oversampling is applied, each time cycle is sampled to the level of oversampling, and the results are averaged. This enables a basic averaging filter that helps with transient noise rejection.</p>
<p>Note that the measurement time increases 2x with each step.</p>
<h5>Low Power Mode</h5>
<p>The low power mode may be LPM0 to LPM3. The function returns when all measurements and processing are complete.</p>
<h3><a class="anchor" id="ch_lib_base_touch_calibrationalgorithms"></a>
Calibration Algorithms</h3>
<p>Sensors are calibrated with a top-level calibration call to <b>CAPT_calibrateSensor()</b> or <b>CAPT_calibrateSensorWithEMC()</b>. These two functions in turn call the two low-level calibration routines:</p>
<ul>
<li><b>CAPT_calibrateGain()</b>, for establishing each element's coarse gain and fine gain based upon the <em>ui16ConversionGain** parameter of the sensor being calibrated</em></li>
<li><em><b>CAPT_calibrateOffset()</b>, for establishing each element's offset subtraction based upon the previously calibrated coarse gain and fine gain values, and the sensor's *ui16ConversionCount</em> parameter.</li>
</ul>
<p>Functionally, calibration process is a two-step process:</p><ol type="1">
<li>First, <b>CAPT_calibrateGain()</b> is called. The coarse gain and fine gain is adjusted for each element in the sensor until the conversion result for each element is as close to the specified ui16ConversionGain parameter as possible.</li>
<li>Second, <b>CAPT_calibrateOffset()</b> is called. The offset subtraction is increased until the conversion result for each element is as close to the specified ui16ConversionCount parameter as possible.</li>
</ol>
<p>At the end of the calibration process, all elements should have conversion results that are normalized to the ui16ConversionCount parameter.</p>
<h3><a class="anchor" id="ch_lib_base_touch_environmentaldriftalgo"></a>
Environmental Drift Algorithms</h3>
<p>Capacitive sensing measurement results will drift over time in response to environmental changes such as temperature and humidity. Humidity effects dielectric properties (specifically, the dielectric of air). Large temperature changes can affect on-chip circuitry by changing the resistance of a pathway in a circuit, or causing an oscillator frequency to drift. This is partially why capacitive sensing is a relative measurement and not an absolute measurement. A change in temperature, humidity, or both can appear to the system as a touch if not properly interpreted. In order to distinguish an environmental change from a touch, it is necessary to examine the rate of the change. A touch event occurs more quickly than a temperature drift in most applications, and the two changes may be distinguished from each other on that basis.</p>
<p>To ensure reliable operation, slow drift in a sensor's measurement result due to temperature or humidity is handled by the CapTIvate Software Library in 3 ways:</p>
<ol type="1">
<li>First, the <a class="el" href="ch_Glossary.html#ch_glossary_lta_filter">long-term-average (LTA)</a> tracks measurement drift associated with slow environmental changes via a slow-moving IIR filter.</li>
<li>Second, the <a class="el" href="ch_Glossary.html#ch_glossary_touch_threshold">touch threshold</a> varies proportionally with the LTA, rather than as an absolute offset, to maintain sensitivity.</li>
<li>Third, if <a class="el" href="ch_Glossary.html#ch_glossary_runtime_reCalibration">runtime recalibration</a> is enabled then the system will re-calibrate if the LTA drifts outside of a window set at +/- 1/8th of the specified <a class="el" href="ch_Glossary.html#ch_glossary_conversion_count">conversion count</a>. This re-normalizes the sensors to the specified <a class="el" href="ch_Glossary.html#ch_glossary_conversion_count">conversion count</a>.</li>
</ol>
<p>These three methods work together to ensure that the system behaves as designed across the lifetime of the product, even in different environments and climates.</p>
<h2><a class="anchor" id="ch_lib_base_isr"></a>
ISR</h2>
<p>The CapTIvate&trade; peripheral has a single interrupt vector with 5 possible interrupt sources. For details on the interrupts themselves, see the <a class="el" href="ch_tech.html#ch_tech_captivatePeripheral_aux_dig_funcs">auxiliary digital functions</a> section of the <a class="el" href="ch_tech.html">technology</a> chapter.</p>
<p>The software library uses the peripheral interrupts to set global status flags. The ISR is designed to quickly determine the cause of an interrupt, set the appropriate status flag, and exit. Upon exit, any low power mode is cleared so that the CPU remains alive after the interrupt. This is the mechanism that is used to wake up the application.</p>
<p>Of the 5 interrupts that are available, 2 are used solely by the library and 3 are left up to the application.</p>
<p>The following flags are used by the library, and generally do not need to be tested in the application:</p><ol type="1">
<li>End of Conversion Interrupt (<em>CAPT_END_OF_CONVERSION_INTERRUPT</em>, <em>CAPT_IV_END_OF_CONVERSION</em>). This interrupt is triggered when a time cycle conversion is complete. The ISR sets the <em>g_bEndOfConversionFlag</em>, which signals the library that the conversion is complete.</li>
<li>Max Count Error Interrupt (<em>CAPT_MAX_COUNT_ERROR_INTERRUPT</em>, <em>CAPT_IV_MAX_COUNT_ERROR</em>). This interrupt is triggered if a conversion exceeds the error threshold that was specified for a sensor. The ISR sets the <em>g_bMaxCountErrorFlag</em>, which signals the library that the error limit was reached and the conversion has stopped.</li>
</ol>
<p>The following flags are meant to be used by the application:</p><ol type="1">
<li>Conversion Timer Interrupt (<em>CAPT_TIMER_INTERRUPT</em>, <em>CAPT_IV_TIMER</em>). This interrupt is triggered when the CapTIvate&trade; interval timer has counted up to the compare register, indicating that it is time to trigger a conversion. The ISR sets the <em>g_bConvTimerFlag</em>. It is expected that the application is configuring and monitoring this interrupt.</li>
<li>Conversion Counter Interrupt (<em>CAPT_CONVERSION_COUNTER_INTERRUPT</em>, <em>CAPT_IV_CONVERSION_COUNTER</em>). This interrupt is triggered when conversion counter has reached the conversion counter interrupt threshold. This mechanism allows for an interrupt to be thrown after a certain number of conversions have taken place. In a wake-on-proximity application, this can be used to periodically wake up the CPU to ensure that the application is proceeding as expected and that all values are within range. This interrupt is enabled by the <b>CAPT_startWakeOnProxMode()</b> function, and is disabled by the <b>CAPT_stopWakeOnProxMode()</b> function.</li>
<li>Detection Interrupt (<em>CAPT_DETECTION_INTERRUPT</em>, <em>CAPT_IV_DETECTION</em>). This interrupt is triggered when any element in a time cycle has its proximity or negative touch thresholds exceeded at the end of a conversion. This mechanism allows for the CPU to wake up due to a threshold crossing. This interrupt is enabled by the <b>CAPT_startWakeOnProxMode()</b> function, and is disabled by the <b>CAPT_stopWakeOnProxMode()</b> function.</li>
</ol>
<h2><a class="anchor" id="ch_lib_base_types"></a>
Type Definitions</h2>
<p>The type definitions file, <em>CAPT_Type.h</em>, contains the definitions for all of the data structures that are used in the library. It is important that the data structures are not modified! The library functions in ROM as well as the pre-compiled library are dependent upon the data structure configuration being consistent.</p>
<hr/>
 <h1><a class="anchor" id="ch_lib_advanced"></a>
Advanced Module</h1>
<p>The advanced module serves two main purposes: It provides processing plug-ins to the base module, and it provides the top level API. The top level API is implemented by the manager module. Processing plug-ins include button processing, slider/wheel processing, and EMC processing.</p>
<h2><a class="anchor" id="ch_lib_advanced_manager"></a>
Manager</h2>
<p>The manager provides the top level API for the library. For details on how to use the top level API, see the <a class="el" href="ch_lib.html#ch_lib_howto_toplevelapi">How to Use the Top Level API</a> section.</p>
<h2><a class="anchor" id="ch_lib_advanced_buttons"></a>
Buttons</h2>
<p>The buttons processing plug-in is a dominant element computation. The dominant element computation compares the delta response from all elements within the sensor. The element with the highest delta response is reported as the dominant element. For details on how to use the dominant element feature, see the <a class="el" href="ch_lib.html#ch_lib_howto_dominantbutton">How to Access the Dominant Button</a> section.</p>
<h2><a class="anchor" id="ch_lib_advanced_sliderswheels"></a>
Sliders and Wheels</h2>
<p>The slider processing plug-in provides a vector position computation to determine the location of a touch over a 1-dimensional array of elements. The same vector math is utilized for processing slider and wheel sensors. The slider is really just a special case of a wheel where the endpoints are disconnected.</p>
<h3>Supported Sizes</h3>
<p>A slider or wheel sensor must be composed of at least 3 elements, but no more than 12 elements.</p>
<h3>Supported Resolution</h3>
<p>The algorithm allows for up to 16 bits of resolution, although 5-10 bits is the typical use-case. Measurement results will be reported back from 0 to resolution-1.</p>
<h3>Slider Endpoint Trim</h3>
<p>The slider algorithm allows for "endpoint trim" to ensure that the beginning position is true 0 and the end position is the resolution-1. For details on how the endpoint trim works, see the <a class="el" href="ch_Glossary.html#ch_glossary_slider_trim">trim help section</a>.</p>
<h2><a class="anchor" id="ch_lib_emc"></a>
EMC</h2>
<p>The CapTIvate&trade; Software Library includes an EMC module in the advanced module. This module provides processing plug-ins to the touch layer to enhance robustness in the presence of noise. This section discusses how to configure that module. For a detailed noise immunity design guide, visit the <a class="el" href="ch_design.html#ch_design_noise">noise immunity</a> section of the design chapter.</p>
<h3><a class="anchor" id="ch_lib_emc_background"></a>
EMC Module Background</h3>
<p>While the CapTIvate&trade; peripheral provides a significant feature set for dealing with electromagnetic compatibility issues on its own, some amount of digital signal processing is still required to process the raw data into usable values. The EMC module in the CapTIvate&trade; Software Library fills that need by providing configurable algorithms to the base touch layer of the software library. It is not necessary to call EMC processing functions directly; rather, they are automatically called by the touch layer. The various EMC features are enabled, disabled, and configured via an EMC configuration structure.</p>
<p>The EMC module provides the following feature set:</p>
<ol type="1">
<li><b>Multi Frequency Processing (MFP) Algorithm</b> for resolving a raw measurement set of 4 frequencies into a single, usable measurement result</li>
<li><b>Multi Frequency Calibration Algorithm</b> for ensuring that accurate, usable calibration values are obtained during the sensor calibration process, even in a noisy environment</li>
<li><b>Oversampling (Averaging) Filter</b> to improve SNR</li>
<li><b>Jitter Filter</b> to remove small 1-count glitches</li>
<li><b>Global Relative Noise Level Tracking</b> to keep a global value of the noise level observed on all self-capacitance elements in the system for use in dynamic threshold adjustment</li>
<li><b>Dynamic Threshold Adjustment (DTA) Algorithm</b> for calculating a threshold adjustment factor to compensate for increased sensitivity of self-capacitance sensors in the presence of noise</li>
</ol>
<h3><a class="anchor" id="ch_lib_emc_overview_using"></a>
Using the EMC Module</h3>
<p>When using the CapTIvate&trade; Software Library, the EMC module functions are not called by the application. Rather, noise immunity is enabled for a user configuration at a top level. When noise immunity is enabled in the library for a design, the top level library functions for calibration and sensor measurement are replaced with EMC versions of the same functions.</p>
<h4><a class="anchor" id="ch_lib_emc_overview_using_enabling"></a>
Enabling Noise Immunity (EMC) Features</h4>
<p>It is best to enable noise immunity via the CapTIvate&trade; Design Center. The controller customizer has a compile-time option for <a class="el" href="DesignCenter.html#ch_cdc_UsersGuide_sec03_01">noise immunity</a>. Selecting this option sets the <b>CAPT_CONDUCTED_NOISE_IMMUNITY_ENABLE</b> compile-time definition in the CAPT_UserConfig.h file to <b>true</b> when source code is generated.</p>
<h4><a class="anchor" id="ch_lib_emc_overview_using_functions"></a>
Function Replacements with Noise Immunity Enabled</h4>
<p>When the compile-time option is set, the manager layer will make calls to EMC versions of functions rather than the standard versions. Below is a mapping of which functions are replaced:</p>
<h5>Top Level Functions</h5>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Standard Function</th><th align="left">EMC Function  </th></tr>
<tr>
<td align="left">Calibrate a Sensor</td><td align="left">CAPT_calibrateSensor()</td><td align="left">CAPT_calibrateSensorWithEMC() </td></tr>
<tr>
<td align="left">Update a Sensor</td><td align="left">CAPT_updateSensor()</td><td align="left">CAPT_updateSensorWithEMC() </td></tr>
</table>
<p>These top level functions are called by the application via abstractions in CAPT_Manager.</p>
<h5>Supporting Functions</h5>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Standard Function</th><th align="left">EMC Function  </th></tr>
<tr>
<td align="left">Process a Cycle</td><td align="left">CAPT_processFSMCycle()</td><td align="left">CAPT_processCycleWithEMC() </td></tr>
<tr>
<td align="left">Update Prox/Touch Status</td><td align="left">CAPT_updateProx, CAPT_updateTouch</td><td align="left">CAPT_updateSelfElementProxTouchWithEMC(), CAPT_updateProjElementProxTouchWithEMC() </td></tr>
</table>
<p>These functions are called inside the touch layer, and are not directly called by the application.</p>
<h4><a class="anchor" id="ch_lib_emc_configuration"></a>
EMC Module Configuration</h4>
<p>The EMC Module is configured through the tEMCConfig structure. The EMC layer only reads from this structure, so the configuration may be kept in non-volatile read-only memory if desired. A default configuration is provided in the user configuration file, and is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> tEMCConfig g_EMCConfig =</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Conversion Style</span></div>
<div class="line">    .selfModeConversionStyle = eMultiFrequency,</div>
<div class="line">    .projModeConversionStyle = eMultiFrequencyWithOutlierRemoval,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Oversampling Style</span></div>
<div class="line">    .selfModeOversamplingStyle = eNoOversampling,</div>
<div class="line">    .projModeOversamplingStyle = eNoOversampling,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Jitter Filter Enable</span></div>
<div class="line">    .bJitterFilterEnable = <span class="keyword">true</span>,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Noise Thresholds and Calibration Noise Limits</span></div>
<div class="line">    .ui8NoiseThreshold = 20,</div>
<div class="line">    .ui16CalibrationNoiseLimit = 10,</div>
<div class="line">    .ui8CalibrationTestSampleSize = 8,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Dynamic Threshold Adjustment Parameters</span></div>
<div class="line">    .bEnableDynamicThresholdAdjustment = <span class="keyword">true</span>,</div>
<div class="line">    .ui8MaxRelThreshAdj = 76,</div>
<div class="line">    .ui8NoiseLevelFilterEntryThresh = 40,</div>
<div class="line">    .ui8NoiseLevelFilterExitThresh = 0,</div>
<div class="line">    .ui8NoiseLevelFilterDown = 6,</div>
<div class="line">    .ui8NoiseLevelFilterUp = 1,</div>
<div class="line">    .coeffA = _IQ31(0.0065),</div>
<div class="line">    .coeffB = _IQ31(0.050)</div>
<div class="line">};</div>
</div><!-- fragment --><p>The default values were selected by bench characterization and have proven effective for several different sensing panels. However, for certain applications and/or certain noise environments, it may be necessary to adjust some of the parameters. To implement a custom configuration, simply create a new tEMCConfig structure with the desired values, and pass it's address to CAPT_loadEMCConfig() when the application is initialized at start-up. Note that the CapTIvate&trade; starter project makes this call in CAPT_appStart() just before CAPT_calibrateUI().</p>
<div class="fragment"><div class="line">CAPT_loadEMCConfig(&amp;g_EMCConfig);</div>
</div><!-- fragment --><p>The configuration parameters can be grouped into 5 different categories:</p><ul>
<li>Conversion Style Control</li>
<li>Oversampling Style Control</li>
<li>Jitter Filter Control</li>
<li>Noise Thresholds and Calibration Noise Limits</li>
<li>Dynamic Threshold Adjustment Parameters</li>
</ul>
<p>Each group will be discussed in detail below.</p>
<h4>Conversion Style Control</h4>
<div class="fragment"><div class="line"><span class="comment">// Conversion Style</span></div>
<div class="line">.selfModeConversionStyle = eMultiFrequency,</div>
<div class="line">.projModeConversionStyle = eMultiFrequencyWithOutlierRemoval,</div>
</div><!-- fragment --><p>The conversion style control influences the type of conversion used by EMC sensor update functions. Conversion style is specified separately for self and mutual capacitance sensors, enabling different algorithms to be applied to designs that have both self and mutual sensors. There are three possible conversion styles:</p>
<ul>
<li><b>Standard conversion</b>, in which each time cycle is measured once.</li>
<li><b>Multi-frequency conversion</b>, in which each time cycle is measured at 4 frequencies and the composite result is the average of the 4 frequencies</li>
<li><b>Multi-frequency conversion with outlier removal</b>, in which each time cycle is measured at 4 frequencies and the composite result is the average of the 4 frequencies after the largest outlier is removed from the data set.</li>
</ul>
<p>Conversion style is a data type that may be passed to the <b>CAPT_updateSensorRawCount()</b> function, which is what the EMC sensor update functions use to measure sensors. The enumeration options are shown below.</p>
<table class="doxtable">
<tr>
<th align="left">Option</th><th align="left">tRawConversionStyle Enumeration  </th></tr>
<tr>
<td align="left">Standard</td><td align="left">eStandard </td></tr>
<tr>
<td align="left">Multi-Frequency</td><td align="left">eMultiFrequency </td></tr>
<tr>
<td align="left">Multi-Frequency with Outlier Removal</td><td align="left">eMultiFrequencyWithOutlierRemoval </td></tr>
</table>
<p>For mutual (projected) capacitance sensors, the recommended style is multi-frequency with outlier removal. The narrow-band susceptibility of mutual capacitance sensors suites them well to this approach. If noise exists at one of the conversion frequencies, that outlying sample is removed and the composite result is re-calculated with the remaining values.</p>
<p>For self-capacitance sensors, the recommended style is multi-frequency if a low-value series impedance is used (&lt;50k-ohm), and standard if a high-value series impedance is used (&gt;50k-ohm). For the higher series impedance approach, a hardware low-pass filter is formed by the electrode/pin capacitance and the series impedance, attenuating noise. For the low-value series impedance approach, a multi-frequency conversion provides 4 data points from which a spread can be calculated and use as a noise level reference. That reference can then be used as an input to the dynamic threshold adjustment algorithm.</p>
<h4>Oversampling Style Control</h4>
<div class="fragment"><div class="line"><span class="comment">// Oversampling Style</span></div>
<div class="line">.selfModeOversamplingStyle = eNoOversampling,</div>
<div class="line">.projModeOversamplingStyle = eNoOversampling,</div>
</div><!-- fragment --><p>The oversampling style control allows for the addition of oversampling in binary steps to a conversion. Oversampling style is a data type that may be passed to the <b>CAPT_updateSensorRawCount()</b> function, which is what the EMC sensor update functions use to measure sensors.</p>
<table class="doxtable">
<tr>
<th align="left">Option</th><th align="left">tOversamplingStyle Enumeration  </th></tr>
<tr>
<td align="left">No Oversampling</td><td align="left">eNoOversampling </td></tr>
<tr>
<td align="left">Double</td><td align="left">e2xOversampling </td></tr>
<tr>
<td align="left">Quadruple</td><td align="left">e4xOversampling </td></tr>
<tr>
<td align="left">8x </td><td align="left">e8xOversampling </td></tr>
<tr>
<td align="left">16x </td><td align="left">e16xOversampling </td></tr>
<tr>
<td align="left">32x </td><td align="left">e32xOversampling </td></tr>
</table>
<p>When no oversampling is applied, each time cycle is sampled once and that value is used as the conversion result. When a level of oversampling is applied, each time cycle is sampled to the level of oversampling, and the results are averaged. This enables a basic averaging filter that helps with transient noise rejection.</p>
<p>Note that this oversampling is in addition to the multi-frequency scanning. For example, a mutual capacitance sensor with a multi-frequency conversion style and a 4x oversampling style is actually measured 16 times per update- 4 frequencies per sample, and a 4x oversample.</p>
<p>For designs that have a smaller number of buttons, more oversampling can be applied, which improves the overall SNR. Oversampling style is specified separately for self and mutual capacitance sensors.</p>
<h4>Jitter Filter Control</h4>
<div class="fragment"><div class="line"><span class="comment">// Jitter Filter Enable</span></div>
<div class="line">.bJitterFilterEnable = <span class="keyword">true</span>,</div>
</div><!-- fragment --><p>A basic 1-level jitter filter may be applied when sensors are updated with EMC features enabled. The jitter filter has a simple control (on or off). The filter looks at each new sample and determines if it is greater or less than the previous sample. If it is greater, the new sample is decremented by a value of 1. if it is less, the new sample is incremented by 1. This reduces low-level jitter in measurements, improving SNR. It is recommended that the jitter filter be enabled in most applications.</p>
<h4>Noise Level Thresholds and Calibration Noise Limits</h4>
<div class="fragment"><div class="line"><span class="comment">// Noise Thresholds and Calibration Noise Limits</span></div>
<div class="line">.ui8NoiseThreshold = 20,</div>
<div class="line">.ui16CalibrationNoiseLimit = 10,</div>
<div class="line">.ui8CalibrationTestSampleSize = 8,</div>
</div><!-- fragment --><p>These parameters primarily exist to enable alerting of the application to the fact that the amount of noise observed in the system is greater than a specified amount. In addition, they aid in calibration if noise is present during a calibration.</p>
<h5>Noise Threshold</h5>
<p>The <em>ui8NoiseThreshold</em> parameter specifies the relative noise level beyond which an element's noise detected status flag should be set. This provides a mechanism to alert the application that there is a certain amount of noise present in the measurement. The parameter is specified is a <em>relative</em> value, not an absolute value. The value is defined as a percentage of the long term average (LTA), in which 0=0% and 128=100%. The absolute noise threshold would be calculated as the relative threshold multiplied by the LTA and divided by 128, as shown below.</p>
<div class="image">
<img src="lib_advanced_rel_to_abs.png" alt="lib_advanced_rel_to_abs.png"/>
<div class="caption">
Relative/Absolute Noise Threshold Conversion</div></div>
  <p>Relative thresholds are used here so that they can be applied to an application that may have many sensors with different conversion count settings.</p>
<p>Note that this noise threshold only serves the purpose of setting the noise detected flag- it does not impact the processing of the library in any way.</p>
<h5>Calibration in Noisy Environments</h5>
<p>The <em>ui16CalibrationNoiseLimit</em> and <em>ui8CalibrationTestSampleSize</em> parameters are used to test the results of the calibration process when multi-frequency scanning is enabled. If the MCU powers up in an environment with noise at one of the conversion frequencies, it is possible that the calibration algorithm may produce invalid calibration values at that frequency. To determine if a calibration value may be corrupt, after the calibration process is complete each element is sampled <em>ui8CalibrationTestSampleSize</em> times. Out of that sample set, the peak-to-peak difference at each frequency in the set is compared with the <em>ui16CalibrationNoiseLimit</em>. If the peak-to-peak variation of the measurement results at a given conversion frequency is greater than the <em>ui16CalibrationNoiseLimit</em> parameter, that frequency's calibration values are marked as invalid. When this happens, they are replaced with the calibration values of the nearest valid conversion frequency.</p>
<p>There are 3 possible outcomes from the multi-frequency calibration test:</p><ol type="1">
<li>All 4 conversion frequencies provided data that was noise-free. Thus, they retain their original calibration values.</li>
<li>1 to 3 conversion frequencies provided data that was noisy. the noisy frequencies have their calibration values replaced with the values from the nearest conversion frequency with valid, noise-free data.</li>
<li>All 4 conversion frequencies provided data that was noisy. In this scenario, there is no way to determine if the calibration values are valid or not. To alert the application, the sensor's <em>bCalibrationError</em> status flag and <em>bSensorNoiseState</em> status flag are set. Applications should test these flags after the calibration process to determine if a usable calibration solution was obtained. If a valid calibration solution was not obtained, the application should stall and re-attempt the calibration process until a valid calibration is obtained.</li>
</ol>
<h4>Dynamic Threshold Adjustment Parameters</h4>
<div class="fragment"><div class="line"><span class="comment">// Dynamic Threshold Adjustment Parameters</span></div>
<div class="line">.bEnableDynamicThresholdAdjustment = <span class="keyword">true</span>,</div>
<div class="line">.ui8MaxRelThreshAdj = 76,</div>
<div class="line">.ui8NoiseLevelFilterEntryThresh = 40,</div>
<div class="line">.ui8NoiseLevelFilterExitThresh = 0,</div>
<div class="line">.ui8NoiseLevelFilterDown = 6,</div>
<div class="line">.ui8NoiseLevelFilterUp = 1,</div>
<div class="line">.coeffA = _IQ31(0.0065),</div>
<div class="line">.coeffB = _IQ31(0.050)</div>
</div><!-- fragment --><p>The dynamic threshold adjustment (DTA) parameters enable and configure the DTA algorithm. The parameters are introduced below: </p><table class="doxtable">
<tr>
<th align="left">Member</th><th align="left">Description</th><th align="left">Default Value</th><th align="left">Valid Values  </th></tr>
<tr>
<td align="left">bEnableDynamicThresholdAdjustment</td><td align="left">Enable or disable dynamic threshold adjustment. Note that dynamic threshold adjustment only applies to self capacitance sensors in either case.</td><td align="left">true</td><td align="left">true, false </td></tr>
<tr>
<td align="left">ui8NoiseLevelFilterEntryThresh</td><td align="left">If the noise level is increasing (low to high vector) and the new noise sample is below this value, the global and local value filters will be disabled to allow for rapid tracking. A value of '0' keeps the filters enabled at all times.</td><td align="left">32</td><td align="left">0-128 </td></tr>
<tr>
<td align="left">ui8NoiseLevelFilterExitThresh</td><td align="left">If the noise level is decreasing (high to low vector) and the new noise sample is below this value, the global and local value filters will be disabled to allow for rapid tracking. A value of '0' keeps the filters enabled at all times.</td><td align="left">0</td><td align="left">0-128 </td></tr>
<tr>
<td align="left">ui8NoiseLevelFilterDown </td><td align="left">The filter beta applied to the global filtered noise value when the new noise sample is lower than the filtered noise value.</td><td align="left">5</td><td align="left">0-15 </td></tr>
<tr>
<td align="left">ui8NoiseLevelFilterUp </td><td align="left">The filter beta applied to the global filtered noise value when the new noise sample is higher than the filtered noise value.</td><td align="left">1</td><td align="left">0-15 </td></tr>
<tr>
<td align="left">coeffA</td><td align="left">The 'A' coefficient in the dynamic threshold adjustment algorithm calculation.</td><td align="left">0.0065</td><td align="left">0-0.999999999 </td></tr>
<tr>
<td align="left">coeffB</td><td align="left">The 'B' coefficient in the dynamic threshold adjustment algorithm calculation.</td><td align="left">0.0100</td><td align="left">0-0.999999999 </td></tr>
</table>
<p>The <em>bEnableDynamicThresholdAdjustment</em> parameter enables and disables the DTA algorithm. The DTA algorithm only applies to self capacitance sensors. See the <a class="el" href="ch_lib.html#ch_lib_emc_algorithms_dta">DTA</a> section for an overview of how the DTA algorithm works.</p>
<h3><a class="anchor" id="ch_lib_emc_algorithms"></a>
EMC Module Algorithms</h3>
<h4><a class="anchor" id="ch_lib_emc_algorithms_mfp"></a>
Multi Frequency Processing (MFP) Algorithm</h4>
<p>The multi frequency processing algorithm is implemented in the <b>CAPT_resolveMultiFreqSet()</b> function. When noise immunity is enabled, each element is measured at four different conversion frequencies to gather more data in the presence of noise. The algorithm is then applied to the four raw measurements. The output of the algorithm is a single, composite measurement and a noise level. The composite measurement is then used by the higher levels of the library just like a raw sample normally would. The noise level is used to update each element's filtered noise level.</p>
<h4><a class="anchor" id="ch_lib_emc_algorithms_dta"></a>
Dynamic Threshold Adjustment (DTA) Algorithm</h4>
<p>The dynamic threshold adjustment (DTA) algorithm is implemented in the <b>CAPT_computeRelativeNoiseComp()</b> function. The algorithm calculates threshold adjustments based on the amount of noise seen in a history of measurements. It relies on a filtered relative noise value as an input, and it calculates the corresponding threshold adjustment to be applied for proximity and touch detection. The threshold adjustment is calculated based on a polynomial model as shown below, where 'x' is the relative noise value and 'y' is the corresponding relative threshold adjustment. The polynomial allows for greater adjustment at higher noise levels.</p>
<div class="image">
<img src="lib_dta_formula.png" alt="lib_dta_formula.png"/>
<div class="caption">
DTA Formula</div></div>
  <p>This formula with the default values provides the adjustment curve shown below. A linear (A=0; B=0.5) curve is also shown for reference.</p>
<div class="image">
<img src="lib_dta_formula_plot.png" alt="lib_dta_formula_plot.png"/>
<div class="caption">
DTA Default Value Response Curve</div></div>
  <hr/>
 <h1><a class="anchor" id="ch_lib_communications"></a>
Communications Module</h1>
<p>The CapTIvate&trade; Touch Library includes a communications module for connecting CapTIvate&trade; MCUs to the outside world. This section discusses the architecture, features, and specification for that communications module, as well as how it may be used in a variety of applications from development to production.</p>
<p>This section assumes that the reader is familiar with the following:</p><ul>
<li>Capacitive sensing as a user interface technology</li>
<li>The Captivate ecosystem and touch library</li>
<li>Basic MSP microcontroller architecture</li>
</ul>
<h2><a class="anchor" id="ch_lib_communications_background"></a>
Background</h2>
<p>Designing a capacitive touch interface is an iterative process. Every sensor in the system must be individually tuned and optimized to achieve the desired sensitivity and "feel." Having the ability to communicate in real-time between a PC GUI and the target MCU drastically reduces the amount of time needed to tune an interface, and can provide better tuning results as the features incorporated into the CapTIvate&trade; peripheral can quickly and easily be exercised to determine the best configuration.</p>
<p>Following the design and tuning phase, a capacitive touch microcontroller takes on one of two roles in a system. It may be a dedicated human-machine interface (HMI) that only serves to resolve a capacitive touch panel into usable information (like touch/no touch, or a slider position), or it may double as a host processor, integrating other functionality such as monitoring sensors or controlling other functions in the system. In the first case (the dedicated HMI case), the controller will almost always require a way to communicate the status of the interface to some other host, which may be another MCU or an MPU. This interface could be as simple as a GPIO that gets set when a button is pressed, or as complex as a full I2C protocol with addressable parameters.</p>
<h2><a class="anchor" id="ch_lib_communications_overview"></a>
Overview</h2>
<p>The CapTIvate&trade; Software Library communications module provides a single solution to the two needs above. The communications module is a layered set of firmware with a simple top-level API, designed to link a CapTIvate&trade; MCU to the CapTIvate&trade; Design Center PC GUI or to a host processor of some kind via a standard, common serial interface.</p>
<p>In a capacitive touch application the MCU is responsible for measuring capacitive sensors, processing the measurement to interpret some kind of result, and transmitting that result either to the application locally or to a host processor. The communications layer provides the "transmission" part of the equation. The diagram below portrays how the communications module fits in with the rest of the firmware in a typical CapTIvate&trade; application.</p>
<p>The CapTIvate&trade; communications module is layered and contains several standalone features that are interlinked together. These features are introduced below. To use the communications module, it is only necessary to set up the configuration file and call the top-level APIs.</p>
<p>The communications module contains 4 layers. In order of decreasing abstraction, they are:</p><ul>
<li><a class="el" href="ch_lib.html#ch_lib_communications_interface">Interface Layer</a> [COMM/CAPT_Interface.c/.h]<ul>
<li>The interface layer implements the top-level API.</li>
</ul>
</li>
<li><a class="el" href="ch_lib.html#ch_lib_communications_protocol">Protocol Layer</a> [COMM/CAPT_Protocol.c/.h]<ul>
<li>The protocol layer implements Captivate protocol packet generation and packet interpretation.</li>
</ul>
</li>
<li>Serial Driver Layer [COMM/Serial_Drivers/*.c/.h]<ul>
<li>The serial driver layer contains several interchangeable serial driver options.</li>
<li>One and only one option may be selected at any given time.</li>
<li>Selection and configuration is handled in the configuration file.</li>
<li>The serial drivers are built on top of the MSP430 DriverLib API.</li>
<li><a class="el" href="ch_lib.html#ch_lib_communications_uartdriver">UART</a> and <a class="el" href="ch_lib.html#ch_lib_communications_i2cslavedriver">I2C Slave</a> drivers are provided.</li>
</ul>
</li>
<li>Data Structure Layer [COMM/CAPT_ByteQueue.c/.h, COMM/CAPT_PingPongBuffer.c/.h]<ul>
<li>The data structure layer implements basic abstract data types, such as a FIFO queue and a ping pong buffer to aid serial communication.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="ch_lib_communications_interface"></a>
Interface Layer</h2>
<p>The CapTIvate&trade; interface layer is the top-level communication layer. It provides the top-level function calls that are used by the application, and serves to marry together the protocol layer (which handles packet generation and interpretation) with the serial driver (which actually moves the data in and out of the microcontroller). The functionality provided is covered in this section below. All application access to the communications module should be through the interface layer.</p>
<h3><a class="anchor" id="ch_lib_communications_interface_init"></a>
Using the Communications Module: Initializing the Interface</h3>
<p>The communications module must be initialized at startup by the application via a call to <b>CAPT_initCommInterface()</b>. This top-level init function handles opening the selected serial driver, as well as initializing any queues/buffers that are needed for communication.</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Init the Communications Module</td><td align="left">extern void CAPT_initCommInterface(tCaptivateApplication *pApp) </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_communications_interface_incomingdata"></a>
Using the Communications Module: Handling Incoming Data</h3>
<p>Incoming raw data from a host is buffered by the serial driver to be serviced when the application is available to do so. The application must periodically call <b>CAPT_checkForInboundPacket()</b> to check to see if any packets have been received from the host. This top-level function will check for packets in the receive queue of the serial driver, and if any packets are found, they will be processed according to their type. Typically, this function is called in a background loop when the application is available. Note that the serial drivers will exit active from sleep if a data is arriving from the host, which can be used as a mechanism to wake up the background loop to call this function.</p>
<p>The <b>CAPT_checkForRecalibrationRequest()</b> function should also be called periodically to see if any of the packets received and handled by <b>CAPT_checkForInboundPacket()</b> require the application to re-calibrate the user interface. An example of this would be if a packet was received that changed the conversion count, requiring a re-calibration of the sensors in the system.</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Check for an Inbound Packet, and Process It</td><td align="left">extern bool CAPT_checkForInboundPacket(void) </td></tr>
<tr>
<td align="left">Check for a Re-calibration Request</td><td align="left">extern bool CAPT_checkForRecalibrationRequest(void) </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_communications_interface_outgoingdata"></a>
Using the Communications Module: Writing Out Data</h3>
<p>The interface layer provides 3 top-level constructs for transmitting data to the host. The three functions below handle generation of the appropriate packet, management of the transmit ping/pong buffers, and transmission over the serial interface. If the serial peripheral is available (not busy) these calls are non-blocking, and the packets that are generated are transmitted to the host via interrupt service routines in the serial driver.</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Write Element Data</td><td align="left">extern bool CAPT_writeElementData(uint8_t ui8SensorID) </td></tr>
<tr>
<td align="left">Write Sensor Data</td><td align="left">extern bool CAPT_writeSensorData(uint8_t ui8SensorID) </td></tr>
<tr>
<td align="left">Write General Purpose Data</td><td align="left">extern bool CAPT_writeGeneralPurposeData(uint16_t *pData, uint8_t ui8Cnt) </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_communications_interface_compiletimeconfig"></a>
Compile-Time Configuration</h3>
<p>The compile-time configuration options are set in the CAPT_CommConfig.h file. The available compile-time options are described below.</p>
<h4>Interface Selection Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">CAPT_INTERFACE</td><td align="center">CAPT_UserConfig.h</td><td align="center">__CAPT_NO_INTERFACE__, <b>CAPT_UART_INTERFACE</b>, <b>CAPT_BULKI2C_INTERFACE</b>, <b>CAPT_REGISTERI2C_INTERFACE</b> </td></tr>
</table>
<p>CAPT_INTERFACE, unlike the remaining definitions, is located in the User Config file (CAPT_UserConfig.h). It selects the interface that the communications module should be built for. If the communication module should be excluded from the build, then <b>CAPT_NO_INTERFACE</b> should be set. Otherwise, the desired communication mode should be set.</p>
<p>NOTE: This value is automatically populated in the CAPT_UserConfig.h file by the Design Center during source code generation.</p>
<h4>Transmit Buffer Size Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">CAPT_TRANSMIT_BUFFER_SIZE</td><td align="center">CAPT_CommConfig.h</td><td align="center">Unsigned Integer </td></tr>
</table>
<p>CAPT_TRANSMIT_BUFFER_SIZE defines the size of the transmit buffer. Note that 2x this size will be allocated, since ping-pong buffering is used. This size should also be at least 2x the size of the largest packet, to allow for byte stuffing.</p>
<h4>Receive Queue Buffer Size Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">CAPT_QUEUE_BUFFER_SIZE</td><td align="center">CAPT_CommConfig.h</td><td align="center">Unsigned Integer </td></tr>
</table>
<p>CAPT_QUEUE_BUFFER_SIZE defines the size of the receive queue. This is the queue that the serial driver uses to buffer received data until the data is processed by a call to <b>CAPT_checkForInboundPacket()</b>. If it seems like packets are being dropped, a good first step is to increase the size of this buffer.</p>
<h4>I2C Slave Serial Driver Receive Buffer Size Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">CAPT_I2C_RECEIVE_BUFFER_SIZE</td><td align="center">CAPT_CommConfig.h</td><td align="center">Unsigned Integer </td></tr>
</table>
<p>CAPT_I2C_RECEIVE_BUFFER_SIZE defines the size of the receive buffer used by the I2C Slave driver, if that driver is selected. This buffer size should be at least as large as the maximum length I2C bus write transaction that is expected.</p>
<h4>I2C Slave Serial Driver Buffer Size in Register Mode Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">CAPT_I2C_REGISTER_RW_BUFFER_SIZE</td><td align="center">CAPT_CommConfig.h</td><td align="center">Unsigned Integer </td></tr>
</table>
<p>CAPT_I2C_REGISTER_RW_BUFFER_SIZE defines the size of the buffer used by the I2C Slave driver when the communication interface is configured in register I2C mode. This buffer size should be at least as large as the maximum length I2C bus transaction that is expected.</p>
<h2><a class="anchor" id="ch_lib_communications_protocol"></a>
Protocol Layer</h2>
<p>The CapTIvate&trade; protocol is a communications specification for sending capacitive touch specific data. It enables MSP430 Captivate-equipped microcontrollers to communicate with design, debug, and tuning tools on host PCs. In addition to this function, it can also provide a mechanism for interfacing a Captivate MCU to another host MCU or SoC in the context of a larger system. This guide discusses the details of the protocol itself: packet types and packet structure.</p>
<p>The Captivate protocol is a packet-based serial messaging protocol. It includes provisions for passing real-time capacitive measurement data from a Captivate target MCU to another processor, as well as provisions for tuning parameter read and write.</p>
<h3>Use Cases</h3>
<p>The various use cases for the protocol are described below.</p>
<ol type="1">
<li>Capacitive Touch Development and Tuning Capacitive touch development and tuning involves looking at real-time data from a touch panel and adjusting software parameters to achieve the desired response and feel from the sensors on that panel. For example: tuning a capacitive button involves looking at the raw data coming back from the microcontroller about that button, and adjusting thresholds, de-bounce, and filters accordingly to create a robust user interface. Having the ability to adjust all of these software parameters in real-time while looking at sensor data, without re-compiling code, is extremely powerful and reduces development time. The Captivate protocol was designed with the Captivate Design Center specifically to meet this need.</li>
<li>Interface to Host Processor Most capacitive touch user interfaces involve a dedicated microcontroller driving the touch panel, which communicates up to a host processor of some kind. The flexibility of the Captivate protocol allows for it to be re-used as an interface to a host processor; it can stream touch status, proximity status, and slider/wheel position up to a host.</li>
<li>In-Field / In-System Debug Interface and Tuning Since the Captivate protocol supports reading and writing of capacitive touch tuning parameters, as well as the streaming of real-time data, it could potentially be utilized as a diagnostic tool in the field when coupled with the Captivate Design Center PC tool.</li>
</ol>
<h3><a class="anchor" id="ch_lib_communications_protocol_packettypes"></a>
Introduction to Packet Types</h3>
<p>The Captivate protocol supports five packet types: sensor packets, cycle packets, parameter packets, general purpose packets, and trackpad packets. In a capacitive touch system, there are two endpoints in the communication link: the target MCU itself, and the host. The host might be a PC tool or some kind of embedded processor. Sensor packets, cycle packets, general purpose packets, and trackpad packets carry information about the current state of the touch panel being driven by the target MCU. These packets are UNIDIRECTIONAL, and only travel from the target to the host. Parameter packets are BIDIRECTIONAL, and may travel from the target to the host or from the host to the target.</p>
<div class="image">
<img src="lib_comm_protocol_packet_direction.png" alt="lib_comm_protocol_packet_direction.png"/>
<div class="caption">
Packet Directionality</div></div>
  <h4>Sensor Packets</h4>
<p><a class="el" href="ch_lib.html#ch_lib_communications_protocol_sensorpacket">Sensor packets</a> are unidirectional packets from the Captivate MCU to the host. They provide information about the current state of a sensor. Sensor state information includes things like dominant button, slider or wheel position, sensor global proximity state, and sensor global touch/previous touch state.</p>
<h4>Cycle Packets</h4>
<p><a class="el" href="ch_lib.html#ch_lib_communications_protocol_cyclepacket">Cycle packets</a> are unidirectional packets from the Captivate MCU to the host. They provide low level element information, such as element touch status, element proximity status, element count, and element long term average for all of the elements within a cycle. These packets are typically used in the tuning phase, where it is desirable to have real-time views of count and long term average for setting thresholds and tuning filters.</p>
<h4>Trackpad Packets</h4>
<p><a class="el" href="ch_lib.html#ch_lib_communications_protocol_trackpadpacket">Trackpad packets</a> are unidirectional packets from trackpad MCUs to the host. They provide the X and Y coordinates of touches on the trackpad.</p>
<h4>General Purpose Packets</h4>
<p><a class="el" href="ch_lib.html#ch_lib_communications_protocol_gppacket">General purpose packets</a> are unidirectional packets from a Captivate MCU to the host. They serve as a generic container to send any information that can be formatted as a 16-bit unsigned integer. This channel can serve as a debug tool for sending any kind of information that doesn't fit into any of the other packet types. Up to 29 integers (58 bytes) may be sent in a single packet.</p>
<h4>Parameter Packets</h4>
<p><a class="el" href="ch_lib.html#ch_lib_communications_protocol_parameterpacket">Parameter packets</a> are bi-directional packets between a host and the Captivate MCU. <a class="el" href="ch_lib.html#ch_lib_communications_protocol_parameterpacket">Parameter packets</a> allow for the host to adjust a tuning parameter on the target at runtime. For example, the touch threshold for an element or the resolution of a slider could be adjusted by sending the appropriate parameter command. Parameters can be read or written. Parameter reads and writes from a host to a target MCU always result in a read-back of the most current value (the value after the write, in the case of a write).</p>
<h3>Transmission Rules</h3>
<p>The packet types discussed above are transmitted via a serial interface of some kind between the target and the host. Full-duplex UART is the typical interface. To provide reliable and accurate packet transmission, a set of transmission rules is applied to all packets when being transmitted. These rules are discussed in the <a class="el" href="ch_evm.html#ch_evm_hidbridge_modesofoperation_packet">HID Bridge Packet Mode</a> section.</p>
<p>The following functions aid in applying transmission rules:</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Stuff Sync Bytes in a Packet</td><td align="left">extern uint16_t CAPT_stuffSyncBytes(uint8_t *pBuffer, uint16_t ui16Length) </td></tr>
<tr>
<td align="left">Verify a Checksum</td><td align="left">extern bool CAPT_verifyChecksum(const uint8_t *pBuffer, const uint16_t ui16Length, const uint16_t ui16Checksum) </td></tr>
<tr>
<td align="left">Get a Checksum</td><td align="left">extern uint16_t CAPT_getChecksum(const uint8_t *pBuffer, const uint16_t ui16Length) </td></tr>
<tr>
<td align="left">Identify and Frame a Packet in a Receive Data Queue</td><td align="left">extern bool CAPT_processReceivedData(tByteQueue *pReceiveQueue, tParameterPacket *pPacket, tTLProtocolProcessingVariables *pVariables) </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_communications_protocol_sensorpacket"></a>
Format: Sensor Packets</h3>
<p>Sensor packets have a fixed length of 6 bytes. There are two control bytes and four data payload bytes.</p>
<div class="image">
<img src="lib_comm_protocol_sensorpacket.png" alt="lib_comm_protocol_sensorpacket.png"/>
<div class="caption">
Sensor Packet Format</div></div>
  <ol type="1">
<li><b>Command Byte [0]</b> The command byte for a sensor packet is always 00h.</li>
<li><b>Sensor ID Byte [1]</b> The sensor ID byte contains an unsigned 8-bit integer that specifies the ID of the sensor whose data is being transmitted. Sensor ID on the target side is typically established by the order of sensor pointers in the global sensor pointer array. Sensors are sorted alphabetically by the Captivate Design Center PC GUI.</li>
<li><b>Data Payload Bytes [2-5]</b> The data payload bytes contain the sensor data that is being sent. The information contained in the payload is dependent upon the sensor type. The table below describes the payload on a sensor type basis.</li>
</ol>
<table class="doxtable">
<tr>
<th align="left">Sensor Type</th><th align="left">Byte 0</th><th align="left">Byte 1</th><th align="left">Byte 2</th><th align="left">Byte 3  </th></tr>
<tr>
<td align="left">Button Group</td><td align="left">Dominant Element (256 elements max)</td><td align="left">Previous Dominant Element (256 elements max)</td><td align="left">Reserved</td><td align="left">Sensor Status </td></tr>
<tr>
<td align="left">Slider</td><td align="left">Slider Position (Lower 8 bits of 16 bits)</td><td align="left">Slider Position (Upper 8 bits of 16 bits)</td><td align="left">Reserved</td><td align="left">Sensor Status </td></tr>
<tr>
<td align="left">Wheel</td><td align="left">Wheel Position (Lower 8 bits of 16 bits)</td><td align="left">Wheel Position (Upper 8 bits of 16 bits)</td><td align="left">Reserved</td><td align="left">Sensor Status </td></tr>
<tr>
<td align="left">Proximity</td><td align="left">Reserved</td><td align="left">Reserved</td><td align="left">Reserved</td><td align="left">Sensor Status </td></tr>
<tr>
<td align="left">Trackpad</td><td align="left">Reserved</td><td align="left">Reserved</td><td align="left">Reserved</td><td align="left">Sensor Status </td></tr>
</table>
<p>The sensor status byte, included in button group, slider, and wheel sensor packets, provides additional data about the state of the sensor that is often meaningful. The status flags are all boolean flags, and are assigned to bit positions as follows:</p>
<table class="doxtable">
<tr>
<th align="left">Bit Mask (Position)</th><th align="left">Sensor Status Flag  </th></tr>
<tr>
<td align="left">Bit 0 (01h)</td><td align="left">Global Sensor Touch Flag </td></tr>
<tr>
<td align="left">Bit 1 (02h)</td><td align="left">Global Sensor Previous Touch Flag </td></tr>
<tr>
<td align="left">Bit 2 (04h)</td><td align="left">Global Sensor Proximity Flag </td></tr>
<tr>
<td align="left">Bit 3 (08h)</td><td align="left">Global Sensor Detect Flag (Prox Detect Pre-Debounce) </td></tr>
<tr>
<td align="left">Bit 4 (10h)</td><td align="left">Global Sensor Negative Touch Flag (Reverse Touch) </td></tr>
<tr>
<td align="left">Bit 5 (20h)</td><td align="left">Global Sensor Noise State </td></tr>
<tr>
<td align="left">Bit 6 (40h)</td><td align="left">Global Sensor Max Count Error Flag </td></tr>
<tr>
<td align="left">Bit 7 (80h)</td><td align="left">Global Sensor Calibration Error Flag </td></tr>
</table>
<p><b>NOTE:</b> For slider / wheel sensors, the 16 position bits in the data payload will contain the valid slider or wheel position when the global sensor touch flag is true on that sensor. If there is not a global touch detection, the 16 position bits will all be set high (0xFFFF for the slider/wheel position value).</p>
<p><b>NOTE:</b> Reserved fields are still transmitted, but do not contain any meaningful data. Do not use or rely on any data transmitted in a reserved field.</p>
<p>Sensor packets are generated via a call into the protocol layer. The <b>CAPT_getSensorPacket</b>() function looks up the sensor at index ui8SensorID in the array sensorArray, and stores the generated packet in the buffer space pointed to by pBuffer. The length of the packet is returned by the function.</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Get a Sensor Packet</td><td align="left">extern uint16_t CAPT_getSensorPacket(tSensor **sensorArray, uint8_t ui8SensorID, uint8_t *pBuffer) </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_communications_protocol_cyclepacket"></a>
Format: Cycle Packets</h3>
<p>Cycle packets have a variable length which is dependent upon the number of elements within the cycle. There are always 3 control bytes and 3 state bytes. In addition to those 6 bytes, there are 4 bytes per element in the cycle.</p>
<div class="image">
<img src="lib_comm_protocol_cyclepacket.png" alt="lib_comm_protocol_cyclepacket.png"/>
<div class="caption">
Cycle Packet Format</div></div>
  <ol type="1">
<li><b>Command Byte [0]</b> The command byte for a cycle packet is always 01h.</li>
<li><b>Sensor ID Byte [1]</b> The sensor ID byte contains an unsigned 8-bit integer that specifies the ID of the sensor whose data is being transmitted. Sensor ID on the target side is typically established by the order of sensor pointers in the global sensor pointer array. Sensors are sorted alphabetically by the Captivate Design Center PC GUI.</li>
<li><b>Cycle ID Byte [2]</b> The cycle ID byte contains an unsigned 8-bit integer that specifies the ID of the cycle whose data is being transmitted, relative to the sensor. For example, in a sensor with 3 cycles, the first cycle would have an ID of 0, the second, an ID of 1, and the third, an ID of 2. The cycle ID should correspond to the index of the cycle in the sensor's cycle pointer array.</li>
<li><b>Cycle State Bytes [3-5]</b> The cycle state bytes specify the touch and proximity detection flags for each element in the cycle. Up to 12 elements per cycle are supported. Bytes 3 through 5 of the cycle packet comprise a 24 bit cycle state section, where the lower 12 bits represent the proximity state for each element in a bitwise fashion, and the upper 12 bits represent the touch state for each element in a bitwise fashion.</li>
<li><b>Element LTA and Element Count Bytes [6-n], n=5+4(number of elements)</b> The remainder of the cycle packet is comprised of element LTA and count values. LTA and count are represented as 16 bit unsigned integers. As such, 32 bits are required for each element in the LTA/Count section. The packet shall increase in size in 32 bit (4 byte) increments for every additional element in the cycle, up to a maximum of 12 elements. The LTA is sent first, and the count second. Per the protocol, when sending values greater than one byte, the transmission sequence is lowest order byte to highest order byte.</li>
</ol>
<p>Cycle packets are generated via a call into the protocol layer. The <b>CAPT_getCyclePacket</b>() function looks up the cycle at index ui8Cycle in the sensor at index ui8SensorID in the array sensorArray, and stores the generated packet in the buffer space pointed to by pBuffer. The length of the packet is returned by the function.</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Get a Cycle Packet</td><td align="left">extern uint16_t CAPT_getCyclePacket(tSensor **sensorArray, uint8_t ui8SensorID, uint8_t ui8Cycle, uint8_t *pBuffer); </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_communications_protocol_trackpadpacket"></a>
Format: Trackpad Packets</h3>
<p>Trackpad packets have a variable length which is dependent upon the maximum number of simultaneous touches supported by the trackpad device. There are 3 control bytes. Following the control bytes, there is a trackpad gesture byte for indicating the detection of a gesture and what the gesture was. For each simultaneous touch the trackpad device supports, 4 additional payload bytes are added to the packet. The packet format can be seen below.</p>
<div class="image">
<img src="lib_comm_protocol_trackpadpacket.png" alt="lib_comm_protocol_trackpadpacket.png"/>
<div class="caption">
Trackpad Packet Format</div></div>
  <ol type="1">
<li><b>Command Byte [0]</b> The command byte for trackpad packets is always 02h.</li>
<li><b>Sensor ID Byte [1]</b> The sensor ID byte contains an unsigned 8-bit integer that specifies the ID of the sensor whose data is being transmitted. Sensor ID on the target side is typically established by the order of sensor pointers in the global sensor pointer array. Sensors are sorted alphabetically by the Captivate Design Center PC GUI.</li>
<li><b>Max Touches [2]</b> The max touches byte contains an unsigned 8-bit integer that specifies the number of simultaneous touches supported by the trackpad device. This also provides insight into the length of the remainder of the packet. Following the max touches byte, there will be 4 bytes for each simultaneous touch supported by the trackpad device. Trackpad devices must support at least one touch.</li>
<li><b>Gesture Status [3]</b> The trackpad gesture byte indicates whether a gesture was just detected, and what that gesture was. The value/gesture pairs are listed below. If no gesture was detected, the gesture byte will be set to FFh.</li>
</ol>
<table class="doxtable">
<tr>
<th align="left">**Value**</th><th align="left">Gesture  </th></tr>
<tr>
<td align="left">00h</td><td align="left">Wake on Proximity Detection </td></tr>
<tr>
<td align="left">01h</td><td align="left">Reserved </td></tr>
<tr>
<td align="left">02h</td><td align="left">Single Touch Single Tap </td></tr>
<tr>
<td align="left">03h</td><td align="left">Single Touch Double Tap </td></tr>
<tr>
<td align="left">04h</td><td align="left">Two Touch Single Tap </td></tr>
<tr>
<td align="left">05h</td><td align="left">Two Touch Double Tap </td></tr>
<tr>
<td align="left">06h</td><td align="left">Tap and Hold </td></tr>
<tr>
<td align="left">07h</td><td align="left">Two Touch Tap and Hold </td></tr>
<tr>
<td align="left">08h</td><td align="left">Swipe Left </td></tr>
<tr>
<td align="left">09h</td><td align="left">Swipe Right </td></tr>
<tr>
<td align="left">0Ah</td><td align="left">Swipe Up </td></tr>
<tr>
<td align="left">0Bh</td><td align="left">Swipe Down </td></tr>
<tr>
<td align="left">0Ch-FEh</td><td align="left">Reserved </td></tr>
<tr>
<td align="left">FFh</td><td align="left">No Gesture Detected </td></tr>
</table>
<ol type="1">
<li><b>Touch Coordinates [4-n], n=4+4(Max Touches)</b> The touch coordinates indicate the presence of and location of a touch on the trackpad. Touch locations are communicated via two 16-bit unsigned integers per touch: one for the coordinate on the X axis, and one for the coordinate on the Y axis. 16 bits is the maximum resolution in either the X or Y direction for the trackpad. Most applications will have a working resolution that is less than 16 bits per coordinate, but 16 bits are always sent regardless. If no touch is present, both the X and the Y coordinates will read as FFFFh.</li>
</ol>
<p><b>NOTE:</b> Trackpad packets only pertain to dedicated trackpad devices.</p>
<h3><a class="anchor" id="ch_lib_communications_protocol_gppacket"></a>
Format: General Purpose Packets</h3>
<p>General purpose packets are unique in that they simply serve as a data streaming mechanism for any data an application wishes to send. Data is sent as an array of 16-bit unsigned integers. General purpose packets have variable length that is dependent upon the number of integers being sent. There are always 2 control bytes. Following the control bytes is the data payload (up to 29 entries), with 2 bytes (16 bits) per entry.</p>
<div class="image">
<img src="lib_comm_protocol_gppacket.png" alt="lib_comm_protocol_gppacket.png"/>
<div class="caption">
General Purpose Packet Format</div></div>
  <ol type="1">
<li><b>Command Byte [0]</b> The command byte for general purpose packets is always 10h.</li>
<li><b>Valid Data Count Byte [1]</b> The valid data count byte indicates how many valid data entries exist in the packet. This also implies the length of the packet: each valid entry implies two bytes of payload (each entry is a 16-bit unsigned integer). Valid values for this field are 1-29.</li>
<li><b>Data Payload [2-n]</b> The data payload section contains the generic data to be transmitted, formatted as unsigned 16-bit integers. Up to 29 payload items (58 bytes) are allowed.</li>
</ol>
<p>General purpose packets are generated via a call into the protocol layer. The <b>CAPT_getGeneralPurposePacket</b>() function generates a packet for the data array of length ui8Cnt pointed to by pData, and stores the generated packet in the buffer space pointed to by pBuffer.</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Get a General Purpose Packet</td><td align="left">extern uint16_t CAPT_getGeneralPurposePacket(uint16_t *pData, uint8_t ui8Cnt, uint8_t *pBuffer) </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_communications_protocol_parameterpacket"></a>
Format: Parameter Packets</h3>
<p>Parameter packets have a fixed length of 7 bytes. There are 3 control bytes and 4 data payload bytes. The packet format can be seen below.</p>
<div class="image">
<img src="lib_comm_protocol_parameterpacket.png" alt="lib_comm_protocol_parameterpacket.png"/>
<div class="caption">
Parameter Packet Format</div></div>
  <ol type="1">
<li><b>Command Byte [0]</b> The command byte for parameter packets is variable, and indicates the ID of the parameter that is to be read or written to.</li>
<li><b>Read/Write Byte [1]</b> The read/write byte is a 1-bit Boolean value that indicates whether the operation is a parameter read or a parameter write. 1 = write, 0 = read.</li>
<li><b>Sensor ID Byte [2]</b> The sensor ID byte contains an unsigned 8-bit integer that specifies the ID of the sensor whose parameter is being read from or written to. Sensor ID on the target side is typically established by the order of sensor pointers in the global sensor pointer array. Sensors are sorted alphabetically by the Captivate Design Center PC tool. Note that parameters for controller commands (C-h commands) may not use the Sensor ID field.</li>
<li><b>Data Bytes [3-6]</b> The data bytes contain the information that is to be read or written to. In some cases, 1 or more of the data bytes are used for further ID (such as cycle ID or element ID).</li>
</ol>
<p>The protocol layer provides several functions for framing and interpreting parameter packets. Placing a call into <b>CAPT_processReceivedData()</b> causes the protocol layer to search for potential packets in a datastream that has been queued up by a serial driver. Once a valid packed has been framed, the parameter may be accessed and updated/read via calls to <b>CAPT_accessSensorParameter()</b> and <b>CAPT_accessSpecialSensorParameter()</b>.</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Access a Sensor Parameter</td><td align="left">extern tTLParameterAccessResult CAPT_accessSensorParameter(tSensor **sensorArray, tParameterPacket *pPacket) </td></tr>
<tr>
<td align="left">Access a Special Sensor Parameter</td><td align="left">extern tTLParameterAccessResult CAPT_accessSpecialSensorParameter(tSensor **sensorArray, tParameterPacket *pPacket) </td></tr>
<tr>
<td align="left">Identify and Frame a Packet in a Receive Data Queue</td><td align="left">extern bool CAPT_processReceivedData(tByteQueue *pReceiveQueue, tParameterPacket *pPacket, tTLProtocolProcessingVariables *pVariables) </td></tr>
<tr>
<td align="left">Verify a Checksum</td><td align="left">extern bool CAPT_verifyChecksum(const uint8_t *pBuffer, const uint16_t ui16Length, const uint16_t ui16Checksum) </td></tr>
</table>
<p>The available parameters that can be adjusted through the use of parameter packets are listed below.</p>
<h4>Sensor Parameters</h4>
<table class="doxtable">
<tr>
<th align="left">Parameter Name</th><th align="center">Byte 0: CMD</th><th align="center">Byte 1: RW</th><th align="center">Byte 2: ID</th><th align="center">Byte 3</th><th align="center">Byte 4</th><th align="center">Byte 5</th><th align="center">Byte 6</th><th align="left">MCU Task</th><th align="left">SW Containing Structure</th><th align="left">SW Containing Variable  </th></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_conversion_gain">Conversion Gain</a></td><td align="center">80</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">ATI Base Lower Byte</td><td align="center">ATI Base Upper Byte</td><td align="left">Re-Cal</td><td align="left">tSensor</td><td align="left">ui16ConversionGain </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_conversion_count">Conversion Count</a></td><td align="center">81</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">ATI Target Lower Byte</td><td align="center">ATI Target Upper Byte</td><td align="left">Re-Cal</td><td align="left">tSensor</td><td align="left">ui16ConversionCount </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_prox_threshold">Prox Threshold</a></td><td align="center">82</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Prox Threshold Lower Byte</td><td align="center">Prox Threshold Upper Byte</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">ui16ProxThreshold </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_debounce">Prox Debounce-In Threshold</a></td><td align="center">84</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Prox Db In</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">ProxDbThreshold .DbUp </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_debounce">Prox Debounce-Out Threshold</a></td><td align="center">85</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Prox Db Out</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">ProxDbThreshold .DbDown </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_debounce">Touch Debounce-In Threshold</a></td><td align="center">86</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Touch Db In</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">TouchDbThreshold .DbUp </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_debounce">Touch Debounce-Out Threshold</a></td><td align="center">87</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Touch Db Out</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">TouchDbThreshold .DbDown </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_sensor_timeout_threshold">Sensor Timeout Threshold</a></td><td align="center">88</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Sensor Timeout Lower Byte</td><td align="center">Sensor Timeout Upper Byte</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">ui16TimeoutThreshold </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_count_filter">Count Filter Enable</a></td><td align="center">89</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Count Filter Enable bit</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">bCountFilterSelect </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_count_filter">Count Filter Beta</a></td><td align="center">8A</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Count Filter Beta</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">ui8CntBeta </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_lta_filter">LTA Filter Beta</a></td><td align="center">8B</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">LTA Filter Beta</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">ui8LTABeta </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_lta_filter">Halt LTA Filter Immediately</a></td><td align="center">8C</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">LTA Filter Halt</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">bSensorHalt </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_runtime_reCalibration">Runtime Re-Calibration Enable</a></td><td align="center">8D</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Runtime Re-Cal Enable</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">bReCalibrateEnable </td></tr>
<tr>
<td align="left">Force Re-Calibrate</td><td align="center">8E</td><td align="center">N/A</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="left">Re-Cal</td><td align="left">tSensor</td><td align="left">N/A </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_bias_current">Bias Current</a></td><td align="center">8F</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Bias Current</td><td align="center">Don't Care</td><td align="left">Re-Cal</td><td align="left">tSensor</td><td align="left">ui8BiasControl </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_sample_capacitor_discharge">Sample Capacitor Discharge</a></td><td align="center">95</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Cs Discharge</td><td align="center">Don't Care</td><td align="left">Re-Cal</td><td align="left">tSensor</td><td align="left">bCsDischarge </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_modulation_enable">Modulation Enable</a></td><td align="center">96</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Mod Enable</td><td align="center">Don't Care</td><td align="left">Re-Cal</td><td align="left">tSensor</td><td align="left">bModEnable </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_frequency_divider">Frequency Divider</a></td><td align="center">97</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Freq Div</td><td align="center">Don't Care</td><td align="left">Re-Cal</td><td align="left">tSensor</td><td align="left">ui8FreqDiv </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_phase_lengths">Charge/Hold Phase Length</a></td><td align="center">98</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Charge Length</td><td align="center">Don't Care</td><td align="left">Re-Cal</td><td align="left">tSensor</td><td align="left">ui8ChargeLength </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_phase_lengths">Transfer/Sample Phase Length</a></td><td align="center">99</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Transfer Length</td><td align="center">Don't Care</td><td align="left">Re-Cal</td><td align="left">tSensor</td><td align="left">ui8TransferLength </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_error_threshold">Error Threshold</a></td><td align="center">9A</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Error Threshold Lower Byte</td><td align="center">Error Threshold Upper Byte</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">ui16ErrorThreshold </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_negative_touch_threshold">Negative Touch Threshold</a></td><td align="center">9B</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Negative Touch Threshold Lower Byte</td><td align="center">Negative Touch Threshold Upper Byte</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">ui16NegativeTouchThreshold </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_idle_state">Idle State</a></td><td align="center">9C</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Idle State</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">bIdleState </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_sync_parameters">Input Sync</a></td><td align="center">9D</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Input Sync</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">ui8InputSyncControl </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_sync_parameters">Timer Sync</a></td><td align="center">9E</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Timer Sync</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">bTimerSyncControl </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_auto_power_down">Automatic Power-Down Enable</a></td><td align="center">9F</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Power Down Control</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">bLpmControl </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_lta_filter">Halt LTA on Sensor Prox or Touch</a></td><td align="center">A0</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Sensor Prox/Touch Halt</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">bPTSensorHalt </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_lta_filter">Halt LTA on Element Prox or Touch</a></td><td align="center">A1</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Element Prox/Touch Halt</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSensor</td><td align="left">bPTElementHalt </td></tr>
</table>
<h4>Element Parameters</h4>
<table class="doxtable">
<tr>
<th align="left">Parameter Name</th><th align="center">Byte 0: CMD</th><th align="center">Byte 1: RW</th><th align="center">Byte 2: ID</th><th align="center">Byte 3</th><th align="center">Byte 4</th><th align="center">Byte 5</th><th align="center">Byte 6</th><th align="left">MCU Task</th><th align="left">SW Containing Structure</th><th align="left">SW Containing Variable  </th></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_touch_threshold">Touch Threshold</a></td><td align="center">83</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Cycle # (relative to sensor)</td><td align="center">Lower 4 Bits: Element # (relative to cycle)</td><td align="center">Touch Threshold</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tElement</td><td align="left">ui8TouchThreshold [Element #] </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_engineering_parameters">Coarse Gain Ratio</a></td><td align="center">A2</td><td align="center">R</td><td align="center">Sensor ID</td><td align="center">Cycle # (relative to sensor)</td><td align="center">[UPPER 4 Bits: Frequency #] [ LOWER 4 Bits: Element # relative to cycle] </td><td align="center">Coarse Gain</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tCaptivateElementTuning</td><td align="left">ui8GainRatioCoarse </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_engineering_parameters">Fine Gain Ratio</a></td><td align="center">A3</td><td align="center">R</td><td align="center">Sensor ID</td><td align="center">Cycle # (relative to sensor)</td><td align="center">[UPPER 4 Bits: Frequency #] [ LOWER 4 Bits: Element # relative to cycle] </td><td align="center">Fine Gain</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tCaptivateElementTuning</td><td align="left">ui8GainRatioFine </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_engineering_parameters">Parasitic Offset Scale</a></td><td align="center">D0</td><td align="center">R</td><td align="center">Sensor ID</td><td align="center">Cycle # (relative to sensor)</td><td align="center">[UPPER 4 Bits: Frequency #] [ LOWER 4 Bits: Element # relative to cycle] </td><td align="center">Offset Scale (2 bit selection)</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tCaptivateElementTuning</td><td align="left">ui16OffsetTap Upper Byte </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_engineering_parameters">Parasitic Offset Level</a></td><td align="center">D1</td><td align="center">R</td><td align="center">Sensor ID</td><td align="center">Cycle # (relative to sensor)</td><td align="center">[UPPER 4 Bits: Frequency #] [ LOWER 4 Bits: Element # relative to cycle] </td><td align="center">Offset Level (8 bit selection)</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tCaptivateElementTuning</td><td align="left">ui16OffsetTap Lower Byte </td></tr>
</table>
<h4>Slider/Wheel Parameters</h4>
<table class="doxtable">
<tr>
<th align="left">Parameter Name</th><th align="center">Byte 0: CMD</th><th align="center">Byte 1: RW</th><th align="center">Byte 2: ID</th><th align="center">Byte 3</th><th align="center">Byte 4</th><th align="center">Byte 5</th><th align="center">Byte 6</th><th align="left">MCU Task</th><th align="left">SW Containing Structure</th><th align="left">SW Containing Variable  </th></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossaray_position_filter">Slider/Wheel Position Filter Enable</a></td><td align="center">90</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Slider Filter Enable bit</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSliderSensorParams</td><td align="left">SliderFilterEnable </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossaray_position_filter">Slider/Wheel Position Filter Beta</a></td><td align="center">91</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Slider Filter Beta</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tSliderSensorParams</td><td align="left">SliderBeta </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_desired_resolution">Desired Slider/Wheel Resolution</a></td><td align="center">92</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Slider Resolution Lower Byte</td><td align="center">Slider Resolution Upper Byte</td><td align="left">NA</td><td align="left">tSliderSensorParams</td><td align="left">ui16Resolution </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_slider_trim">Slider Lower Trim</a></td><td align="center">93</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Slider Lower Trim Lower Byte</td><td align="center">Slider Lower Trim Upper Byte</td><td align="left">NA</td><td align="left">tSliderSensorParams</td><td align="left">SliderLower </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_slider_trim">Slider Upper Trim</a></td><td align="center">94</td><td align="center">RW</td><td align="center">Sensor ID</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Slider Upper Trim Lower Byte</td><td align="center">Slider Upper Trim Upper Byte</td><td align="left">NA</td><td align="left">tSliderSensorParams</td><td align="left">SliderUpper </td></tr>
</table>
<h4>Controller/Management Parameters</h4>
<table class="doxtable">
<tr>
<th align="left">Parameter Name</th><th align="center">Byte 0: CMD</th><th align="center">Byte 1: RW</th><th align="center">Byte 2: ID</th><th align="center">Byte 3</th><th align="center">Byte 4</th><th align="center">Byte 5</th><th align="center">Byte 6</th><th align="left">MCU Task</th><th align="left">SW Containing Structure</th><th align="left">SW Containing Variable  </th></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_communications">Element Data Transmit Enable</a></td><td align="center">C0</td><td align="center">RW</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Element Transmit Enable</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tCaptivateApplication</td><td align="left">bElementDataTxEnable </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_communications">Sensor Data Transmit Enable</a></td><td align="center">C1</td><td align="center">RW</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Sensor Transmit Enable</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tCaptivateApplication</td><td align="left">bSensorDataTxEnable </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_system_report_rate">Active Mode Scan Rate (ms)</a></td><td align="center">C2</td><td align="center">RW</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Active Report Period (ms) Lower Byte</td><td align="center">Active Report Period (ms) Upper Byte </td><td align="left">NA</td><td align="left">tCaptivateApplication</td><td align="left">ui16ActiveModeScanPeriod </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_system_wakeonprox_mode">Wake-on-Prox Mode Scan Rate (ms)</a></td><td align="center">C3</td><td align="center">RW</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">WoP Report Period (ms) Lower Byte</td><td align="center">WoP Report Period (ms) Upper Byte </td><td align="left">NA</td><td align="left">tCaptivateApplication</td><td align="left">ui16WakeOnProxModeScanPeriod </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_system_wakeonprox_mode">Wakeup Interval</a></td><td align="center">C4</td><td align="center">RW</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Wakeup Interval</td><td align="center">Don't Care</td><td align="left">NA</td><td align="left">tCaptivateApplication</td><td align="left">ui8WakeupInterval </td></tr>
<tr>
<td align="left"><a class="el" href="ch_Glossary.html#ch_glossary_system_wakeonprox_mode">Inactivity Timeout</a></td><td align="center">C5</td><td align="center">RW</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Don't Care</td><td align="center">Timeout Lower Byte</td><td align="center">Timeout Upper Byte</td><td align="left">NA</td><td align="left">tCaptivateApplication</td><td align="left">ui16InactivityTimeout </td></tr>
</table>
<h2><a class="anchor" id="ch_lib_communications_uartdriver"></a>
UART Driver</h2>
<p>The MSP430 eUSCI_A UART Driver provides a simple UART API to MSP430 applications, enabling interrupt-driven transmit and receive operations as well as error handling. This section provides an overview of the driver's features, architecture, and API. This document assumes that the reader is familiar with the MSP430 MCU architecture, as well as embedded C programming concepts.</p>
<h3>Related Documents</h3>
<p>This document should be used with the following additional supporting documentation. The MSP430 Driver Library API is not specific to this driver, and has its own documentation.</p><ul>
<li>MSP430 Driver Library (DriverLib) User's Guide</li>
<li>The relevant MSP430 Family User's Guide</li>
</ul>
<h3><a class="anchor" id="ch_lib_comm_uart_purpose"></a>
Purpose of the Driver</h3>
<p>The eUSCI_A UART Driver enables developers to quickly get up and running with UART communication via an API that is similar to one used on a PC. The API provides simple functions such as UART_openPort() and UART_transmitBuffer(), and it allows the developer to register event handlers for received data and error conditions. To enable portability, the driver is built upon the MSP430 DriverLib register abstraction. This driver has been designed to work with MSP430 DriverLib build 1.90.00.00 and greater. Like any other serial interface, UART has benefits and drawbacks. Whether or not it is the best choice for an embedded interface depends on a number of factors. The benefits and drawbacks of UART are discussed below.</p>
<p>UART Benefits</p><ul>
<li>Ease of implementation. UART is one of the most common serial communication protocols around. While interfaces with higher speed and higher reliability exist, such as I2C and SPI, none match UART for ease of implementation. UART is easily interfaced to a host PC or another microcontroller, and as such it is well suited for use as a debug console.</li>
<li>Point-to-point simplicity. Since only two nodes exist, the interface is not a bus with multiple devices attached. This removes the need for addressing or chip-select overhead.</li>
<li>Full duplex communication. In this UART driver implementation, transmit and receive operations are decoupled and may occur concurrently. Each of the two connected nodes may consider itself a master, and may begin transmission to the other node at any time.</li>
</ul>
<p>UART Drawbacks</p><ul>
<li>Critical bit timing. Because UART transmission is asynchronous (there is no bit clock), accurate timing must be guaranteed on both sides of the interface.</li>
<li>Bit rate limitation. Due to the critical bit timing above, UART is typically more limited in maximum bit clock then when compared with a synchronous interface, such as SPI or I2C.</li>
<li>Critical ISR timing. This driver does not employ the use of a DMA channel for moving data from transmit and receive buffers into RAM, as not all devices are equipped with a DMA engine. Instead of DMA, all data transfers are handled via interrupt service routines. This means that the CPU must be available to service receive interrupts at least every byte period. A byte period is defined as the transmission time for one byte, which is equal to 10 times the bit period. Note that the byte transmission time increases if parity or more than one stop bit is used. For example, if the bit clock is 250 kHz, the transmission time of one byte is 4us times 10 bits, or 40us. With an 8MHz CPU clock, there are only 320 instruction cycles available every 40us. If the CPU is not available to service receive interrupts, received bytes may be lost. The driver provides an error detection mechanism to alert the application if and when data is being lost.</li>
<li>Asynchronous overhead. UART as configured in this driver requires at least one start bit and one stop bit. As such, each 8-bit byte requires that 10 bits be sent. This overhead would not be present in a SPI interface, although I2C does impose an ACK/NACK bit as well as addressing overhead.</li>
</ul>
<h3><a class="anchor" id="ch_lib_comm_uart_features"></a>
Driver Features</h3>
<p>The key features implemented in the UART driver are listed below.</p><ul>
<li>Full duplex bi-directional communication</li>
<li>No flow control required</li>
<li>Fully interrupt-driven</li>
<li>Non-blocking transmit function</li>
<li>Receive event callback</li>
<li>Error event callback</li>
<li>Compile-time selection of which eUSCI_A instance to use</li>
</ul>
<h3><a class="anchor" id="ch_lib_comm_uart_overview"></a>
Driver Overview</h3>
<p>The UART driver is provided in source code. The driver consists of three source files:</p><ul>
<li>UART_Definitions.h (Configuration header file)</li>
<li>UART.h (API Header file)</li>
<li>UART.c (API Implementation file) The core driver is implemented in UART.h and UART.c. The UART_Definitions.h file allows the developer to adjust the driver's compile-time options.</li>
</ul>
<p>The UART driver requires the following hardware resources:</p><ul>
<li>One eUSCI_A peripheral instantiation</li>
<li>Two device pins (UCAxTXD and UCAxRXD), where 'x' represents the selected eUSCI_A instance</li>
</ul>
<p>The UART driver API is composed of functions and data types. The sections below describe how to configure the UART driver and use it to perform transmit and receive operations. The UART driver employs a basic software state machine to manage operations. The three driver states and their interconnection are shown in the diagram below.</p>
<div class="image">
<img src="lib_comm_uartdriverstatemachine.png" alt="lib_comm_uartdriverstatemachine.png"/>
<div class="caption">
UART Driver State Machine</div></div>
  <h3><a class="anchor" id="ch_lib_comm_uart_compiletimeconfig"></a>
Compile-time Driver Configuration Options</h3>
<p>The UART driver has compile-time options as well as run-time configurable options. Certain things must be known at compile-time, such as which eUSCI_A peripheral instance is associated with the driver. Other options, such as baud rate, may be controlled at runtime.</p>
<p>The compile-time configuration options are set in the UART_Definitions.h file. The available compile-time options are described below.</p>
<h4>UART Enable Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">UART__ENABLE</td><td align="center">UART_Definitions.h</td><td align="center">true, false </td></tr>
</table>
<p>The UART Enable compile-time option selects whether the UART Driver is enabled or disabled. This provides a mechanism to exclude the driver from the compilation process. To include the driver, define UART__ENABLE as true. Else, define it as false.</p>
<h4>UART eUSCI_A Peripheral Selection Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">UART__EUSCI_A_PERIPHERAL</td><td align="center">UART_Definitions.h</td><td align="center">EUSCI_A0_BASE, EUSCI_A1_BASE </td></tr>
</table>
<p>The UART eUSCI_A peripheral selection allows easy selection of which eUSCI_A instance to associate with the UART driver. This provides flexibility during design if a pin-mux change is necessary. A valid base address must be provided.When a eUSCI_A peripheral selection is made, the UART driver ISR address is linked to the appropriate eUSCI interrupt vector automatically. If an invalid address is selected, a compiler error is thrown.</p>
<h4>UART Low Power Mode (LPMx)</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">UART__LPMx_bits</td><td align="center">UART_Definitions.h</td><td align="center">0, LPM0_bits, LPM1_bits, LPM2_bits, LPM3_bits </td></tr>
</table>
<p>UART communications is often performed in a low power mode. The UART LPM Mode configuration is used in three ways, as described below.</p><ul>
<li>The receive callback and error callback functions may trigger an active exit from a low power mode to wake the CPU for further action. If a callback function returns a Boolean true, the UART driver will wake the CPU after returning from the callback. It does this by clearing the status register bits indicated in the UART LPM Mode configuration upon exit from the UART ISR.</li>
<li>A transmit operation will exit the low power mode specified by the UART LPM Mode configuration once the full transmission is complete, to allow the application to know that the transmission was completed.</li>
<li>The transmit function is normally a non-blocking function. Once transmission begins, the function returns. However, in the event that a previous transmission was still in progress when the transmit function was called, there is an option to wait for the previous transmission to complete inside of a low power mode. If that option is selected, the low power mode specified by the UART LPM Mode configuration will be entered while waiting. The transmit function will know to begin transmission when the previous transmission exits active (per number 2 above).</li>
</ul>
<h3><a class="anchor" id="ch_lib_comm_uart_runtimeconfig"></a>
Run-time Driver Configuration Options</h3>
<p>The UART driver has compile-time options as well as run-time configurable options. The runtime configuration options are specified by populating a tUARTPort structure in the application, and passing this structure to the driver when opening the driver. A tUARTPort structure is required when opening the UART driver. The tUARTPort structure must be available in memory whenever the driver is open. This is a result of the fact that the UART driver references this structure at runtime to find the callback functions for receive handling and error handling. However, the driver does not modify the data in the structure at any time, and as such, the structure may be placed in a read-only memory section (such as C const memory). These parameters are considered runtime adjustable because the parameters may be modified by the application if the UART driver is closed first, then re-opened. For example, the application may change the UART baud rate by closing the port, changing the baud rate options on the tUARTPort structure, and re-opening the port. Note that the .peripheralParameters member of the tUARTPort structure is a EUSCI_A_UART_initParam structure from the MSP430 Driver Library.</p>
<table class="doxtable">
<tr>
<th align="left">Member</th><th align="left">Description</th><th align="left">Valid Values  </th></tr>
<tr>
<td align="left">bool (*pbReceiveCallback)(uint8_t)</td><td align="left">pbReceiveCallback is a function pointer that may point to a receive event handler. If no receive handling is required, initialize this member to 0 (null).</td><td align="left">Null, or a valid function address. </td></tr>
<tr>
<td align="left">bool (*pbErrorCallback)(uint8_t)</td><td align="left">pbErrorCallback is a function pointer that may point to an error event handler. If no error handling is required, initialize this member to 0 (null).</td><td align="left">Null, or a valid function address. </td></tr>
<tr>
<td align="left">.peripheralParameters.selectClockSource</td><td align="left">This member specifies the clock source for the eUSCI_A peripheral.</td><td align="left">EUSCI_A_UART_CLOCKSOURCE_SMCLK, EUSCI_A_UART_CLOCKSOURCE_ACLK </td></tr>
<tr>
<td align="left">.peripheralParameters.clockPrescalar</td><td align="left">This member specifies the eUSCI_A clock prescalar. This affects the baud rate.</td><td align="left">0-65535 </td></tr>
<tr>
<td align="left">.peripheralParameters.firstModReg</td><td align="left">This member specifies the eUSCI_A first stage modulation. This affects the baud rate.</td><td align="left">0-15 </td></tr>
<tr>
<td align="left">.peripheralParameters.secondModReg</td><td align="left">This member specifies the eUSCI_A second stage modulation. This affects the baud rate.</td><td align="left">0-255 </td></tr>
<tr>
<td align="left">.peripheralParameters.parity</td><td align="left">This member specifies the UART parity mode.</td><td align="left">EUSCI_A_UART_NO_PARITY, EUSCI_A_UART_ODD_PARITY, EUSCI_A_UART_EVEN_PARITY </td></tr>
<tr>
<td align="left">.peripheralParameters.msborLsbFirst</td><td align="left">This member specifies the transmission bit order.</td><td align="left">EUSCI_A_UART_LSB_FIRST, EUSCI_A_UART_MSB_FIRST </td></tr>
<tr>
<td align="left">.peripheralParameters.numberofStopBits</td><td align="left">This member specifies the number of stop bits.</td><td align="left">EUSCI_A_UART_ONE_STOP_BIT, EUSCI_A_UART_TWO_STOP_BITS </td></tr>
<tr>
<td align="left">.peripheralParameters.uartMode</td><td align="left">This member specifies the UART mode.</td><td align="left">EUSCI_A_UART_MODE, EUSCI_A_UART_IDLE_LINE_MULTI_PROCESSOR_MODE, EUSCI_A_UART_ADDRESS_BIT_MULTI_PROCESSOR_MODE, EUSCI_A_UART_AUTOMATIC_BAUDRATE_DETECTION_MODE </td></tr>
<tr>
<td align="left">.peripheralParameters.overSampling</td><td align="left">This member specifies whether UART oversampling is enabled.</td><td align="left">EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION, EUSCI_A_UART_LOW_FREQUENCY_BAUDRATE_GENERATION </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_comm_uart_howtoopenandclose"></a>
Using the Driver: Opening and Closing the Driver</h3>
<p>Opening and closing of the UART driver is accomplished through the following function calls:</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Open the UART Port</td><td align="left">extern void <b>UART_openPort</b>(const tUARTPort *pPort) </td></tr>
<tr>
<td align="left">Close the UART Port</td><td align="left">extern void <b>UART_closePort</b>(void) </td></tr>
</table>
<p>The UART driver is opened and initialized by a call to <b>UART_openPort()</b>, which is passed a completed tUARTPort structure. The tUARTPort structure must be populated by the application. It may be placed in read-only memory, as the UART API does not modify the structure at any time; rather, it only references it. It is important that the structure be left in memory at the address given when <b>UART_openPort()</b> is called, as the UART API will reference this structure to access callback functions when the port is open. If the memory must be freed, first close the UART port with a call to <b>UART_closePort()</b>.</p>
<p>A call to <b>UART_closePort()</b> will disable the UART port and its associated eUSCI_A peripheral, halting all Rx/Tx interrupt activity. After the port is closed, the event handlers will no longer be called, and the tUARTPort structure memory may be released to the application.</p>
<p><b>Opening a Port</b> </p><div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// g_myUartPort specifies the UART port configuration that is passed</span></div>
<div class="line"><span class="comment">// to the UART port driver during init.</span></div>
<div class="line"><span class="comment">// The UART configuration is 9600B8N1, sourced by a 4MHz SMCLK.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">const</span> tUARTPort g_myUartPort =</div>
<div class="line">{</div>
<div class="line">    .pbReceiveCallback = &amp;receiveHandler,</div>
<div class="line">    .pbErrorCallback = &amp;errorHandler,</div>
<div class="line">    .peripheralParameters.selectClockSource = EUSCI_A_UART_CLOCKSOURCE_SMCLK,</div>
<div class="line">    .peripheralParameters.clockPrescalar = 26,</div>
<div class="line">    .peripheralParameters.firstModReg = 0,</div>
<div class="line">    .peripheralParameters.secondModReg = 0xB6,</div>
<div class="line">    .peripheralParameters.parity = EUSCI_A_UART_NO_PARITY,</div>
<div class="line">    .peripheralParameters.msborLsbFirst = EUSCI_A_UART_LSB_FIRST,</div>
<div class="line">    .peripheralParameters.numberofStopBits = EUSCI_A_UART_ONE_STOP_BIT,</div>
<div class="line">    .peripheralParameters.uartMode = EUSCI_A_UART_MODE,</div>
<div class="line">    .peripheralParameters.overSampling = EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">UART_openPort(&amp;g_myUartPort);</div>
</div><!-- fragment --><h3><a class="anchor" id="ch_lib_comm_uart_howtotx"></a>
Using the Driver: Transmitting Data</h3>
<p>Data transmission is accomplished through the following function calls:</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Transmit a Buffer</td><td align="left">extern void <b>UART_transmitBuffer</b>(const uint8_t *pBuffer, uint16_t ui16Length) </td></tr>
<tr>
<td align="left">Transmit a Byte</td><td align="left">extern void <b>UART_transmitByteImmediately</b>(uint8_t ui8Data) </td></tr>
<tr>
<td align="left">Get Port Status</td><td align="left">extern uint8_t <b>UART_getPortStatus</b>(void) </td></tr>
</table>
<p>Transmit operations are interrupt driven. To initiate a transmission after opening the UART port, make a call to <b>UART_transmitBuffer()</b>. This function is simply passed a pointer to the buffer to transmit, and the length of the buffer to transmit (specified in bytes). If the eUSCI_A peripheral is available, transmission will begin immediately and the function will return. If the peripheral is still busy sending a previous transmission, it will block (in a low power mode, if specified in UART_Definitions.h) until the previous transmission is complete.</p>
<p><b>Transmitting a Buffer</b> </p><div class="fragment"><div class="line">UART_transmitBuffer(<span class="stringliteral">&quot;\n\rHello World!\n\r&quot;</span>, <span class="keyword">sizeof</span>(<span class="stringliteral">&quot;\n\rHello World!\n\r&quot;</span>));</div>
</div><!-- fragment --><div class="image">
<img src="lib_comm_uartdrivertxflow.png" alt="lib_comm_uartdrivertxflow.png"/>
<div class="caption">
UART Transmit Flow Diagram</div></div>
  <p>The transmit operation uses the buffer memory that was pointed to in the <b>UART_transmitBuffer()</b> function - it does not perform a data copy in the name of efficiency. As such, that memory must not be modified during the transmission, or the transmission will be invalid. To detect when transmission has completed and the memory is again available, it is possible to check the UART port status via a call to <b>UART_getPortStatus()</b>. If an application will be re-using buffer space, it is best to employ a ping-pong buffer strategy so that a new packet may be assembled while a previous packet is being sent.</p>
<p>A call to <b>UART_getPortStatus()</b> returns one of the values enumerated by tUARTStates. The options are described below.</p>
<table class="doxtable">
<tr>
<th align="left">Port Status Option</th><th align="left">Description  </th></tr>
<tr>
<td align="left">eUARTIsClosed</td><td align="left">The UART driver is not currently open, and is neither receiving nor transmitting data. </td></tr>
<tr>
<td align="left">eUARTIsIdle</td><td align="left">The UART driver is currently open, but is not in the process of transmitting a buffer. </td></tr>
<tr>
<td align="left">eUARTIsTransmitting</td><td align="left">The UART driver is currently open, and is in the process of transmitting a buffer. </td></tr>
</table>
<p>If only a single byte is going to be sent, it is possible to send it immediately via the <b>UART_transmitByteImmediately()</b> function. This function sends a single byte as soon as the eUSCI_A peripheral transmit buffer is available. It will block until the buffer is available. If a transmission started by a call to <b>UART_transmitBuffer()</b> is in progress, this transfer may finish first as it is interrupt-driven. The <b>UART_transmitByteImmediately()</b> function is mainly available to be used in terminal emulator applications, where sent ASCII characters are echoed back to be visible to the user.</p>
<p><b>Transmitting a Single Byte</b> </p><div class="fragment"><div class="line">uint8_t ui8Data = 0x01;</div>
<div class="line">UART_transmitByteImmediately(ui8Data);</div>
</div><!-- fragment --><h3><a class="anchor" id="ch_lib_comm_uart_howtorx"></a>
Using the Driver: Receiving Data</h3>
<p>Received data is passed to the application through the use of the receive callback. The UART driver will call a user-defined function every time a new byte is received from the UART peripheral, passing that byte to the receive callback. It is then up to the application to decide how to handle the data. It is recommended to use a ring-buffer FIFO queue to handle buffering incoming data. The data may then be extracted and processed in a background process. The receive event handler is called from the UART ISR in the UART driver, and as such, the event handler should be kept as short as possible. It is recommended to follow the same practice used to write ISR's when writing event handlers.</p>
<p>The receive callback function is linked to the driver by placing its address in the pbReceiveCallback member of the tUARTPort structure. If the application does not wish to listen for receive events, the receive callback pointer in the tUARTPort structure may be initialized to null. Receive operations are performed entirely out of the ISR. The receive operation ISR flow is shown below. <a class="el" href="ch_lib.html#ch_lib_comm_uart_howtoerrorhandle">Errors</a> are checked for whenever a receive interrupt is serviced.</p>
<div class="image">
<img src="lib_comm_uartdriverrxflow.png" alt="lib_comm_uartdriverrxflow.png"/>
<div class="caption">
UART Receive Flow Diagram</div></div>
  <h3><a class="anchor" id="ch_lib_comm_uart_howtoerrorhandle"></a>
Using the Driver: Error Handling</h3>
<p>The UART driver employs basic UART error detection to alert the application when something has gone wrong. The two errors detected by the driver are:</p><ol type="1">
<li>UART Receive Buffer Overrun. This occurs if a new byte is placed into the eUSCI_A UART receive buffer before a previous byte was read out. This occurs when there is not enough CPU bandwidth to read out data at the rate data is coming into the peripheral. To resolve this error during development, it is necessary to either: slow down the rate at which data is received, whether through delays between bytes or a lower baud rate, or to increase the CPU availability by shortening interrupt handlers or increasing the CPU clock frequency. The enumerated error flag is eUARTOverrunError.</li>
<li>UART Framing Error. This typically occurs if there is a baud rate mismatch between devices. The enumerated error flag is eUARTFramingError. The driver alerts the application via the error callback function. This works similar to the receive callback, except the error code is passed rather than the received byte. The error callback function is called from the UART ISR, and as such, it should be kept as short as possible. The error callback function is linked to the driver by placing its address in the pbErrorCallback member of the tUARTPort structure. If the application does not wish to listen for error events, the error callback pointer in the tUARTPort structure may be initialized to null.</li>
</ol>
<h3><a class="anchor" id="ch_lib_comm_uart_example1"></a>
Using the Driver: Example Application</h3>
<p>This example listens for a ASCII line on eUSCI_A0. When a line is received, it is echoed back. The baud rate is 9600-8N1. The max line size is 64 bytes.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;driverlib.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;UART.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// DCO_FREQ defines the MSP430 DCO frequency in Hz</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#define DCO_FREQ                8000000</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// REFO_FREQ defines the REFO frequency in Hz</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#define REFO_FREQ               32768</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// RECEIVE_BUFFER_SIZE defines the size of the UART receive buffer.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#define RECEIVE_BUFFER_SIZE     64</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// g_ui8ReceiveBuffer is the UART receive buffer.  It is filled with</span></div>
<div class="line"><span class="comment">// incoming characters via the UART receive event handler.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">uint8_t g_ui8ReceiveBuffer[RECEIVE_BUFFER_SIZE];</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// g_ui8ReceiveIndex is the UART receive buffer index.  It defines the</span></div>
<div class="line"><span class="comment">// buffer index that the next received byte is placed into.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">uint8_t g_ui8ReceiveIndex;</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// g_bGotNewLine is a flag used by the UART receive event handler to</span></div>
<div class="line"><span class="comment">// signal the background loop (the main application thread) that a full</span></div>
<div class="line"><span class="comment">// ASCII line has been received in the buffer.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> g_bGotNewLine = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The UART receive handler is called by the UART port driver whenever a new</span></div>
<div class="line"><span class="comment">// character is received.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> receiveHandler(uint8_t ui8Data)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (g_bGotNewLine == <span class="keyword">false</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (g_ui8ReceiveIndex&lt;RECEIVE_BUFFER_SIZE)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// It is safe to receive the new character into the buffer.</span></div>
<div class="line">            <span class="comment">// If the data is a ASCII return, signal the background app</span></div>
<div class="line">            <span class="comment">// and exit awake.</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            g_ui8ReceiveBuffer[g_ui8ReceiveIndex++] = ui8Data;</div>
<div class="line">            <span class="keywordflow">if</span> (ui8Data==<span class="charliteral">&#39;\r&#39;</span>)</div>
<div class="line">            {</div>
<div class="line">                g_bGotNewLine = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                UART_transmitByteImmediately(ui8Data);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// The buffer is full, return new line to print what</span></div>
<div class="line">            <span class="comment">// we have right now</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            g_bGotNewLine = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The UART error handler is called by the UART port driver whenever an</span></div>
<div class="line"><span class="comment">// error on the UART port is detected.</span></div>
<div class="line"><span class="comment">// The application could handle errors here if desired (such as a UART buffer</span></div>
<div class="line"><span class="comment">// overrun or framing error).</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> errorHandler(uint8_t ui8Error)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// g_myUartPort specifies the UART port configuration that is passed</span></div>
<div class="line"><span class="comment">// to the UART port driver during init.</span></div>
<div class="line"><span class="comment">// The UART configuration is 9600B8N1, sourced by SMCLK.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">const</span> tUARTPort g_myUartPort =</div>
<div class="line">{</div>
<div class="line">    .pbReceiveCallback = &amp;receiveHandler,</div>
<div class="line">    .pbErrorCallback = &amp;errorHandler,</div>
<div class="line">    .peripheralParameters.selectClockSource = EUSCI_A_UART_CLOCKSOURCE_SMCLK,</div>
<div class="line">    .peripheralParameters.clockPrescalar = 26,</div>
<div class="line">    .peripheralParameters.firstModReg = 0,</div>
<div class="line">    .peripheralParameters.secondModReg = 0xB6,</div>
<div class="line">    .peripheralParameters.parity = EUSCI_A_UART_NO_PARITY,</div>
<div class="line">    .peripheralParameters.msborLsbFirst = EUSCI_A_UART_LSB_FIRST,</div>
<div class="line">    .peripheralParameters.numberofStopBits = EUSCI_A_UART_ONE_STOP_BIT,</div>
<div class="line">    .peripheralParameters.uartMode = EUSCI_A_UART_MODE,</div>
<div class="line">    .peripheralParameters.overSampling = EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Application main()</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Set up the MCU with a 8MHz MCLK, 4MHz SMCLK, and ~32.768kHz ACLK.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    WDT_A_hold(WDT_A_BASE);</div>
<div class="line">    CS_clockSignalInit(CS_FLLREF, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1);</div>
<div class="line">    CS_initFLLSettle(DCO_FREQ/1000, DCO_FREQ/REFO_FREQ);</div>
<div class="line">    CS_clockSignalInit(CS_MCLK, CS_DCOCLKDIV_SELECT, CS_CLOCK_DIVIDER_1);</div>
<div class="line">    CS_clockSignalInit(CS_SMCLK, CS_DCOCLKDIV_SELECT, CS_CLOCK_DIVIDER_2);</div>
<div class="line">    CS_clockSignalInit(CS_ACLK, CS_REFOCLK_SELECT, CS_CLOCK_DIVIDER_1);</div>
<div class="line">    __delay_cycles(8000000);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Set P1.0 and P1.1 to UCA0TXD and UCA0RXD, respectively.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    PM5CTL0 &amp;= ~LOCKLPM5;</div>
<div class="line">    GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P1, GPIO_PIN4, GPIO_PRIMARY_MODULE_FUNCTION);</div>
<div class="line">    GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P1, GPIO_PIN5, GPIO_PRIMARY_MODULE_FUNCTION);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Enable masked interrupts.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    __bis_SR_register(GIE);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Open the UART port and send the welcome message!</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    UART_openPort(&amp;g_myUartPort);</div>
<div class="line">    UART_transmitBuffer(<span class="stringliteral">&quot;\n\rHello World!\n\r&quot;</span>, <span class="keyword">sizeof</span>(<span class="stringliteral">&quot;\n\rHello World!\n\r&quot;</span>));</div>
<div class="line">    UART_transmitBuffer(<span class="stringliteral">&quot;Waiting for a new line... &quot;</span>, <span class="keyword">sizeof</span>(<span class="stringliteral">&quot;Waiting for a new line... &quot;</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Application background loop</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// If a new line was received, echo it back!</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordflow">if</span> (g_bGotNewLine == <span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            UART_transmitBuffer(<span class="stringliteral">&quot;\n\rReceived: &quot;</span>, <span class="keyword">sizeof</span>(<span class="stringliteral">&quot;\n\rReceived: &quot;</span>));</div>
<div class="line">            UART_transmitBuffer(g_ui8ReceiveBuffer, g_ui8ReceiveIndex);</div>
<div class="line">            UART_transmitBuffer(<span class="stringliteral">&quot;\n\r&quot;</span>, <span class="keyword">sizeof</span>(<span class="stringliteral">&quot;\n\r&quot;</span>));</div>
<div class="line">            UART_transmitBuffer(<span class="stringliteral">&quot;Waiting for a new line: &quot;</span>, <span class="keyword">sizeof</span>(<span class="stringliteral">&quot;Waiting for a new line: &quot;</span>));</div>
<div class="line">            g_ui8ReceiveIndex = 0;</div>
<div class="line">            g_bGotNewLine = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Sleep in LPM0 (CPU off, DCO on).</span></div>
<div class="line">        <span class="comment">// The UART receive event handler will</span></div>
<div class="line">        <span class="comment">// wake up the background loop if a line is received.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        LPM0;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="ch_lib_communications_i2cslavedriver"></a>
I2C Slave Driver</h2>
<p>The MSP430 eUSCI_B I2C slave driver provides a simple I2C slave API to MSP430 applications, enabling interrupt-driven I2C read/write operations as well as bus timeout detection and driver error handling. This User's Guide provides an overview of the driver's features, architecture, and API. This document assumes that the reader is familiar with MSP430 MCU architecture, as well as embedded C programming concepts and basic I2C principles. Note: From this point forward, the I2C slave driver will simply be referred to as "the driver."</p>
<h3>Related Documents</h3>
<p>This guide should be used with the following additional supporting documentation. The MSP430 Driver Library API is not specific to this driver, and has its own documentation.</p><ul>
<li>MSP430 Driver Library (DriverLib) User's Guide</li>
<li>The relevant MSP430 Family User's Guide</li>
</ul>
<h3><a class="anchor" id="ch_lib_comm_i2cslave_purpose"></a>
Purpose of the Driver</h3>
<p>The driver enables quick development of MSP430 applications where the MSP430 itself is a slave device to some other master in a larger embedded system. This is a common application, as MSP430 microcontrollers are often a secondary MCU to a larger host MCU or host MPU.</p>
<p>The driver is structured to be flexible, enabling many different applications. It is capable of providing a register-file interface to a host processor, similar to a sensor or an EEPROM. It may also be used as a bulk-transfer interface to a host.</p>
<h3><a class="anchor" id="ch_lib_comm_i2cslave_features"></a>
Driver Features</h3>
<p>The key features provided by the driver are listed below.</p><ul>
<li>Interrupt-driven I2C slave software state machine</li>
<li>I2C Write (master transmitter, slave receiver) event callback</li>
<li>I2C Read (master receiver, slave transmitter) buffer assignment</li>
<li>Support for I2C start/stop/start as well as I2C start/repeated-start sequences</li>
<li>I2C error/warning reporting via an error callback function</li>
<li>Operation in LPM3 between I2C interrupts when timeout feature is used</li>
<li>Operation in LPM4 between I2C interrupts when timeout feature is not used</li>
<li>Open drain slave request signal (to alert the master to service the slave)</li>
<li>Slave request timeout capability to prevent an application stall</li>
<li>I2C bus transaction timeout capability to prevent an application stall</li>
</ul>
<h3><a class="anchor" id="ch_lib_comm_i2cslave_overview"></a>
Driver Overview</h3>
<p>The driver is provided in C source code. It consists of 3 base driver source files, plus an additional 3 source files related to the I2C timeout detection feature (which is a compile-time option).</p>
<p>Base Driver:</p><ul>
<li>I2CSlave_Definitions.h (Configuration header file)</li>
<li>I2CSlave.h (API header file)</li>
<li>I2CSlave.c (API implementation file)</li>
</ul>
<p>Function Timer (used for I2C timeout detection):</p><ul>
<li>FunctionTimer_Definitions.h (Configuration header file)</li>
<li>FunctionTimer.h (API header file)</li>
<li>FunctionTimer.c (API source file)</li>
</ul>
<p>The I2CSlave_Definitions.h and FunctionTimer_Definitions.h files contain the compile-time options for each component.</p>
<p>The driver requires the following MCU hardware resources:</p>
<p>Base Driver:</p><ul>
<li>One eUSCI_B peripheral instantiation</li>
<li>Two device pins (UCBxSDA and UCBxSCL), where 'x' represents the selected eUSCI_B instance</li>
</ul>
<p>Slave Request Feature (Optional):</p><ul>
<li>One additional device pin (Any digital IO for the slave request line feature).</li>
</ul>
<p>Timeout Feature (Optional):</p><ul>
<li>One TIMER_A peripheral instantiation with at least 2 capture-compare units (CCR0 and CCR1)</li>
</ul>
<p>The driver operation is based upon a software state machine that keeps track of the current driver state. There are four possible states: closed, idle, read, and write. Since the driver implements an I2C slave, it is important to be clear on the naming conventions for read and write. An I2C bus write is a receive operation from the perspective of an I2C slave, as the bus master is writing to the slave. Similarly, an I2C bus read is a transmit operation from the perspective of the slave. The state machine implemented by the driver is depicted below.</p>
<div class="image">
<img src="lib_comm_i2cslavestatemachine.png" alt="lib_comm_i2cslavestatemachine.png"/>
<div class="caption">
I2C Slave Driver State Machine</div></div>
  <p>As shown, state changes between idle, read, and write are controlled solely by the I2C bus master. It is possible for the slave to close the driver at any time, however.</p>
<h4><a class="anchor" id="ch_lib_comm_i2cslave_overview_receiveops"></a>
Driver Overview: I2C Receive Operations (I2C Bus Write)</h4>
<p>The driver enters the "write" state (eI2CSlaveIsBeingWrittenTo) whenever the bus master sends a start or restart condition to the driver's 7-bit I2C address with the R/_W bit cleared. In this state, the driver is receiving data. Data is received into the buffer memory that was specified by the user when the driver was opened. If the bus master attempts to write data beyond the length of the receive buffer, the data is ignored and an error callback alerts the application. The write state is cleared when a stop condition or a restart condition is issued. When this happens, the driver calls a user-specified callback function for the received data to be handled.</p>
<h4><a class="anchor" id="ch_lib_comm_i2cslave_overview_transmitops"></a>
Driver Overview: I2C Transmit Operations (I2C Bus Read)</h4>
<p>The driver enters the "read" state (eI2CSlaveIsBeingRead) whenever the bus master sends a start or restart condition to the driver's 7-bit I2C address with the R/_W bit set. In this state, the driver is transmitting data to the master by loading data from the latest transmit buffer memory that was linked to the driver. Note that the buffer memory must have been pre-loaded before the read state was entered. If the bus master attempts to read data before any buffer was specified or if it attempts to read out more data than was made available in the buffer, the driver will clock out an invalid byte, which may be specified as a compile-time option. The read state is cleared when a stop condition or a restart condition is issued. When this happens, the driver wakes the CPU from any low power modes in case it was pending on the completion of a read operation.</p>
<h4><a class="anchor" id="ch_lib_comm_i2cslave_overview_slavereqfeature"></a>
Driver Overview: Slave Request Feature</h4>
<p>The driver provides a mechanism for alerting the bus master that it wishes to communicate. This is helpful in many applications, as the slave has no way to initiate communication on the I2C bus. The slave request feature is implemented as an open-drain request line. The request line may be any digital IO on the MCU. The request line should be pulled up to VCC via a pull-up resistor, just like an I2C bus line. The driver controls whether the request line IO is left tri-stated (Hi-Z), or whether it is pulled to a logic low (sinking current to ground through the pullup resistor and the digital IO). The driver API contains a function for "pulling" the request line, which waits for a I2C bus response from the master (or a timeout) before returning.</p>
<h4><a class="anchor" id="ch_lib_comm_i2cslave_overview_timeoutfeature"></a>
Driver Overview: Timeout Feature (Function Timer)</h4>
<p>The driver provides a timeout mechanism for preventing application lock-ups. To enable timeouts in a low-power way, a dedicated hardware timer is used to set limits on how long specific driver operations may take. The operations that may have timeouts placed on them are:</p>
<ol type="1">
<li><b>I2C Slave Request Timeout.</b> The slave request feature described in section 2.3.3 signals the bust master to communicate with the slave. That slave request API function is designed to block until the master starts communication (via a I2C bus read start condition). If the timeout feature is enabled, the slave request function will time out automatically if the master does not start a read within the specified timeout period.</li>
<li><b>I2C Transaction Timeout.</b> The transaction timeout places a limit on how long any I2C bus transaction may take. An I2C transaction time is defined between a start or restart condition until a restart or stop condition is issued. The goal of the transaction timeout is to detect scenarios where the bus master went down in the middle of transmission, or an I2C bus disconnection.</li>
</ol>
<p>The timeout feature is implemented by the Function Timer module, which is a completely independent software module. As transaction monitoring may be a part of the application layer (perhaps with a standard watchdog timer), the timeout feature may be excluded completely at compile time. The Function Timer module essentially calls a predefined function in the foreground after a defined delay in timer cycles. That function can then take actions such as cancelling a slave request or resetting the driver.</p>
<h3><a class="anchor" id="ch_lib_comm_i2cslave_compiletimeconfig"></a>
Compile-time Driver Configuration Options</h3>
<p>The compile-time configuration options are set in the I2CSlave_Definitions.h and FunctionTimer_Definitions.h files. These options are described below.</p>
<h4>I2C Slave Enable Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__ENABLE</td><td align="center">I2CSlave_Definitions.h</td><td align="center">true, false </td></tr>
</table>
<p>The I2C Slave Enable compile-time option selects whether the driver is enabled or disabled. This provides a mechanism to exclude the driver from the compilation process. To include the driver, define I2CSlave__ENABLE as true. Else, define it as false.</p>
<h4>I2C eUSCI_B Peripheral Selection Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__EUSCI_B_PERIPHERAL</td><td align="center">I2CSlave_Definitions.h</td><td align="center">EUSCI_B0_BASE </td></tr>
</table>
<p>The I2C eUSCI_B peripheral selection allows easy selection of which eUSCI_B instance to associate with the I2C driver. This provides flexibility during design if a pin-mux change is necessary. A valid base address must be provided.</p>
<h4>I2C Slave Address Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__ADDRESS</td><td align="center">I2CSlave_Definitions.h</td><td align="center">0x00 to 0x7F </td></tr>
</table>
<p>The I2C slave address specifies the 7-bit I2C bus address associated with this device.</p>
<h4>I2C Slave LPM Mode Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__LPMx_bits</td><td align="center">I2CSlave_Definitions.h</td><td align="center">LPM0_bits, LPM1_bits, LPM2_bits, LPM3_bits, LPM4_bits </td></tr>
</table>
<p>I2C communication may be performed in a low power mode. No clocks need to be enabled on the MSP430 to send or receive bytes on a eUSCI_B peripheral when in I2C slave mode. This is a benefit of the bit clock being provided by the bus master. The I2C Slave LPM mode control is used in the following ways.</p><ol type="1">
<li>Receive callback functions may trigger an active exit from the I2C ISR after the completion of a receive event (triggered by either a re-start or a stop condition). If a receive callback returns true to the driver, the status register bits specified by the I2C slave LPM mode will be cleared when exiting.</li>
<li>A call to I2CSlave_setTransmitBuffer() will block if a previous read is requested or in progress. If a low power mode is specified via the I2C Slave LPM Mode definition, the block will take place in that low power mode- otherwise, it will block in active mode.</li>
</ol>
<h4>I2C Slave Invalid Byte Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__INVALID_BYTE</td><td align="center">I2CSlave_Definitions.h</td><td align="center">0x00 to 0xFF </td></tr>
</table>
<p>The invalid byte specifies the byte that is transmitted to the master (during an I2C read) if the master attempts to read beyond the length of the transmit buffer provided to the driver.</p>
<h4>I2C Slave Timeout Enable Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__TIMEOUT_ENABLE</td><td align="center">I2CSlave_Definitions.h</td><td align="center">true, false </td></tr>
</table>
<p>The slave timeout enable controls whether the timeout feature of the driver is included. The timeout feature provides the ability to set a maximum amount of time a certain I2C slave task may take before it fails. The two tasks that may be monitored with a timeout is the I2C slave request and any I2C transaction. Note that enabling the timeout feature requires the inclusion of the FunctionTimer source files, a Timer_A instance, and additional memory.</p>
<h4>I2C Slave Request Timeout Cycles Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__REQ_TIMEOUT_CYCLES</td><td align="center">I2CSlave_Definitions.h</td><td align="center">0x0000 - 0xFFFF </td></tr>
</table>
<p>The I2C slave request timeout cycles specifies the timeout period for the I2C request timeout, in units of the function timer clock period. This is the amount of time the driver will wait after pulling the slave request line low before the transaction fails out. The bus master must respond to the slave request within this amount of time.</p>
<h4>I2C Slave Transfer Timeout Cycles Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__TXFR_TIMEOUT_CYCLES</td><td align="center">I2CSlave_Definitions.h</td><td align="center">0x0000 - 0xFFFF </td></tr>
</table>
<p>The I2C slave transfer timeout cycles specifies the timeout period for any I2C transaction, in units of the function timer clock period. I2C transactions are timed from start condition to stop condition, or start condition to re-start condition.</p>
<h4>I2C Slave Request Enable Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__REQ_ENABLE</td><td align="center">I2CSlave_Definitions.h</td><td align="center">true, false </td></tr>
</table>
<p>The request enable controls whether the I2C request line feature is included in the driver build. The I2C request line provides a mechanism for the slave to signal the master that it would like to communicate.</p>
<h4>I2C Slave Request Line Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">I2CSLAVE__REQ_POUT</td><td align="center">I2CSlave_Definitions.h</td><td align="center">PxOUT </td></tr>
<tr>
<td align="center">I2CSLAVE__REQ_PDIR</td><td align="center">I2CSlave_Definitions.h</td><td align="center">PxDIR </td></tr>
<tr>
<td align="center">I2CSLAVE__REQ_MASK</td><td align="center">I2CSlave_Definitions.h</td><td align="center">BIT0 - BIT7 </td></tr>
</table>
<p>The I2C slave request line is defined by three values- the port output register, the port direction register, and the pin mask. These do not need to be defined if the slave request enable is set to false.</p>
<h4>Function Timer Enable Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">FUNCTIONTIMER__ENABLE</td><td align="center">FunctionTimer_Definitions.h</td><td align="center">true, false </td></tr>
</table>
<p>The function timer enable controls whether the function timer is included in the driver build. If the I2C slave timeout feature is not used, memory is conserved when the function timer is disabled (set to false).</p>
<h4>Function Timer Peripheral Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">FUNCTIONTIMER__PERIPHERAL</td><td align="center">FunctionTimer_Definitions.h</td><td align="center">TIMER_A0_BASE, TIMER_A1_BASE, TIMER_A2_BASE, TIMER_A3_BASE </td></tr>
</table>
<p>The function timer peripheral stores the base address of the Timer_A instance that should be associated with the function timer. This instance must have at least two capture compare units (CCR0 and CCR1).</p>
<h4>Function Timer Clock Source Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">FUNCTIONTIMER__CLOCK</td><td align="center">FunctionTimer_Definitions.h</td><td align="center">TASSEL__SMCLK, TASSEL__ACLK </td></tr>
</table>
<p>The function timer clock determines the resolution of the function timer, as well as the maximum delay. Sources include SMCLK and ACLK. Note that if the clock source is changed, the effective function timer delay may change.</p>
<h4>Function Timer Clock Divider Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">FUNCTIONTIMER__DIVIDER</td><td align="center">FunctionTimer_Definitions.h</td><td align="center">ID__1, ID__2, ID__4, ID__8 </td></tr>
</table>
<p>The function timer clock divider divides down the source clock (which was specified above). Note that if the clock divider is changed, the effective function timer delay may change.</p>
<h4>Function Timer Extended Clock Divider Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">FUNCTIONTIMER__EXDIVIDER</td><td align="center">FunctionTimer_Definitions.h</td><td align="center">TAIDEX_0 to TAIDEX_7 </td></tr>
</table>
<p>The function timer extended divider allows an additional second divider to be added in series with the standard divider. Note that if the extended clock divider is changed, the effective function timer delay may change.</p>
<h4>Function Timer LPM Clear Definition</h4>
<table class="doxtable">
<tr>
<th align="center">Parameter</th><th align="center">File</th><th align="center">Valid Values  </th></tr>
<tr>
<td align="center">FUNCTIONTIMER__LPM_CLEAR</td><td align="center">FunctionTimer_Definitions.h</td><td align="center">LPM0_bits, LPM1_bits, LPM2_bits, LPM3_bits, LPM4_bits </td></tr>
</table>
<p>The function timer LPM clear controls which LPM bits are cleared upon exit from a function called in the foreground by the function timer. This should be set to enable CPU wake-up after a timeout event. The function timer feature will never use these bits to enter into a low power mode- it will only use them to exit.</p>
<h3><a class="anchor" id="ch_lib_comm_i2cslave_runtimeconfig"></a>
Run-time Driver Configuration Options</h3>
<p>The driver's runtime configuration options are specified by populating a tI2CSlavePort structure in the application, and passing this structure to the driver when opening the driver. The tI2CSlavePort structures are discussed below.</p>
<table class="doxtable">
<tr>
<th align="left">Member</th><th align="left">Description</th><th align="left">Valid Values  </th></tr>
<tr>
<td align="left">bool (*pbReceiveCallback)(uint16_t)</td><td align="left">pbReceiveCallback is a function pointer that may point to a receive event handler in the application. If no receive handling is required, initialize this member to 0 (null).</td><td align="left">Null, or a valid function address. </td></tr>
<tr>
<td align="left">void (*pvErrorCallback)(uint8_t)</td><td align="left">pvErrorCallback is a function pointer that may point to an error event handler in the application. If no error handling is required, initialize this member to 0 (null).</td><td align="left">Null, or a valid function address </td></tr>
<tr>
<td align="left">ui16ReceiveBufferSize</td><td align="left">This member stores the size of the receive buffer pointed to by pReceiveBuffer.</td><td align="left">0x00 to 0xFF </td></tr>
<tr>
<td align="left">pReceiveBuffer</td><td align="left">This member is a pointer to the I2C receive buffer.</td><td align="left">A valid pointer </td></tr>
<tr>
<td align="left">bSendReadLengthFirst</td><td align="left">When set to true, this flag configures the driver to always load the length of the transmit buffer as the first data byte read by the bus master. This is useful when variable length bulk packets are being read out by the master, and the master needs to know how many bytes to read from the slave.</td><td align="left">true, false </td></tr>
</table>
<p>If the timeout feature is included in the driver build, a function timer run-time configuration also happens- but it is handled automatically by the driver when the I2C port is opened. The function timer runtime configuration structure (tFunctionTimer) is outlined below for completeness, but application does not need to know any of the function timer details.</p>
<table class="doxtable">
<tr>
<th align="left">Member</th><th align="left">Description</th><th align="left">Valid Values  </th></tr>
<tr>
<td align="left">ui16FunctionDelay_A</td><td align="left">This member specifies the length of the delay (in timer clock cycles) before function A is called.</td><td align="left">0x0000 to 0xFFFF </td></tr>
<tr>
<td align="left">bool (*pbFunction_A)(void)</td><td align="left">pbFunction_A is a function pointer to function A.</td><td align="left">A valid function pointer, else null. </td></tr>
<tr>
<td align="left">ui16FunctionDelay_B</td><td align="left">This member specifies the length of the delay (in timer clock cycles) before function B is called.</td><td align="left">0x0000 to 0xFFFF </td></tr>
<tr>
<td align="left">bool (*pbFunction_B)(void)</td><td align="left">pbFunction_B is a function pointer to function B.</td><td align="left">A valid function pointer, else null. </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_comm_i2cslave_howtoopenandclose"></a>
Using the Driver: Opening and Closing the Driver</h3>
<p>Opening and closing of the I2C slave driver is accomplished through the following function calls:</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Open the I2C Slave Port</td><td align="left">extern void <b>I2CSlave_openPort</b>(const tI2CSlavePort *pPort) </td></tr>
<tr>
<td align="left">Close the I2C Slave Port</td><td align="left">extern void <b>I2CSlave_closePort</b>(void) </td></tr>
</table>
<p>The driver is initialized and made ready for use by placing a call to <b>I2CSlave_openPort()</b>, which is passed a completed tI2CSlavePort structure. The tI2CSlavePort structure must be populated by the application. This structure is not modified by the driver at any time, and as such, it may be placed in read-only memory such as a C const memory section. It is important that the structure be left in memory at the original address that is passed to <b>I2CSlave_openPort()</b>, as the driver will reference this structure to access callback functions when the port is open. If the memory must be freed, first close the driver with a call to <b>I2CSlave_closePort()</b>. A call to <b>I2CSlave_closePort()</b> will disable the driver and its associated eUSCI_B peripheral, halting all I2C slave activity. If the timeout feature was included in the build, <b>I2C_closePort()</b> disables the function timer module that drives the timeout feature. After the port is closed, the event handlers will no longer be called and the tI2CSlave structure memory may be released to the application.</p>
<p><b>Open the I2C Slave Port</b> </p><div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Open the I2C slave port</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">I2CSlave_openPort(&amp;g_myI2CPort);</div>
</div><!-- fragment --><h3><a class="anchor" id="ch_lib_comm_i2cslave_howtotransmit"></a>
Using the Driver: Transmitting Data (I2C Read Operation)</h3>
<p>Data transmission is accomplished through the following function calls:</p>
<table class="doxtable">
<tr>
<th align="left">Description</th><th align="left">Declaration  </th></tr>
<tr>
<td align="left">Set Transmit Buffer</td><td align="left">extern void <b>I2CSlave_setTransmitBuffer</b>(uint8_t *pBuffer, uint16_t ui16Length) </td></tr>
<tr>
<td align="left">Set Request Flag</td><td align="left">extern void <b>I2CSlave_setRequestFlag</b>(void) </td></tr>
<tr>
<td align="left">Get Port Status</td><td align="left">extern uint8_t <b>I2CSlave_getPortStatus</b>(void) </td></tr>
</table>
<p>An I2C slave cannot push data out onto the bus on its own- rather, a master must address the slave and clock out the data. Therefore, the data buffer must be made available to the driver before the bus master attempts to read it. The application may pass a pointer and a length (in bytes) to the <b>I2CSlave_setTransmitBuffer</b>() function. This function will block if a current transaction is in progress, and will return when the transmit buffer pointer and length have been updated. If no transmit buffer is provided and the bus master attempts to read from the slave, it will read out the invalid character (a compile-time option).</p>
<p>The <b>I2CSlave_setTransmitBuffer</b>() function does not perform a copy of the buffer- rather, it just stores its location and length. This is very valuable for "register" applications, where the application just updates the buffer, and <b>I2CSlave_setTransmitBuffer</b>() only needs to be called once during initialization. Repeated reads from the bus master will re-read the same buffer until <b>I2CSlave_setTransmitBuffer</b>() is called again. On the flipside, it is important that the application does not overwrite the transmit buffer space until transmission is complete.</p>
<p>If the slave request feature is enabled, the master may be signaled by calling the <b>I2CSlave_setRequestFlag</b>() function. This function immediately pulls the request line, then waits for the master to begin performing a read operation before it returns (or times out).</p>
<p>The driver state may be obtained by the application at any time by calling <b>I2CSlave_getPortStatus</b>(). This function returns the current I2C Slave state. The possible states are enumerated by tI2CSlaveStates. The possible enumerations are listed below.</p>
<table class="doxtable">
<tr>
<th align="left">Port Status Option</th><th align="left">Description  </th></tr>
<tr>
<td align="left">eI2CSlaveIsClosed</td><td align="left">The driver is closed. All functions besides <b>I2CSlave_openPort</b>() and <b>I2CSlave_getPortStatus</b>() are invalid. </td></tr>
<tr>
<td align="left">eI2CSlaveIsIdle</td><td align="left">The driver is open, but no I2C transactions are currently in progress. </td></tr>
<tr>
<td align="left">eI2CSlaveIsBeingRead</td><td align="left">The driver is open and the bus master is reading data. The driver loads data from the transmit buffer until all data has been sent, then it loads the invalid byte. </td></tr>
<tr>
<td align="left">eI2CSlaveIsBeingWrittenTo</td><td align="left">The driver is open and the bus master is writing data. The written data is placed into the receive buffer if there is space. At the end of this state, the receive callback in the application is called. </td></tr>
</table>
<p><b>Setting the I2C Slave Transmit Buffer</b> </p><div class="fragment"><div class="line">uint8_t g_ui8MemoryArray[MEMORY_SIZE] = {0};</div>
<div class="line">I2CSlave_setTransmitBuffer(g_ui8MemoryArray, MEMORY_SIZE);</div>
</div><!-- fragment --><h3><a class="anchor" id="ch_lib_comm_i2cslave_howtoreceive"></a>
Using the Driver: Receiving Data (I2C Write Operation)</h3>
<p>The bus master may start a write operation at any time. The driver will buffer incoming data into the receive buffer. When the transaction is complete, the application receive callback is called. The callback is passed the size of the data received from the master (in bytes). Since it is called from the driver interrupt service routine, no other interrupts will be processed and the eUSCI_B may be stretching the bus clock line until the driver returns from the receive callback. This provides the callback function the opportunity to process any received data and update the transmit buffer before the master may continue with communication.</p>
<h3><a class="anchor" id="ch_lib_comm_i2cslave_howtohandleerrors"></a>
Using the Driver: Error Handling</h3>
<p>The driver provides an error callback to alert the application if there is a problem with the driver. The error callback, when called, passes a value indicating the error that occurred. The possible errors are listed below.</p>
<table class="doxtable">
<tr>
<th align="left">Error Code</th><th align="left">Description  </th></tr>
<tr>
<td align="left">eI2CSlaveTransmitRequestTimeout</td><td align="left">This code indicates that a slave request to the bus master was not serviced within the timeout window, and the request timed out. </td></tr>
<tr>
<td align="left">eI2CSlaveTransactionTimeout</td><td align="left">This code indicates that an I2C transaction was taking longer than the timeout window, and the transaction timed out. This error also results in a driver reset. </td></tr>
<tr>
<td align="left">eI2CSlaveReceiveBufferFull</td><td align="left">This code indicates that the receive buffer was full during the last read transaction, and data from the bus master was lost. </td></tr>
<tr>
<td align="left">eI2CSlaveWasReadBeyondTransmitBuffer</td><td align="left">This code indicates that the bus master attempted to read data from the slave beyond the valid transmit buffer length (indicating the master was reading invalid bytes). </td></tr>
</table>
<h3><a class="anchor" id="ch_lib_comm_i2cslave_example1"></a>
Using the Driver: Example Application</h3>
<p>This is an I2C Slave Driver 512B Embedded Memory IC example. This example project configures the MSP430FR2633 as a 512B RAM device with an I2C interface. The master may write up to 128 bytes to the 8kB memory at a time. The master may read from any memory address until the end of the memory section at any time. The read/write format is as follows: I2C-START / ADDRESS+RW / MEMORY ADDR UPPER BYTE / MEMORY ADDR LOWER BYTE / DATA.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;driverlib.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;I2CSlave.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;string.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MEMORY_SIZE defines the size of the memory array in bytes</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#define MEMORY_SIZE                                                      (512)</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// g_ui8MemoryArray is the memory array.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">uint8_t g_ui8MemoryArray[MEMORY_SIZE] = {0};</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// I2C_RECEIVE_BUFFER_SIZE defines the size of the I2C receive buffer</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#define I2C_RECEIVE_BUFFER_SIZE     130</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// g_ui8I2CReceiveBuffer is the buffer space used for I2C receive ops.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">uint8_t g_ui8I2CReceiveBuffer[I2C_RECEIVE_BUFFER_SIZE];</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// REQ_LOW_ADDR defines a macro to get the low address byte in the I2C</span></div>
<div class="line"><span class="comment">// receive buffer.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// REQ_HIGH_ADDR defines a macro to get the high address byte in the I2C</span></div>
<div class="line"><span class="comment">// receive buffer.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// REQ_FULL_ADDR defines a macro to access the full 13-bit address in</span></div>
<div class="line"><span class="comment">// the receive buffer</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// REMAINING_MEMORY defines macro to get the remaining memory from the</span></div>
<div class="line"><span class="comment">//current address in the receive buffer to the end of memory.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// DATA_TO_WRITE defines a macro to get a pointer to the data to write</span></div>
<div class="line"><span class="comment">// in the I2C receive register</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#define REQ_LOW_ADDR                                 (g_ui8I2CReceiveBuffer[1])</span></div>
<div class="line"><span class="preprocessor">#define REQ_HIGH_ADDR                                (g_ui8I2CReceiveBuffer[0])</span></div>
<div class="line"><span class="preprocessor">#define REQ_FULL_ADDR ((uint16_t)REQ_LOW_ADDR | ((uint16_t)REQ_HIGH_ADDR &lt;&lt; 8))</span></div>
<div class="line"><span class="preprocessor">#define REMAINING_MEMORY                            (MEMORY_SIZE-REQ_FULL_ADDR)</span></div>
<div class="line"><span class="preprocessor">#define DATA_TO_WRITE                               (&amp;g_ui8I2CReceiveBuffer[2])</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The receive handler is called by the I2C port driver whenever a new</span></div>
<div class="line"><span class="comment">// packet was received.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> receiveHandler(uint16_t ui16Length)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Update the current memory location</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    uint8_t *pCurrMemoryLocation = &amp;g_ui8MemoryArray[REQ_FULL_ADDR];</div>
<div class="line">    I2CSlave_setTransmitBuffer(pCurrMemoryLocation, REMAINING_MEMORY);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// If there is data in the packet, write it into the memory</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">if</span> (ui16Length &gt; 2)</div>
<div class="line">    {</div>
<div class="line">        memcpy(pCurrMemoryLocation, DATA_TO_WRITE, (ui16Length-2));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// No need to wake the CPU, return false to exit asleep</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> errorHandler(uint8_t ui8Error)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// g_myI2CPort specifies the I2C Slave port configuration that is passed</span></div>
<div class="line"><span class="comment">// to I2CSlave_openPort().</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">const</span> tI2CSlavePort g_myI2CPort =</div>
<div class="line">{</div>
<div class="line">    .pbReceiveCallback = &amp;receiveHandler,</div>
<div class="line">    .pvErrorCallback = &amp;errorHandler,</div>
<div class="line">    .ui16ReceiveBufferSize = I2C_RECEIVE_BUFFER_SIZE,</div>
<div class="line">    .pReceiveBuffer = g_ui8I2CReceiveBuffer,</div>
<div class="line">    .bSendReadLengthFirst = <span class="keyword">false</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    WDT_A_hold(WDT_A_BASE);</div>
<div class="line">    PMM_unlockLPM5();</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Set P1.6 and P1.7 to UCB0SDA and UCB0SCL, respectively</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P1, GPIO_PIN2, GPIO_SECONDARY_MODULE_FUNCTION);</div>
<div class="line">    GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P1, GPIO_PIN3, GPIO_SECONDARY_MODULE_FUNCTION);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Enable masked interrupts</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    __bis_SR_register(GIE);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Open the I2C slave port</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    I2CSlave_openPort(&amp;g_myI2CPort);</div>
<div class="line">    I2CSlave_setTransmitBuffer(g_ui8MemoryArray, MEMORY_SIZE);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Application background loop</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Enter LPM3</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        LPM3;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><hr/>
 <h1><a class="anchor" id="ch_lib_benchmarks"></a>
Benchmarks</h1>
<p>This section contains benchmarks the CapTIvate&trade; Software Library as used in different applications.</p>
<h2><a class="anchor" id="ch_lib_benchmarks_memoryreq"></a>
Memory Requirements</h2>
<p>The CapTIvate Software Library is just one component of an application. At a minimum, an application will also require the following:</p><ul>
<li>MCU port muxing configuration (requires code space)</li>
<li>MCU clock configuration (requires code space)</li>
<li>CapTIvate configuration (requires code space)</li>
<li>A main routine (requires code space)</li>
<li>A call stack (requires data space)</li>
</ul>
<p>Therefore, when selecting the correct device it is important to consider the memory needs for the entire application and not just for CapTIvate.</p>
<h3>CODE (FRAM) and DATA (RAM) Requirements</h3>
<p>The following table illustrates the typical memory requirements for several different use-cases of the CapTIvate Software Library to aid in selecting the correct device for an application.</p>
<p>For each of these examples, the following assumptions were taken:</p><ul>
<li>CapTIvate Software Library and Starter Project v1.04.00.00 (September 2016)</li>
<li>A 256B call stack (CapTIvate examples default to a 256B call stack for application safety, this may be reduced)</li>
<li>MCU initialization via the CAPT_BSP module (configures GPIO and clocks)</li>
<li>CCS Toolchain (Compiler 15.12.1.LTS)</li>
<li>Optimization set to level 2 / size</li>
</ul>
<p>Sizes are shown with and without CapTIvate Design Center UART COMM support enabled. Enabling UART communications adds 1664B of FRAM and 389B of RAM with the default CapTIvate COMM configuration.</p>
<table class="doxtable">
<tr>
<th align="left">Example Case</th><th align="left">Sensor Configuration</th><th align="left">FRAM (B)</th><th align="left">RAM (B)</th><th align="left">FRAM (B) w/COMM</th><th align="left">RAM (B) w/COMM</th><th align="left">Recommended IC</th><th align="center">Comments  </th></tr>
<tr>
<td align="left">Basic touch switch</td><td align="left">1 button</td><td align="left">4200</td><td align="left">358</td><td align="left">5864</td><td align="left">747</td><td align="left">MSP430FR2532</td><td align="center"></td></tr>
<tr>
<td align="left">Basic touch switch with wake-on-prox</td><td align="left">1 button</td><td align="left">4634</td><td align="left">361</td><td align="left">6298</td><td align="left">750</td><td align="left">MSP430FR2532</td><td align="center">When adding wake-on-touch, FRAM increases. </td></tr>
<tr>
<td align="left">Basic touch switch with noise immunity</td><td align="left">1 button</td><td align="left">6594</td><td align="left">384</td><td align="left">8258</td><td align="left">773</td><td align="left">MSP430FR2532</td><td align="center">When adding noise immunity, RAM and FRAM increase. Some optimizations are required when communications are enabled. </td></tr>
<tr>
<td align="left">Numeric Keypad UI</td><td align="left">12 buttons</td><td align="left">4356</td><td align="left">722</td><td align="left">6020</td><td align="left">1111</td><td align="left">MSP430FR2532</td><td align="center">Main increase when adding buttons is RAM. </td></tr>
<tr>
<td align="left">Numeric Keypad UI with wake-on-prox</td><td align="left">12 buttons, 1 prox</td><td align="left">4850</td><td align="left">799</td><td align="left">6514</td><td align="left">1188</td><td align="left">MSP430FR2532</td><td align="center"></td></tr>
<tr>
<td align="left">Numeric Keypad UI with noise immunity</td><td align="left">12 buttons</td><td align="left">6750</td><td align="left">946</td><td align="left">8414</td><td align="left">1335</td><td align="left">MSP430FR2632</td><td align="center">Some optimizations are required when communications are enabled. </td></tr>
<tr>
<td align="left">32 button UI</td><td align="left">32 buttons</td><td align="left">4678</td><td align="left">1392</td><td align="left">6342</td><td align="left">1781</td><td align="left">MSP430FR2533</td><td align="center">&gt;16 buttons requires an FR2533 or FR2633 </td></tr>
<tr>
<td align="left">32 button UI with noise immunity</td><td align="left">32 buttons</td><td align="left">7074</td><td align="left">1976</td><td align="left">8738</td><td align="left">2365</td><td align="left">MSP430FR2633</td><td align="center"></td></tr>
<tr>
<td align="left">64 button UI</td><td align="left">64 buttons</td><td align="left">5178</td><td align="left">2464</td><td align="left">6842</td><td align="left">2853</td><td align="left">MSP430FR2633</td><td align="center"></td></tr>
<tr>
<td align="left">64 button UI with noise immunity</td><td align="left">64 buttons</td><td align="left">7570</td><td align="left">3624</td><td align="left">9234</td><td align="left">4013</td><td align="left">MSP430FR2633</td><td align="center"></td></tr>
</table>
<h3>Stack Requirements</h3>
<p>The worst-case stack usage for most applications running only the CapTIvate Touch Library is approximately 100B, with 30B of additional space required for interrupt service routines. Therefore, applications should have a minimum stack size of 100B+30B=130B. If callback functions are used, these may potentially increase the stack size requirement. A good, conservative estimate that is safe for many applications is a 256B stack. Every application will have its own unique stack requirements, with interrupt service routines being the largest unknown factor. Therefore it is recommended that each designer perform a worst-case stack usage analysis to determine the required stack size.</p>
<h2><a class="anchor" id="ch_lib_benchmarks_exectimes"></a>
Execution Times</h2>
<p>It is often of interest to understand the amount of time required to set up a measurement, perform the measurement, and process the measurement results. This total time (setup+measure+process) determines the overall scan rate that is achievable for a system. This section is intended to provide general guidance on typical execution times for the setup+measure+process sequence.</p>
<h3>Top Level - CAPT_updateUI()</h3>
<p><b>CAPT_updateUI()</b> is the top level user-interface update application. It handles the setup+measure+process sequence for all sensors in the user interface, and will transmit data via a serial interface if configured to do so. This is the easiest function to use as it includes all of the required processing. Below are several examples of execution times for the setup+measure+process sequence.</p>
<p>Test conditions:</p><ul>
<li>One button, one time cycle, one sensor</li>
<li>CAPTIVATE-BSWP demo panel</li>
<li>250 counts of measurement resolution at a 2 MHz conversion frequency for a 145us measurement time.</li>
<li>CPU frequency is 8 MHz</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">Function</th><th align="left">Total Time</th><th align="left">Setup Time</th><th align="left">Measurement Time</th><th align="left">Processing Time</th><th align="center">Notes  </th></tr>
<tr>
<td align="left">CAPT_updateUI(&amp;g_uiApp);</td><td align="left">0.723ms</td><td align="left">0.388ms</td><td align="left">0.145ms</td><td align="left">0.190ms</td><td align="center">LPM3 during conversion, bLpmControl=false </td></tr>
<tr>
<td align="left">CAPT_updateUI(&amp;g_uiApp);</td><td align="left">0.632ms</td><td align="left">0.297ms</td><td align="left">0.145ms</td><td align="left">0.190ms</td><td align="center">LPM3 during conversion, bLpmControl=true </td></tr>
<tr>
<td align="left">CAPT_updateUI(&amp;g_uiApp);</td><td align="left">0.626ms</td><td align="left">0.297ms</td><td align="left">0.145ms</td><td align="left">0.184ms</td><td align="center">LPM0 during conversion, bLpmControl=true </td></tr>
</table>
<p>In the first case, the CapTIvate peripheral was configured to turn off after each conversion. This means that before each conversion starts, there is an extra start-up time for the peripheral. Here that time measures to be approximately 0.1ms. Also note the difference between LPM3 and LPM0 in the second and third cases. It takes up to 0.010ms to wake up from LPM3 to active, whereas the LPM0 to active transition is less than 0.001ms.</p>
<h3>Sensor Level - CAPT_updateSensor()</h3>
<p><b>CAPT_updateSensor()</b> is the sensor-level update function. It handles the setup+measure+process sequence for a single sensor at time. It does not transmit data. This is an easy function to use if you want to control when a specific sensor is measured.</p>
<p>Test conditions:</p><ul>
<li>One button, one time cycle, one sensor</li>
<li>CAPTIVATE-BSWP demo panel</li>
<li>250 counts of measurement resolution at a 2 MHz conversion frequency for a 145us measurement time.</li>
<li>CPU frequency is 8 MHz</li>
<li>LPM0 during conversion, bLpmControl=false</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">Function</th><th align="left">Total Time</th><th align="left">Setup Time</th><th align="left">Measurement Time</th><th align="left">Processing Time</th><th align="center">Notes  </th></tr>
<tr>
<td align="left">CAPT_updateSensor(&amp;BTN00, CPUOFF);</td><td align="left">0.603ms</td><td align="left">0.293ms</td><td align="left">0.145ms</td><td align="left">0.165ms</td><td align="center">Full element and sensor processing performed </td></tr>
<tr>
<td align="left">CAPT_updateSensorRawCount(&amp;BTN00, eStandard, eNoOversampling, CPUOFF);</td><td align="left">0.514ms</td><td align="left">0.296ms</td><td align="left">0.145ms</td><td align="left">0.073ms</td><td align="center">No element or sensor processing performed </td></tr>
</table>
<h3>Low Level - CAPT_startConversionAndWaitUntilDone()</h3>
<p>Low level functions may be used to extract raw data. This is the most time efficient way to measure if there is only one sensor, because the sensor's parameters do not need to be re-loaded each time it is measured. This type of low-level conversion is only valuable for systems that have only 1 time cycle and are only looking to extract raw data with no post-processing.</p>
<p>The sequence to set up the sensor for measurement is as follows (run once):</p><ul>
<li>MAP_CAPT_applySensorParams(&amp;BTN00);</li>
<li>MAP_CAPT_applySensorFreq(CAPT_OSC_FREQ_DEFAULT, &amp;BTN00);</li>
</ul>
<p>The sequence to load the cycle, run, and extract the cycle's measurement data is as follows (run for each measurement):</p>
<ul>
<li>CAPT_loadCycle(&amp;BTN00, 0, CAPT_OSC_FREQ_DEFAULT, false);</li>
<li>CAPT_startConversionAndWaitUntilDone(CPUOFF);</li>
<li>CAPT_unloadCycle(&amp;BTN00, 0, CAPT_OSC_FREQ_DEFAULT, false);</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">Function</th><th align="left">Total Time</th><th align="left">Setup Time</th><th align="left">Measurement Time</th><th align="left">Processing Time</th><th align="center">Notes  </th></tr>
<tr>
<td align="left">Low Level</td><td align="left">0.243ms</td><td align="left">0.066</td><td align="left">0.145</td><td align="left">.032</td><td align="center">3 function calls </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<p>Copyright &#169; 2015, Texas Instruments Incorporated</p>	
    </li>
  </ul>
</div>
</body>
</html>
