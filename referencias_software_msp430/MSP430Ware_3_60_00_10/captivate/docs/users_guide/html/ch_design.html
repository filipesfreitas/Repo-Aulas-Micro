<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>CapTIvate&trade; Technology Guide: Design Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <img alt="Logo" width=25% src="ti_hz_2c_pos_rgb_png.png"/>
    <table cellspacing="0" cellpadding="0">
        <tbody>
        <tr style="height: 56px;">
            <td style="padding-left: 0.5em;">
                <div id="projectname">CapTIvate&trade; Technology Guide
                    &#160;<span id="projectnumber">v1.30.10.00</span>
                    <p><a href="http://www.ti.com/tool/msp-capt-fr2633">Purchase the kit now</a>
                    <br><a href="http://www.ti.com/captivate">Go to ti.com/CapTIvate</a></p>
                </div>
            </td>
        </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ch_design.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Design Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ch_design_intro"></a>
Introduction</h1>
<p>Capacitive touch detection is sometimes considered more art than science. This often results in multiple design iterations before the optimum performance is achieved. There are, however, good design practices for circuit layout and principles of materials that need to be understood to keep the number of iterations to a minimum.</p>
<p>Good sensor design are the foundation for a successful touch product. </p><div class="image">
<img src="design_products.png" alt="design_products.png"/>
</div>
 <p>The purpose of this design guide is to provide guidance for the design and layout of capacitive touch sensors so that they can achieve maximum performance. By achieving maximum performance in the hardware, the CapTIvate&trade; capacitive touch software library can perform the capacitive touch measurements consuming the lowest power. Tuning guides, along with the CapTIvate&trade; Design Center are used to help tune the performance of the capacitive touch application.</p>
<hr/>
 <h1><a class="anchor" id="ch_design_start"></a>
Starting a New Design</h1>
<p>Starting any new capacitive touch design can be a challenging task. This section will guide you through this process and help determine what is important for your design and end application.</p>
<p><b>Identify Sensors</b></p>
<p>First we want to identify the types of sensors that you are considering for your application and provide some basic design guidelines.</p><ul>
<li><a class="el" href="ch_design.html#ch_design_best_practices">Best Practices</a></li>
<li><a class="el" href="ch_design.html#ch_design_buttons">Buttons</a></li>
<li><a class="el" href="ch_design.html#ch_design_sliders_wheels">Sliders and Wheels</a></li>
<li><a class="el" href="ch_design.html#ch_design_proximity">Proximity</a></li>
</ul>
<p><b>Identify Care Abouts</b></p>
<p>Next it is important to identify any special requirements for the end application, such as low-power, noise immunity, moisture, etc.</p><ul>
<li><a class="el" href="ch_design.html#ch_design_low_power">Ultra Low Power</a></li>
<li><a class="el" href="ch_design.html#ch_design_moisture">Moisture</a></li>
<li><a class="el" href="ch_design.html#ch_design_noise">Noise</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="ch_design_process"></a>
Design Process</h1>
<p>Creating a reliable capacitive touch design can be a time consuming process that starts with designing sensors, laying out a PCB, writing lots of code and finally performing an iterative sensor tuning process to achieve the desired performance. The CapTIvate&trade; Technology sensor design process <em>accelerates</em> the capacitive touch development cycle through automation, helping get your product to market faster.</p>
<p><b>Creating a new sensor design</b> <br />
 We begin the process by creating a new capacitive touch design using the CapTIvate&trade; Design Center. With a few simple drag-n-drop inputs and configuration selections, the CapTIvate&trade; Design Center will automatically determine the optimal pin assignments between the target MCU and the sensors (CapTIvate&trade; Technology peripheral can measure four channels in parallel). Alternatively, connections can be manually assigned or reserved for those applications with specific routing requirements. </p><div class="image">
<img src="design_process_step1.png" alt="design_process_step1.png"/>
</div>
  <br />
 <br />
 <br />
</p>
<p><b>Layout PCB</b> <br />
 Once the pin assignments have been made, the MCU pin to sensor electrode connection information is exported to a .csv file and can be used during the PCB layout and design.</p>
<div class="image">
<img src="design_process_step2.png" alt="design_process_step2.png"/>
</div>
  <br />
 <br />
 <br />
</p>
<p><b>Generate configuration and starter project files</b> <br />
 Now we are ready to create a custom starter code project based on our sensor design. The CapTIvate&trade; Design Center creates a fully working capacitive touch application that can be imported into Texas Instruments Code Composer Studio (CCS) or IAR Embedded Workbench. In addition to the application, the CapTIvate&trade; Software Library and MSP430 driver-lib are automatically included with the project, as portions of the libraries are needed during the development cycle. </p><div class="image">
<img src="design_process_step3.png" alt="design_process_step3.png"/>
</div>
  <br />
 <br />
 <br />
</p>
<p><b>Program target MCU</b> <br />
 Import the generated CapTIvate&trade; project into Code Composer Studio or IAR IDE, compile and program the target MCU. The specific steps to perform the programming operation depend on the IDE, however, once the target MCU is programed, you are ready to start running your first capacitive touch application without having to write a <em>single line of code!</em></p>
<p>Didn't get it right the first time? Changes to a sensor design is simple. We use the CapTIvate&trade; Design Center to modify our sensor design project, then generate an updated configuration file. Simply copy the new configuration file and replace the existing one in the CCS or IAR application project and rebuild the application. That's it!</p>
<p><b>Tune Sensors</b> Our PCB is ready to go so we can now begin the process of tuning the sensors for the desired touch and feel. With the MCU programmed with our application and running, the sensors are scanned and real-time data is transmitted to the CapTIvate&trade; Design Center using the high-speed HID serial bridge MCU on the CAPTIVATE-PGMR PCB. The CapTIvate&trade; Design Center has several different views to display and monitor the sensor response and allow quick modifications in real-time to the sensor's parameters, providing instant feedback. </p><div class="image">
<img src="design_process_step4.png" alt="design_process_step4.png"/>
</div>
 <p><b>Generate final configuration</b> Once our desired touch and feel is achieved, the final sensor configuration can be generated and then programmed into the target MCU. That's it! Using the steps outlined above, capacitive sensor design time can be dramatically reduced.</p>
<p>_Congratulations! You are done with your design and ready to go to market.</p>
<hr/>
<h1><a class="anchor" id="ch_design_best_practices"></a>
Best Practices</h1>
<p>In this section we will cover both mechanical as well as common layout practices.</p>
<p>Capacitive touch detection is a type of analog-to-digital converter (ADC), specifically a capacitance-to- digital converter. As with most ADCs, the terms of interest are resolution, signal-to-noise ratio (SNR), and linearity, in the specific cases of wheels and sliders. Throughout this document, the design guidance helps to maximize signal, minimize noise, and address when these two goals are at odds.</p>
<p>As mentioned above, the basis of capacitive touch detection is the ability to measure a change in capacitance. This change in capacitance is the signal that the capacitive touch solution identifies. The term sensitivity is often used to describe the signal strength a more sensitive solution has a stronger signal.</p>
<p>Sensitivity is measured in capacitance per counts. In the context of capacitive touch detection, the magnitude of change introduced by a touch is on the order of picofarads or hundreds of femtofarads. It is not uncommon for a solution to see a touch introduce 1 pF of change and be measured as 300 counts. And while the sensitivity might be 3.3 fF/count, this should not be considered until the noise is factored in. Refer to the section on <a class="el" href="ch_design.html#ch_design_noise">Noise</a> below.</p>
<p>Sensitivity can be controlled within firmware, but the goal is to provide good sensitivity with the hardware, so that the lowest sensitivity settings can be used in firmware, which provides the lowest-power solution. Referring to the <a class="el" href="ch_basics.html#ch_basic_self_cap">Equivalent circuit</a> for a self capacitive sensor, C_touch must be maximized, while the other four capacitances must be minimized. The capacitances of the trace and electrode are approximated as parallel plate capacitances. The following equation serves as the basis for layout recommendations. </p>
<p>C = Er x E0 x A/d (1)</p>
<p>The dielectric constant (Er), area (A), and distance (d) are described throughout this document with the intent of positively influencing the capacitance for a touch system.</p>
<p>Although parasitic capacitance is presented separately, it is a part of the sensitivity and signal. As already mentioned, the capacitance of interest is the relative change in capacitance. The change in capacitance is based upon the touch interaction, but this change is perceived relative to the parasitic capacitance of the system. The parasitic capacitance is also called the steady-state capacitance or baseline capacitance. If the introduced change is 100 fF, then the sensitivity, which is the relative change in capacitance, can be increased by decreasing the parasitic capacitance.</p>
<p>The capacitances C_trace, C_electrode, and C_parasitics are generically referred to as parasitic capacitance.</p>
<h2><a class="anchor" id="ch_design_mechanicals"></a>
Mechanicals</h2>
<p>The mechanicals are the mechanical characteristics of the design. The mechanicals include the overlay material, ink on top of the overlay, any adhesives used to bond the electrode to the overlay or enclosure, and any transition materials used to remove air gaps between the electrode and the overlay. Mechanicals also include the types of materials used for the electrodes. The mechanicals affect both the signal and the parasitic capacitance.</p>
<p>The goal of this section is threefold:</p><ol type="1">
<li>To understand the benefits in terms of both aesthetics and robustness</li>
<li>To understand how the materials on top of the electrode and the electrode material itself influence the layout of the electrodes</li>
<li>To avoid mistakes in the mechanicals that are detrimental to the electrical performance</li>
</ol>
<h3>Typical Stackup</h3>
<p>The following figure shows a typical stackup for a capacitive touch solution. One of the main goals of this stackup is to reduce (or eliminate, if possible) any low-dielectric (air) gaps between the electrode and the area where the touch takes place. The capacitance associated with the stackup has a very strong effect on the signal (change in capacitance from a touch). The signal is directly proportional to the dielectric of the materials. If possible, high-dielectric materials should be used, but at a minimum the stackup should eliminate any air gaps.</p>
<ul>
<li>Air gaps can also contain moisture, which can influence performance or even damage the stackup as temperatures vary and the contents of the gap expand and contract.</li>
</ul>
<div class="image">
<img src="design_material_stackup.png" alt="design_material_stackup.png"/>
<div class="caption">
Typical Material Stackup</div></div>
  <p>Another critical attribute of the stackup is that it should be non-conductive. This is not usually a problem with the overlay material but can be overlooked when choosing adhesives, labels, or inks. Popular adhesives for capacitive touch solutions include 200MP products from 3M&trade; such as 467MP and 468MP.</p>
<h3>Overlay</h3>
<p>The capacitance of the stackup is a superposition of all of the material, but the overlay is often the dominant material. The type and dimension of the overlay material that is used is determined by the desired aesthetic and from the required amount of protection. A common requirement is rugged (scratch or puncture resistant) and yet lightweight.</p>
<p>The following figure shows the relationship between the thickness of the overlay and the sensitivity of the circuit. From the parallel plate capacitance equation, the capacitance in inversely proportional to the material thickness (C ~ 1/d). </p><div class="image">
<img src="design_plot.png" alt="design_plot.png"/>
<div class="caption">
Sensitivity vs Thickness</div></div>
  <p>The thickness and dielectric of the material influence the electrode design. The electrode area is a function of the area of interaction (a fingertip or the palm of the hand) while the spacing (to adjacent electrodes or ground fill) is related to the thickness of the overlay. For example, with a 2-mm overlay that has a dielectric of 3, the spacing should be approximately 1 mm (half of the thickness). Using a higher dielectric material (for example, Er = 6) the thickness could be doubled while maintaining the same level of performance. The following table shows dielectric values for various materials used as overlays.</p>
<p>Table: Material Dielectric and Breakdown Voltage</p>
<table class="doxtable">
<tr>
<th align="left">Material</th><th align="left">Dielectric Constant (Er) (1)</th><th align="left">Breakdown Voltage (V/mm)  </th></tr>
<tr>
<td align="left">Air</td><td align="left">1.0</td><td align="left">3300 (STP) </td></tr>
<tr>
<td align="left">FR-4</td><td align="left">4.8</td><td align="left">20000 </td></tr>
<tr>
<td align="left">Glass</td><td align="left">7.6 to 8.0</td><td align="left">7900 </td></tr>
<tr>
<td align="left">Gorilla&amp;reg Glass</td><td align="left">7.2 to 7.6</td><td align="left">See Manufacturer (2) </td></tr>
<tr>
<td align="left">Polycarbonate</td><td align="left">2.9 to 3.0</td><td align="left">16000 </td></tr>
<tr>
<td align="left">Acrylic</td><td align="left">2.8</td><td align="left">13000 </td></tr>
<tr>
<td align="left">ABS</td><td align="left">2.4 to 4.1</td><td align="left">16000 </td></tr>
</table>
<p>(1) Relative permittivity</p>
<p>(2) <a href="http://www.corninggorillaglass.com">http://www.corninggorillaglass.com</a></p>
<p>The table above also includes the breakdown voltage for different overlay materials. This should be considered when designed for ESD protection. ESD solutions should be system solutions, and any additional components should complement the protection provided by the overlay.</p>
<h3>Electrode and Trace Materials</h3>
<p>The performance is affected by the conductive materials that are used for the electrode and for the trace between the electrode and the microcontroller. Most applications use copper on a PCB, and copper has a resistivity of 1.7x10-6 Ohm-cm (3). As the resistivity of the conductor increases, the ability to move charge to and from the electrode decreases. This has the same effect as an increase in parasitic capacitance. This increase in resistivity, like an increase in parasitic capacitance, reduces the system sensitivity. The table below shows the resistivity for materials that are commonly used in touch applications.</p>
<p>(3) Resistivity is given in Ohm-cm so that resistance is equal to the resistivity times the length divided by the cross-sectional area : R = p x L / A.</p>
<p>Table: Resistivity of Materials</p>
<table class="doxtable">
<tr>
<th align="left">Material</th><th align="left">Resistivity, p (Ohm-cm)  </th></tr>
<tr>
<td align="left">Copper</td><td align="left">1.68x10-6 </td></tr>
<tr>
<td align="left">Silver</td><td align="left">1.59x10-6 </td></tr>
<tr>
<td align="left">Tin</td><td align="left">1.09x10-5 </td></tr>
<tr>
<td align="left">Indium Tin Oxide</td><td align="left">1.05x10-3 (1) </td></tr>
</table>
<p>(1) This resistivity is for a film thickness of 270 nm. Typically, vendors provide sheet resistance instead of resistivity for ITO, which is on the order of 10 to 100 Ohms per square.</p>
<p>When using high-resistivity materials, generally the recommendation is to increase the area of traces to reduce the resistance (at the cost of capacitance). ITO solutions provide lower sensitivity, which must be compensated for in the capacitance measurement algorithm by longer measurement times.</p>
<h2>Other Situations</h2>
<p>Not all applications fit into the typical category, and this section describes two special cases. The first is intentional air gaps that are greater than 2 mm between the electrode and the overlay material, and the second is the use of gloves.</p>
<h3>Gaps</h3>
<p>In some applications, components are on the same layer as the electrode. This prevents the overlay from being directly applied to the electrode. A common example of this is when an LCD is mounted near the electrode (see diagram below). Another scenario is when the overlay material is not a uniform surface and, therefore, the electrode cannot make direct contact with the overlay.</p>
<div class="image">
<img src="design_gaps.png" alt="design_gaps.png"/>
<div class="caption">
Intentional Gaps Between Electrode and Overlay</div></div>
  <p>In either case, the gap must be filled or bridged with a non-conductive filler (typically adhesive) or a conductive extension. When the gap is in excess of 2 mm, then a conductive extension, either foam or metal, should be used. The metal or foam must be malleable to conform to the shape of the surfaces and prevent the formation of gaps. As shown in the Figure above, the area created by the foam or metal in contact with the overlay is now the area that influences the capacitance.</p>
<h3>Gloves</h3>
<p>Gloves are simply another layer of medium between the electrode and the finger, and the same principles of thickness and dielectric apply. The challenges with glove applications include the ability to support both gloved and ungloved hands as well as the variation in the types of gloves the application might require. Typical leather or plastic gloves have a dielectric constant in the range of 2 to 4, and fabric gloves and gloves with insulation can have a dielectric constant less than 2.</p>
<hr/>
 <h2><a class="anchor" id="ch_design_common"></a>
Common Layout Considerations</h2>
<p>After the mechanicals are understood, the electrodes can be sized and designed to provide the most signal. Independent of the mechanicals, the layout design is affected by the distance between the microcontroller and the electrodes, the PCB stackup (for example, one layer, two layer, or four layer), and other electrical circuits on the PCB.</p>
<p>The first item to consider relates to the schematic and the placement of any external components that are associated with the capacitive touch solution. A typical example is ESD protection components such as a series current limiting resistor. In all cases, the components should be kept as close as possible to the microcontroller. As the components move farther away from the microcontroller, the increased area correlates to an increased risk of noise or ESD conducting into the device.</p>
<h3><a class="anchor" id="ch_design_common_routing"></a>
Routing</h3>
<p>The parasitic capacitance of the trace comprises several major and minor capacitance contributors. For simplicity, C_trace represents the major capacitances formed between the trace line and the ground pour on the bottom side and surrounding it. The top and cross-sectional views of a typical two layer PCB are shown in Figure 6. The capacitance, C_trace, is determined by the trace line width (W), dielectric thickness (H), trace thickness (T), and the relative permittivity of the PCB material (Er).</p>
<div class="image">
<img src="design_routing.png" alt="design_routing.png"/>
<div class="caption">
Top and Cross-Sectional Views of Trace Line in PCB</div></div>
  <p>The capacitance per unit length of the trace is an important concept to emphasize the need for short traces. Increasing the distance of the trace increases the parasitic capacitance associated with the trace. Increasing the trace length can also increase susceptibility to noise. Therefore, the trace routing between the microcontroller and the electrode should be kept as short as possible. This is not always possible, so it is important to understand the increase in parasitic capacitance associated with the trace routing.</p>
<h4>Capacitance per Unit Length</h4>
<p>The capacitance per unit length should be kept as small as possible to minimize the parasitic capacitance (C_trace) and ultimately maximize sensitivity. As previously mentioned, the dominant capacitance in C_trace is the parallel plate capacitance between the trace and the surrounding ground pour. The ability to reduce this capacitance is a direct function of the PCB manufacturing capabilities. Tighter tolerances and smaller minimum dimensions (trace width and separation) allow for thinner traces and larger separation, which result in lower capacitance per unit length. These manufacturing capabilities typically come at a higher cost.</p>
<p>The table below shows how the capacitance per unit length changes with the variation of different dimensions. These values are taken from <a class="el" href="ch_design.html#ch_design_references">Reference Section</a> in the Coplanar Waveguide Analysis/Synthesis Calculators.</p>
<p>Table: Calculating Results of Capacitance per Unit Length</p>
<table class="doxtable">
<tr>
<th align="left">W (mm) </th><th align="left">S (mm) </th><th align="left">T (mm) </th><th align="left">H (mm) </th><th align="left">Er </th><th align="left">C (pF/cm)  </th></tr>
<tr>
<td align="left">0.152</td><td align="left">0.152</td><td align="left">0.036</td><td align="left">1.6</td><td align="left">4.6</td><td align="left">0.633 </td></tr>
<tr>
<td align="left">0.152</td><td align="left">0.254</td><td align="left">0.036</td><td align="left">1.6</td><td align="left">4.6</td><td align="left">0.555 </td></tr>
<tr>
<td align="left">0.152</td><td align="left">0.381</td><td align="left">0.036</td><td align="left">1.6</td><td align="left">4.6</td><td align="left">0.496 </td></tr>
<tr>
<td align="left">0.203</td><td align="left">0.152</td><td align="left">0.036</td><td align="left">1.6</td><td align="left">4.6</td><td align="left">0.692 </td></tr>
<tr>
<td align="left">0.203</td><td align="left">0.254</td><td align="left">0.036</td><td align="left">1.6</td><td align="left">4.6</td><td align="left">0.602 </td></tr>
<tr>
<td align="left">0.203</td><td align="left">0.381</td><td align="left">0.036</td><td align="left">1.6</td><td align="left">4.6</td><td align="left">0.543 </td></tr>
<tr>
<td align="left">0.254</td><td align="left">0.152</td><td align="left">0.036</td><td align="left">1.6</td><td align="left">4.6</td><td align="left">0.740 </td></tr>
<tr>
<td align="left">0.254</td><td align="left">0.254</td><td align="left">0.036</td><td align="left">1.6</td><td align="left">4.6</td><td align="left">0.641 </td></tr>
<tr>
<td align="left">0.254</td><td align="left">0.381</td><td align="left">0.036</td><td align="left">1.6</td><td align="left">4.6</td><td align="left">0.578 </td></tr>
<tr>
<td align="left">0.254</td><td align="left">0.152</td><td align="left">0.036</td><td align="left">2.54</td><td align="left">4.6</td><td align="left">0.736 </td></tr>
<tr>
<td align="left">0.254</td><td align="left">0.254</td><td align="left">0.036</td><td align="left">2.54</td><td align="left">4.6</td><td align="left">0.637 </td></tr>
<tr>
<td align="left">0.254</td><td align="left">0.381</td><td align="left">0.036</td><td align="left">2.54</td><td align="left">4.6</td><td align="left">0.566 </td></tr>
</table>
<p>The table above shows that increasing the space, S, between the trace line and the ground is an effective way to reduce the parasitic capacitance. However, increasing the separation can have negative effects that need to be understood. One effect is simply increased board space. Increasing the dimensions can lead to larger PCBs and higher cost. Another effect is related to noise. The larger separation makes traces more sensitive to touch events (touching the trace instead of the electrode) and more susceptible to radiated emissions.</p>
<p>In practice, the designer should choose a balanced S value, and a value of 1/8 of the overlay thickness is typically acceptable. Additionally, a hatched ground is commonly used instead of solid fill near the trace lines to reduce the area and consequently the parasitic capacitance.</p>
<p>The table above also shows that as H gets smaller, the parasitic capacitance increases, which results in a decrease in sensitivity. In most applications, a two-layer PCB is used, and a standard FR4 PCB with the thickness of 1 mm to 1.6 mm is recommended. If a multilayer board is used, it is recommended to keep the H as large as possible. With complex multilayer boards (more than six layers), it is important to recognize that the absence of copper in the internal layers can cause issues and the height, H, between the top layer and the bottom may be smaller than predicted.</p>
<p>The figure below shows an example of a four-layer PCB, which may be desired in applications with limited board space. To reduce parasitic capacitance, the ground pour is usually placed on the lowest layer underneath the trace to provide the largest H. If it is difficult to achieve the maximum height, then a narrower W, a larger S, or even a hatched ground fill are alternatives to reducing the parasitic capacitance.</p>
<div class="image">
<img src="design_multilayer_pcb.png" alt="design_multilayer_pcb.png"/>
<div class="caption">
Trace Without Copper Pouring Underneath in Multilayer PCB</div></div>
  <p>To determine the maximum trace length from the capacitance per unit length, some additional information is needed. The following example is used to calculate the maximum distance for a trace with a capacitance per unit length of 0.58 pF/cm. The capacitance introduced by a touch, C_touch, is assumed to be approximately 1 pF. To make sure that the capacitance induced by a finger is large relative to the parasitic capacitance, the total parasitic capacitance (C_parasitics, C_trace, and C_electrode) should be in the range of 10 pF to 20 pF (the change is at least a 5% change). Assuming that the C_electrode is approximately 3 pF, the C_parasitics is 5 pF, and the capacitance per unit length is 0.58 pF/cm, so the trace line length L should be no longer than 210 mm. If the electrode is larger (for a proximity application), the capacitance itself is larger (assume approximately 8 pF for this example), so the maximum trace line length L is reduced to 120 mm.</p>
<p>Generally speaking, the trace width W should be as thin as the PCB technology allows, because a short and narrow trace line is preferred. The trace thickness T and the relative permittivity of the material Er also have significant influence on capacitance per unit length, but they are determined by PCB manufacture process and are usually difficult to change.</p>
<h4>Connectors</h4>
<p>Some designs require the electrode to be off-board, and consequently a connector is used to transition the trace from the PCB to a cable or to another PCB. Connectors are generally not desired because like any component there is an associated parasitic capacitance with connector PCB footprint and structure.</p>
<p>In terms of parasitic capacitance and sensitivity, the connector is treated as a parasitic capacitance reducing the sensitivity of the solution. Because the connector is treated as a lumped capacitance, the placement is irrelevant to the sensitivity. However, the placement is important with respect to noise.</p>
<p>The figure below shows that if the aggressor (noise source, N1) is located on the PCB, then the preferred placement of the connector is near the MSP430 microcontroller. The parasitic capacitance associated with the connector shunts high-frequency noise (Z 1/jwC) and increases the noise immunity of the circuit. Conversely, if the aggressor is located off-board (noise source, N2), then the connector should be placed farther from the microcontroller and closer to the electrode. This arrangement minimizes the off-board trace and cable length (which acts like an antenna). When multiple aggressors exist as is shown in the figure below, it is recommended to reduce the effect of the radiators that most closely match the operating frequency of the touch detection circuit.</p>
<div class="image">
<img src="design_connectors.png" alt="design_connectors.png"/>
<div class="caption">
Top View of Connector and Noise Source</div></div>
  <p>When deciding the position of the connector, the designer must balance the length of the trace and the cable while considering parameters like the background noise.</p>
<h3>Routing Material</h3>
<p>The routing is typically done with copper, but other materials like silver and ITO can be used. Silver is similar to copper and similar performance can be expected (if the thickness of the materials are also equivalent). ITO is very different from copper, and the difference in resistivity degrades the sensitivity of the solution. Lowering the impedance of the trace (by increasing the width) should be a high priority in the design, even though this comes at the cost of increased parasitic capacitance and reduced noise immunity. Ultimately, the use of materials like ITO requires more processing by the MSP430 microcontroller to adjust to lower sensitivity and increased noise.</p>
<h3><a class="anchor" id="ch_design_self_electrode_material"></a>
Electrode Material</h3>
<p>As discussed in the <a class="el" href="ch_design.html#ch_design_common_routing">Routing section</a>, conductivity becomes an issue in more resistive materials like ITO. Although the transparency of ITO is very good, the resistivity is high when compared to materials like silver and copper. Typically the physical dimensions prohibit increasing the area of the ITO electrodes, and therefore any degradation in sensitivity must be compensated for in the firmware. This typically results in slightly longer measurement times and consequently increased power consumption.</p>
<h3>Electrode Design</h3>
<p>The electrode design must accomplish two goals. First, the design must provide sufficient signal (change in capacitance with interaction). The design must project the e-field up and out so that the appropriate level of sensitivity is achieved at the desired distance. Understanding the stackup, thickness and dielectric, the electrode can be sized and shaped to provide the maximum signal. Second, the electrode design needs to have a minimal parasitic capacitance.</p>
<p>In the following sections the shape and area of the electrode are discussed with the intent of maximizing the signal for different implementations (buttons, sliders, and wheels). The basis for controlling the parasitic capacitance is common to different sensor implementations and is discussed here.</p>
<p>The figure below shows an example PCB cross-section and the important parameters that influence the parasitic capacitance. The height, width, and separation have a direct effect on the parasitic capacitance of the electrode, C_electrode. The fundamental parameter area is not shown in the figure below because this has a direct effect on both the touch capacitance (C_touch) and the parasitic capacitance (C_electrode). This section describes how changes to the height and separation can minimize the parasitic capacitance. The following sections describe how changes to the area can maximize C_touch.</p>
<div class="image">
<img src="design_electrode_capacitance.png" alt="design_electrode_capacitance.png"/>
<div class="caption">
Capacitance of the Electrode</div></div>
  <p>The separation (S_electrode) is directly related to the height of the overlay as described in the <a class="el" href="ch_design.html#ch_design_mechanicals">Mechanical section</a>. The height is a function of the PCB and is not a parameter that can be easily controlled. The separation is typically the parameter with the most flexibility.</p>
<p>Table: Baseline Electrode Capacitance</p>
<table class="doxtable">
<tr>
<th align="left">Area(mm2)</th><th align="left">Height(mm)</th><th align="left">Description</th><th align="left">Separation(mm)</th><th align="left">Capacitance(pF)  </th></tr>
<tr>
<td align="left">10x10, FR-4 (Er = 4.4)</td><td align="left">1.572</td><td align="left">2 Layer PCB, L2</td><td align="left">0.508</td><td align="left">3.3 </td></tr>
<tr>
<td align="left">10x10, FR-4 (Er = 4.4)</td><td align="left">1.572</td><td align="left">2 Layer PCB, L2</td><td align="left">1.02</td><td align="left">3.2 </td></tr>
<tr>
<td align="left">10x10, FR-4 (Er = 4.4)</td><td align="left">1.572</td><td align="left">2 Layer PCB, L2</td><td align="left">1.52</td><td align="left">3.1 </td></tr>
<tr>
<td align="left">10x10, FR-4 (Er = 4.4)</td><td align="left">1.30</td><td align="left">4 Layer PCB, L2</td><td align="left">0.508</td><td align="left">3.8 </td></tr>
<tr>
<td align="left">10x10, FR-4 (Er = 4.4)</td><td align="left">1.57</td><td align="left">4 Layer PCB, L3</td><td align="left">0.508</td><td align="left">3.3 </td></tr>
</table>
<p>The table above shows that increasing the height (the distance between the electrode and the reference plane) decreases the capacitance. By decreasing the parasitic capacitance, the relative change in capacitance caused by a touch event is increased. For example, if the change in capacitance associated with a touch is 0.5 pF, the relative change is greater when the base capacitance is 11 pF instead of 12 pF, (5.5% instead of 4.2%).</p>
<h3><a class="anchor" id="ch_design_self_electrode_spacing"></a>
Spacing Between Electrodes</h3>
<p>By default, the CapTIvate&trade; Software Library drives non-actively scanned electrodes to ground allowing neighboring electrodes to be treated as an extension of the ground pour. Therefore, the spacing between the electrodes follows the same rules for spacing from ground. The goal is provide enough spacing so that the e-field propagates up and through the overlay material. A minimum spacing of one-half the laminate thickness has been found to provide sufficient signal (sensitivity).</p>
<h3><a class="anchor" id="ch_design_self_shape"></a>
Shapes</h3>
<p>The capacitance of the electrode is a function of area, but the shape is important to consider, because the shape can influence the area. An important detail of designing the electrode shape is not to design shapes that have low surface area. The area of each electrode must provide the maximum C_touch, which in turn produces the most signal (the change in capacitance) when a touch event occurs.</p>
<h3><a class="anchor" id="ch_design_common_crosstalk"></a>
Crosstalk</h3>
<p>In the Connectors section above, the aggressor is assumed to be a point source of noise. In this section, the aggressors are different signals that are routed in close proximity to the capacitive touch sensor trace. These aggressors can be another capacitance sensor trace or non-capacitance sensor lines. Examples of non-capacitance sensor lines include digital signals, analog signals, and high-current signals used to drive LEDs.</p>
<h3><a class="anchor" id="ch_design_common_other"></a>
Adjacent Capacitive Touch Signals</h3>
<p>Capacitive sensor traces influence neighboring capacitive touch sensor traces. The space between capacitance sensor trace lines, Scs, should be kept as a safe distance (see figure below).</p>
<div class="image">
<img src="design_traces_spacing.png" alt="design_traces_spacing.png"/>
<div class="caption">
Top View of Different Traces</div></div>
   <br />
 <br />
 <br />
</p>
<h3><a class="anchor" id="ch_design_common_digital_signals"></a>
Digital Signals</h3>
<p>Digital signals are typically PWM signals or communications like I2C or SPI. Unlike the capacitive traces, these signals can act as aggressors and can be active during a capacitance measurement. It is recommended to keep these types of signals at least 4 mm away from the capacitive touch trace. If the digital signal and the capacitive touch trace must cross, then it is recommended to keep the crossing at a 90 degree angle. </p><div class="image">
<img src="design_traces_digital.png" alt="design_traces_digital.png"/>
<div class="caption">
Top View of Different Traces</div></div>
   <br />
 <br />
 <br />
</p>
<h3><a class="anchor" id="ch_design_common_leds"></a>
LEDs/LED Backlighting</h3>
<p>Signals used to drive LEDs (unless the LEDs require high-strength drivers) are similar to other digital signals. As with digital signals, a distance of at least 4 mm is strongly recommended for S_LED as shown in the figure below. </p><div class="image">
<img src="design_traces_leds.png" alt="design_traces_leds.png"/>
<div class="caption">
Top View of Different Traces</div></div>
   <br />
 <br />
 <br />
</p>
<p>As a general rule, LEDs should be driven and the use of high-impedance states should not be used to control the LED. The use of a high impedance to prevent an LED from conducting can result in a significant difference between the on-state and off-state capacitances. This change in capacitance may be detected by the touch solution and treated as a change in the system capacitance, or even worse as a false detection. If the use of high-impedance control of the LED is unavoidable, a discrete capacitor (typically 1 nF is acceptable) in parallel with the LED is recommended.</p>
<ul>
<li>Avoid tri-stating the LED as the LED capacitance will change when turned on and off</li>
<li>If LED must be tri-stated, add small bypass capacitor to control change in LED capacitance</li>
<li>Capacitor does not have to be physically near LED, just in the circuit</li>
</ul>
<div class="image">
<img src="design_backlighting2.png" alt="design_backlighting2.png"/>
<div class="caption">
Recommended methods to drive LEDs</div></div>
  <p>LED BackLighting can be done easily using a back lighting LED on the opposite side of the PCB</p><ul>
<li>Keep hole as small as possible to eliminate possible dead spots in sensor</li>
<li>LEDs may require bypass capacitor (see above)</li>
</ul>
<div class="image">
<img src="design_backlighting1.png" alt="design_backlighting1.png"/>
<div class="caption">
Backlighting LEDs</div></div>
   <br />
 <br />
 <br />
</p>
<p>As an example of an LED backlighting technique, the following wheel design has an LED mounted on the backside of the PCB and illuminates through a small hole. In parallel to the LED, a small 1nF capacitor is used to reject changes in capacitance when the LED is switched between ground and high-Z. Also note the hatched ground on both the top and bottom layers to help with noise immunity. </p><div class="image">
<img src="design_mutual_led_backlight.png" alt="design_mutual_led_backlight.png"/>
<div class="caption">
LED BackLight Example</div></div>
   <br />
 <br />
 <br />
</p>
<h3><a class="anchor" id="ch_design_self_ground_planes"></a>
Ground Planes</h3>
<p>Surrounding ground planes affect the sensitivity of the electrode. This is seen primarily as an increase in base capacitance as the separation from the ground decreases and the area of the ground pour increases. This section looks at the placement of surrounding ground pours and the fill (percent hatch) of those pours.</p>
<p>Planes and pours near the electrode and trace must be connected to a potential and cannot be left floating or in a high impedance state. Such structures serve as a mechanism for noise coupling and are strongly discouraged.</p>
<h3><a class="anchor" id="ch_design_self_ground_separation"></a>
Separation</h3>
<p>Ground planes, both coplanar and on neighboring PCB layers, reduce noise. This is the same principle discussed in the <a class="el" href="ch_design.html#ch_design_common_routing">Routing section</a>. The ground or guard structures are placed as close as possible to reduce noise but also kept far enough away to minimize parasitic capacitance. This separation is a function of the thickness of the materials (overlay, adhesive, etc.) on top of the trace. As mentioned in the <a class="el" href="ch_design.html#ch_design_common_routing">Routing section</a>, a good rule is one-eighth the thickness for separation between traces and ground. The separation between electrodes and ground should be at least one-half the thickness.</p>
<div class="image">
<img src="design_ground_separation.png" alt="design_ground_separation.png"/>
<div class="caption">
Ground Separation</div></div>
   <br />
 <br />
 <br />
</p>
<p>As shown in the figure above, the separation between the electrode and the coplanar ground pour should be at least one half the thickness of the overlay material. Any unused electrode should be held at a logic low level (Vss potential) and not allowed to float. In this way the spacing between electrodes is the same as the ground and electrode distance.</p>
<h3><a class="anchor" id="ch_design_self_ground_pour"></a>
Pour</h3>
<p>The use of a hatched pour instead of a solid ground pour is a good design practice. This reduces the area and consequently the parasitic capacitance associated with both C_trace and C_electrode. Typically, a 25% fill hatch is sufficient, but this percentage can be increased or decreased to improve noise immunity or sensitivity, respectively.</p>
<div class="image">
<img src="design_hatched_gnd_fill.png" alt="design_hatched_gnd_fill.png"/>
<div class="caption">
Example Hatched Ground Fill</div></div>
   <br />
 <br />
 <br />
</p>
<h3>Using Poly Cut Out to control Ground Pour around Sensors</h3>
<p>When designing a button, slider or wheel of any size or shape, a flexible method to control the distance between any sensor and the ground pour is to provide a poly cut-out region around the sensor as shown below. </p><div class="image">
<img src="design_mutual_buttons_poly_cut.png" alt="design_mutual_buttons_poly_cut.png"/>
<div class="caption">
Define Poly Cut Out Region</div></div>
   <br />
 <br />
 <br />
</p>
<div class="image">
<img src="design_mutual_buttons_poly_cut_plane.png" alt="design_mutual_buttons_poly_cut_plane.png"/>
<div class="caption">
Ground Pour Spacing Controlled</div></div>
   <br />
 <br />
 <br />
</p>
<h3><a class="anchor" id="ch_design_mutual_routing"></a>
Mutual Capacitance Traces</h3>
<p>Routing mutual capacitive traces has special considerations compared to self capacitive traces. Specifically, the TX and RX signals on the same layer should be close only in those areas where coupling through a finger touch is expected by design, such as the case with button, slider or wheel elements (electrodes). Anywhere else that TX and RX traces on the same layer are routed close can be susceptible to a "ghost" touch should a finger touch in that area.</p>
<h4>Traces</h4>
<ul>
<li>Avoid routing TX lines near RX lines when possible<ul>
<li>Within a finger spacing, they will create a button</li>
<li>If unable to avoid on same layer, put ground trace in between (adds parasitic capacitance)</li>
<li>If TX needs to cross RX, make crossing perpendicular (minimize surface area intersection)</li>
<li>Avoid running TX on one layer of PCB parallel to RX on other layer of PCB</li>
</ul>
</li>
<li>Route TX lines next to other TX lines</li>
<li>Route RX lines next to other RX lines</li>
<li>Keep nearby ground away from TX and RX traces by 1/2 panel thickness (reduces parasitic capacitance)</li>
</ul>
<p>The diagram below shows an 8-button keypad using (2) TX and (4) RX traces. In this layout the TX and RX traces are on the same layer. The TX traces are routed close to each other as are the RX traces. The TX traces are routed away from the RX traces. In this example there is one RX that must be routed near a TX trace. A ground trace/fill is used to separate the RX an TX traces. </p><div class="image">
<img src="design_mutual_mcu.png" alt="design_mutual_mcu.png"/>
<div class="caption">
Routing mutual capacitance sensors</div></div>
   <br />
 <br />
 <br />
 </p><h4>Electrodes</h4>
<ul>
<li>For noise suppression, use 25% hatched ground on:<ul>
<li>Bottom layer of PCB and/or</li>
<li>On top layer of PCB keeping ground 1/2 panel thickness away from electrode</li>
</ul>
</li>
</ul>
<hr/>
<h1><a class="anchor" id="ch_design_buttons"></a>
Buttons</h1>
<h2><a class="anchor" id="ch_design_self_buttons"></a>
Self Capacitive Buttons</h2>
<p>A self capacitive button sensor is a single electrode. Self capacitive buttons are simple to layout and each button is assigned to only one pin on the MCU. Self capacitive buttons will provide greater sensitivity as compared to a mutual capacitive button, but are more influenced by parasitic capacitances to ground.</p>
<table class="doxtable">
<tr>
<th align="left">Parameter</th><th align="left">Guidance  </th></tr>
<tr>
<td align="left">Radiation Pattern</td><td align="left">Between Electrode and Ground </td></tr>
<tr>
<td align="left">Size</td><td align="left">Equivalent to interaction </td></tr>
<tr>
<td align="left">Shape</td><td align="left">Various: typically round or square </td></tr>
<tr>
<td align="left">Spacing</td><td align="left">0.5 x Overlay minimum thickness </td></tr>
</table>
<div class="image">
<img src="design_self_buttons_finger.png" alt="design_self_buttons_finger.png"/>
<div class="caption">
Example Self Capacitive Button Designs</div></div>
   <br />
 <br />
 <br />
</p>
<h3><a class="anchor" id="ch_design_self_button_shape"></a>
Self Capacitive Button Shapes</h3>
<p>The electrode shape is typically rectangular or round with common sizes of 10mm and 12mm. Ultimately, the size will depend on the required touch area. A good design practice is to keep the size of the button as small as possible, which minimizes the capacitance and will help with the following:</p>
<ul>
<li>Reduce susceptibility to noise</li>
<li>Improve sensitivity</li>
<li>Lower power operation due to smaller capacitance and reduced electrode scan time</li>
</ul>
<p>In the diagram below, an example silkscreen button outline pattern is shown. </p><div class="image">
<img src="design_self_buttons.png" alt="design_self_buttons.png"/>
<div class="caption">
Example Self Capacitive Button Designs</div></div>
   <br />
 <br />
 <br />
 The goal of the button area is to provide sufficient signal when the user touches the overlay above the button electrode. Typically a nonconductive decal or ink is used to identify the touch area above the electrode. The relationship between the decal and the electrode can be varied so that contact with the outer edge of the decal registers a touch. Conversely, the electrode could be small to ensure that the button is activated only when the center of the decal is touched. The two figures below show how the effective touch area is a function of the electrode size and the size of the finger. </p><div class="image">
<img src="design_larger_than_decal.png" alt="design_larger_than_decal.png"/>
<div class="caption">
Effective Area Example for Electrodes Larger Than Decal</div></div>
   <br />
 <br />
 <br />
 </p><div class="image">
<img src="design_smaller_than_decal.png" alt="design_smaller_than_decal.png"/>
<div class="caption">
Effective Area Example for Electrode Smaller Than Decal</div></div>
   <br />
 <br />
 <br />
</p>
<p>One common mistake is to make the electrode the same shape as the icons printed (in nonconductive ink) on the overlay. As shown in the figure below, this can lead to electrodes with odd shapes that create discontinuities and reduce surface area.</p>
<div class="image">
<img src="design_buttons.png" alt="design_buttons.png"/>
<div class="caption">
Button Shape Examples, Dos and Don'ts</div></div>
   <br />
 <br />
 <br />
 As the distance of the overlay increases, the effective area decreases. Therefore, it is important to keep the button electrode diameter at least three times the laminate thickness.</p>
<p><br />
 <br />
 <br />
 </p>
<h2><a class="anchor" id="ch_design_mutual_buttons"></a>
Mutual Capacitive Buttons</h2>
<p>A mutual or "projected" capacitive button sensor requires two electrodes, one as a TX and the other for RX. Mutual capacitive buttons are not as sensitive as self capacitive buttons, however, it is possible to pack the electrodes closer together with a low risk of cross talk between neighboring electrodes. With mutual capacitive electrodes, multi-touch is possible by multiplexing the channels. Multiplexing creates up to 64 electrode pairs or "buttons" that can be scanned using only 16 CapTIvate&trade; I/O pins.</p>
<table class="doxtable">
<tr>
<th align="left">Parameter</th><th align="left">Guidance  </th></tr>
<tr>
<td align="left">Radiation Pattern</td><td align="left">Between TX and RX and ground </td></tr>
<tr>
<td align="left">Size</td><td align="left">Equivalent to interaction </td></tr>
<tr>
<td align="left">Shape</td><td align="left">Various: recommend square or shape with corners </td></tr>
<tr>
<td align="left">Spacing</td><td align="left">0.5 x Overlay minimum </td></tr>
</table>
<div class="image">
<img src="design_mutual_buttons_finger.png" alt="design_mutual_buttons_finger.png"/>
<div class="caption">
Example Mutual Capacitive Button Designs</div></div>
   <br />
 <br />
 <br />
</p>
<h3><a class="anchor" id="ch_design_mutual_button_shape"></a>
Mutual Capacitive Button Shapes</h3>
<p>The electrode shape is typically rectangular with common sizes being 10mm and smaller. Ultimately, the size will depend on the required touch area. In the diagram below, the TX and RX electrodes are identified and a suggested silkscreen button outline pattern is shown. The position of the vias on the TX and RX electrodes provide flexible signal connection points when routing traces.</p>
<ul>
<li>Simple Square Electrode<ul>
<li>Easiest to layout</li>
<li>Highest sensitivity</li>
<li>TX on outside, RX on inside</li>
<li>For single layer designs, can open TX on one side and feed RX trace through (preferably not in a corner)</li>
<li>Better sensitivity if traces on two layers</li>
</ul>
</li>
</ul>
<div class="image">
<img src="design_mutual_buttons.png" alt="design_mutual_buttons.png"/>
<div class="caption">
Example 10mm Mutual Capacitive Button Design)</div></div>
   <br />
 <br />
 <br />
 A good design practice is to keep the size of the button as small as possible, which minimizes the capacitance and will help with the following:</p>
<ul>
<li>Reduce susceptibility to noise</li>
<li>Improve sensitivity</li>
<li>Lower power operation due to smaller capacitance and reduced electrode scan time</li>
</ul>
<p>The dimensions shown on a 10mm x 10mm example button are suitable for overlay thickness up to 2mm.</p>
<div class="image">
<img src="design_mutual_buttons_dimensions.png" alt="design_mutual_buttons_dimensions.png"/>
<div class="caption">
10mm Mutual Capacitive Button Dimensions</div></div>
   <br />
 <br />
 <br />
</p>
<p>An alternative button design, which can provide better sensitivity and is slightly more difficult to create, forces the e-field lines to be concentrated in the four RX corners. </p><div class="image">
<img src="design_mutual_buttons_boost.png" alt="design_mutual_buttons_boost.png"/>
<div class="caption">
Alternative Mutual Capacitive Button Design</div></div>
   <br />
 <br />
 <br />
</p>
<p>The dimensions shown for this 10mm x 10mm example button are suitable for overlay thickness up to 2mm.</p>
<div class="image">
<img src="design_mutual_buttons_dimensions_boost.png" alt="design_mutual_buttons_dimensions_boost.png"/>
<div class="caption">
10mm Mutual Capacitive Button Dimensions</div></div>
   <br />
 <br />
 <br />
</p>
<p>To accommodate the individual RX connections in this design, vias on each RX electrode allow the four electrodes to be connected on the bottom PCB layer as shown. The four vias provide convenient connection points when sharing an RX channel with neighboring button sensors or to simplify overall trace routing. </p><div class="image">
<img src="design_mutual_buttons_boost_connections.png" alt="design_mutual_buttons_boost_connections.png"/>
<div class="caption">
RX Electrodes Bottom Layer Connections</div></div>
   <br />
 <br />
 <br />
</p>
<h4>Mutual Capacitive TX / RX Electrode Spacing Considerations</h4>
<p>For thicker overlays, the spacing between the TX and RX is related to the thickness of the overlay and should be maintained at 0.5 x overlay thickness. The reason is the coupling that occurs between the outer TX electrode and the inner RX electrode is affected by the separation distance between these electrodes. In the diagram below, TX and RX traces that have larger spacing between them will build a field that extends further out compared to TX and RX traces that are closer together. With TX and RX traces close together, it may not be possible to work reliably with a thick overlay. So to accommodate a thicker overlay, the design requires the TX and RX traces to be moved further apart. There may be some design limitations that restrict the overall button size, so experimentation maybe required to meet the TX and RX spacing recommendations.</p>
<div class="image">
<img src="design_mutual_button_flux_spacing.png" alt="design_mutual_button_flux_spacing.png"/>
<div class="caption">
Example Mutual Capacitive Button Designs</div></div>
   <br />
 <br />
 <br />
</p>
<p>As mentioned earlier, mutual capacitive electrodes can be multiplexed with other mutual capacitive electrodes. This means that more than one button can share a common signal. In the 8-button example below, the design of the button and placement of vias allow for easy routing to the neighboring buttons. Depending on the orientation of the routing signals, the buttons could be rotated if needed. Taking advantage of CapTIvate&trade; Technology hardware feature allowing up to four channels to be scanned in parallel, the top four RX channels are measured while TX_0 is driven. The sequence is then repeated for the bottom row. Scanning four channels in parallel reduces the device's overall power by reducing the scan time by 4x and it should become apparent that the eight buttons were measured with only six CapTIvate&trade; I/O pins.</p>
<div class="image">
<img src="design_mutual_buttons_multiplexed.png" alt="design_mutual_buttons_multiplexed.png"/>
<div class="caption">
8-Button Multiplexed Mutual Capacitive Example Design</div></div>
   <br />
 <br />
 <br />
</p>
<hr/>
 <h1><a class="anchor" id="ch_design_sliders_wheels"></a>
Sliders and Wheels</h1>
<p>Sliders and wheels are multi-electrode sensors. Sliders and wheels with as few as three or four electrodes can provide excellent performance. The CapTIvate&trade; Software Library supports both sliders and wheels, ranging from 3 to 12 electrodes. While it is certainly possible to use as many electrodes, the layout becomes more difficult, requires more MCU RX pins and generally does not improve the sensor's performance. A powerful feature of CapTIvate&trade; Technology is the ability to scan 4 electrodes in parallel. Optimizing a sensor to take advantage of this hardware feature for a slider or wheel provides the best power and measurement time efficiency.</p>
<p>For both sliders and wheels, the area of the electrode is not as critical as the percentage of coverage across multiple electrodes. As shown in the examples below, interdigitated slider and wheel designs provide the most efficient and optimal coupling, but can be complicated to create. Simpler designs are possible, but require experimentation.</p>
<p>For reference, several self and mutual capacitive slider and wheel sensors examples are illustrated throughout this section and are the same sensors used on the CAPTIVATE-BSWP and CAPTIVATE-PHONE demo PCBs.</p>
<h2><a class="anchor" id="ch_design_slider_wheel_resolution"></a>
Slider and Wheel Resolution</h2>
<p>CapTIvate&trade; Technology's increased sensitivity combined with the CapTIvate&trade; Software Library provide exceptional linearity and accuracy for slider and wheel resolutions well beyond 10-bit of resolution. By following the design guidelines and examples that follow in this section, designing a slider or wheel with great performance is easy.</p>
<h3>A Note About Resolution vs. Number of Positions</h3>
<p>For sliders and wheels, the number of discrete positions = the resolution, but because 0 is included as a position, the reported range of positions covers from 0 to (resolution - 1). As an example, if a slider or wheel has a resolution of 1000, the sensor will report 1000 positions, from 0 to 999.</p>
<h2><a class="anchor" id="ch_design_self_slider_wheel"></a>
Self Capacitive Sensor Shapes</h2>
<p>In general, self capacitive sensors are also easy to design and route on a PCB. Due to the nature of self-capacitance, self capacitive sliders and wheels have higher sensitivity compared to mutual capacitive sliders and wheels. For that reason they should be considered as a first choice when designing an application. However, self capacitive sensors require one CapTIvate&trade; I/O pin for each electrode.</p>
<h3><a class="anchor" id="ch_design_self_slider"></a>
Self Capacitive Slider</h3>
<p>As mentioned above, a self capacitive slider with great performance can be designed with only three or four electrodes depending the size of the sensor. In fact, a 30cm slider using only four electrodes has been successfully demonstrated with superior linearity and resolution. A basic slider design below uses four RX electrodes. Each electrode is interdigitated and the two end electrodes are electrically connected. <br />
 <br />
</p>
<div class="image">
<img src="design_self_slider.png" alt="design_self_slider.png"/>
<div class="caption">
Example 4-Element Slider Design</div></div>
   <br />
 <br />
 <br />
</p>
<h3><a class="anchor" id="ch_design_self_wheel"></a>
Self Capacitive Wheel</h3>
<p>A wheel is basically a slider design with both ends wrapped around and connected together. With CapTIvate&trade; Technology, a self capacitive wheel only needs three elements to provide exceptional linearity and resolution. A basic wheel design below uses three RX channels. Each electrode is interdigitated. </p><div class="image">
<img src="design_self_wheel.png" alt="design_self_wheel.png"/>
<div class="caption">
Example 3-Element Wheel Design</div></div>
   <br />
 <br />
 <br />
</p>
<h2><a class="anchor" id="ch_design_mutual_slider_wheel"></a>
Mutual Capacitive Sensor Shapes</h2>
<p>Mutual capacitance has a unique feature that allows sensors to multiplexed. Mutual capacitive sliders and wheels can take advantage of this feature by sharing several RX channels with one or more sensors. Because of this, it is possible to have up to 64 electrodes using 16 CapTIvate&trade; I/O pins. As mentioned earlier, mutual capacitive sensor doesn't have the same sensitivity as a self capacitive slider or wheel. However, with CapTIvate&trade; Technology, mutual capacitive sliders and wheels will provide the same performance as self capacitive sensors.</p>
<h3><a class="anchor" id="ch_design_mutual_slider"></a>
Mutual Capacitive Slider</h3>
<p>The following diagram illustrates a four element slider. The outer TX electrode traces surround the interdigitated RX electrodes and are connected together at both ends of the slider. This simple slider design uses four RX and one TX channels. </p><div class="image">
<img src="design_mutual_slider.png" alt="design_mutual_slider.png"/>
<div class="caption">
4 Element Slider Design</div></div>
  <ul>
<li>TX on outside (track on top and bottom)</li>
<li>RX on inside as triangles</li>
<li>Spacing from TX to RX is 1/2 the overlay thickness</li>
<li>1st and last RX triangle connected to each other</li>
<li>Spacing between TX and RX ~0.5mm</li>
</ul>
<h3><a class="anchor" id="ch_design_mutual_wheel"></a>
Mutual Capacitive Wheel</h3>
<p>The diagram below illustrates a basic 3 element wheel design. The wheel has two TX circle electrodes surrounding the interdigitated RX electrodes. The wheel is basically a slider design with both ends wrapped around and connected together. This wheel design uses three RX and one TX channels. </p><div class="image">
<img src="design_mutual_wheel.png" alt="design_mutual_wheel.png"/>
<div class="caption">
3 Element Wheel Design</div></div>
  <ul>
<li>TX Circles on outside and inside of wheel (Need to connect inside and outside together on backside of board)</li>
<li>RX as interdigitated patterns (similar to Self Capacitance Wheel)</li>
<li>Spacing between TX and RX ~1/2 overlay thickness</li>
<li>Ground hatch added inside wheel to provide noise stability. Also ok to have hatching on backside of board. (be careful of total ground loading</li>
<li>Possible to include LED/LED backlight in the center</li>
<li>Difficult to draw</li>
</ul>
<p>As a variation to the design above, the open portion of the wheel on the top PCB layer can be filled with either a solid or hatched ground to improve noise immunity. Providing a additional hatched ground on the bottom layer of the PCB will also help with noise. Using a solid ground on the bottom layer may present too much capacitive loading, so be careful. </p><div class="image">
<img src="design_mutual_wheel_center_ground.png" alt="design_mutual_wheel_center_ground.png"/>
<div class="caption">
3 Element Wheel Design with Center Grounded</div></div>
   <br />
 <br />
 <br />
</p>
<h3>Mutual Capacitive Wheel with Center Button</h3>
<p>A great feature to add is a separate "button" sensor inside the wheel sensor, if size permits. The design is the same as the basic wheel but a ground separation trace is added between the wheel electrodes and button electrodes. This helps prevent cross talk between the two sensors, should a finger wander slightly off the wheel sensor. This wheel design with center button uses three RX channels and one TX channel for the wheel, one RX and TX channel for the button. </p><div class="image">
<img src="design_mutual_wheel_button.png" alt="design_mutual_wheel_button.png"/>
<div class="caption">
3 Element Wheel Design with Center Button Sensor</div></div>
   <br />
 <br />
 <br />
</p>
<h3>Mutual Capacitive Wheel with Center LEDs</h3>
<p>Similar to the wheel design with a button in the center, it is simple to add a backlighted LED as illustrated in the next diagram. This wheel design with center LED uses three RX channels and one TX channel for the wheel. The LED is driven separately. For additional information about LEDs, refer to <a class="el" href="ch_design.html#ch_design_common_leds">LEDs and Backlighting</a>.</p>
<div class="image">
<img src="design_mutual_wheel_led.png" alt="design_mutual_wheel_led.png"/>
<div class="caption">
3 Element Wheel Design with Center LED</div></div>
   <br />
 <br />
 <br />
</p>
<hr/>
 <h1><a class="anchor" id="ch_design_proximity"></a>
Proximity</h1>
<p>Proximity sensors are electrodes designed to detect a hand or other conductive object at some distance using greater sensitivity compared to buttons, sliders or wheels. For this reason, proximity sensors are self capacitive and can have one or more electrodes.</p>
<h2><a class="anchor" id="ch_design_proximity_shapes"></a>
Proximity Shapes</h2>
<p>Proximity electrodes can be any shape and for most applications the electrode size is limited by the end product dimensions. As an example, the CAPTIVATE-BSWP Demo PCB with its proximity sensor highlighted in RED is shown below. As mentioned above, proximity sensors require a higher degree of sensitivity than buttons, and this higher sensitivity can be achieved by:</p><ul>
<li>Increasing the area</li>
<li>Separation from other conductors.</li>
</ul>
<div class="image">
<img src="design_proximity_bswp.png" alt="design_proximity_bswp.png"/>
<div class="caption">
CAPTIVATE-BSWP Demo PCB Proximity Sensor</div></div>
   <br />
 <br />
 <br />
 Proximity sensors typically have a larger area in order to detect large surfaces (palm of the hand) at larger distances. When considering the size of the proximity electrode, keep in mind that as size increases, so does parasitic capacitance. And with an increase in capacitance, there is in increase in measurement times which can directly translate into higher power consumption. So there needs to be a careful balance between size, sensitivity and power.</p>
<h2>Proximity Ground and Shielding</h2>
<p>In a perfect design, without any parasitic capacitances, a proximity sensor's e-field can extend a great distance, providing incredible sensitivity. The field lines will flow from the electrode to any nearby ground potential and can include a nearby hand or earth ground. </p><div class="image">
<img src="design_proximity_no_parasitic.png" alt="design_proximity_no_parasitic.png"/>
<div class="caption">
PCB with Minimal Parasitic Capacitances</div></div>
   <br />
 <br />
 <br />
</p>
<p>Unfortunately, it is almost impossible to avoid having some ground potential on a PCB, so some charge is stolen away from the proximity sensor, reducing the sensor's sensitivity and detection distance.</p>
<div class="image">
<img src="design_proximity_small_parasitic.png" alt="design_proximity_small_parasitic.png"/>
<div class="caption">
PCB with Typical Parasitic Capacitances</div></div>
   <br />
 <br />
 <br />
</p>
<p>One must be careful to avoid designs with excessive ground potentials. In some applications, where electrical noise is an issue, ground planes on top and bottom layers are in place to help shield circuits from potential noise sources. However, these very same ground planes that protect against noise now provide a very easy path to steal even more charge away from the proximity sensor, making proximity detection very difficult or even impossible. </p><div class="image">
<img src="design_proximity_large_parasitic.png" alt="design_proximity_large_parasitic.png"/>
<div class="caption">
PCB with Large Parasitic Capacitances</div></div>
   <br />
 <br />
 <br />
</p>
<p>One method to control the amount of parasitic capacitance to nearby ground is through the use of a driven shield. By replacing the dedicated ground plane with a plane driven by an additional CapTIvate&trade; I/O pin, the plane can be grounded through the I/O pin when the proximity sensor is not active. When driving the proximity sensor, the shield is also driven at the same potential. Any remaining parasitic capacitance to other ground potentials will steal charge from the shield and with minimal impact to proximity sensor's sensitivity. This minimizes the parasitic capacitance and restores the proximity sensor's sensitivity. </p><div class="image">
<img src="design_proximity_driven_shield.png" alt="design_proximity_driven_shield.png"/>
<div class="caption">
PCB with Large Parasitic Capacitances</div></div>
   <br />
 <br />
 <br />
</p>
<hr/>
 <h1><a class="anchor" id="ch_design_low_power"></a>
Ultra Low Power</h1>
<p>The MSP430 CapTIvate&trade; peripheral is capable of enabling user interface designs with extremely low power consumption. This is possible because the CapTIvate&trade; peripheral includes a processing state machine that is capable of performing the following functions from LPM3 without any CPU interaction whatsoever:</p>
<ol type="1">
<li>Wake up the CapTIvate measurement blocks from deep sleep (LPM3) at a periodic interval</li>
<li>Start a conversion automatically (1 electrode per measurement block, or 4 electrodes on the MSP430FR2633)</li>
<li>Finish the conversion</li>
<li>Perform IIR noise filtering (adjustable strength)</li>
<li>Perform a threshold crossing detection (adjustable window comparator)</li>
<li>If a threshold was crossed, wake up the CPU</li>
<li>Otherwise, perform environmental drift compensation (adjustable strength)</li>
<li>Shut down the CapTIvate measurement blocks and wait until the next interval, then go back to #1</li>
</ol>
<p>This capability combined with the MSP430 FRAM low power architecture enables designs with average current in the single digit microamps.</p>
<h2><a class="anchor" id="ch_design_low_power_intro"></a>
Introduction</h2>
<p>Designing for low power consumption involves optimizing the hardware and the tuning to achieve 5 basic things:</p><ol type="1">
<li>The lowest <a class="el" href="ch_design.html#ch_design_low_power_optimization">base LPM3 current</a> possible</li>
<li>The slowest <a class="el" href="ch_Glossary.html#ch_glossary_system_report_rate">UI refresh rate</a> possible (software design)</li>
<li>The smallest <a class="el" href="ch_basics.html#ch_basic_self_parasitics">parasitic capacitance</a> possible (hardware design)</li>
<li>The shortest <a class="el" href="ch_Glossary.html#ch_glossary_time_estimation">measurement time</a> possible (hardware and software design)</li>
<li>The most effective use of the wake-on-proximity state machine</li>
</ol>
<p>In short, achieving the lowest possible power consumption is all about optimizing the duty cycle of the application - <b>minimizing the amount of time that the CPU and high performance analog are awake, and maximizing the amount of time spent in deep sleep</b>.</p>
<h2><a class="anchor" id="ch_design_low_power_expectations"></a>
Expectations</h2>
<p>Below are several test cases that have been bench verified with the MSP430FR2633 on the CAPTIVATE-FR2633 processor module.</p>
<table class="doxtable">
<tr>
<th align="left">Sensor Configuration</th><th align="left">Mode</th><th align="left">Method</th><th align="left">Scan Rate</th><th align="left">Base Scan Time</th><th align="left">LF Clock</th><th align="left">I-avg</th><th align="left">I-avg / Electrode</th><th align="left">Years on AAAs</th><th align="left">Years on a CR2032  </th></tr>
<tr>
<td align="left">1 Proximity Sensor</td><td align="left">Wake-on-Proximity</td><td align="left">Self</td><td align="left">8 Hz</td><td align="left">420us</td><td align="left">Crystal</td><td align="left">5uA</td><td align="left">5uA</td><td align="left">16</td><td align="left">3.6 </td></tr>
<tr>
<td align="left">1 Proximity Sensor</td><td align="left">Active (CPU)</td><td align="left">Self</td><td align="left">8 Hz</td><td align="left">420us</td><td align="left">Crystal</td><td align="left">7.3uA</td><td align="left">7.3uA</td><td align="left">10.9</td><td align="left">2.5 </td></tr>
<tr>
<td align="left">1 Button</td><td align="left">Wake-on-Proximity</td><td align="left">Self</td><td align="left">8 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">3.4uA</td><td align="left">3.4uA</td><td align="left">23.5</td><td align="left">5.3 </td></tr>
<tr>
<td align="left">1 Button</td><td align="left">Active (CPU)</td><td align="left">Self</td><td align="left">8 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">6.0uA</td><td align="left">6.0uA</td><td align="left">13.3</td><td align="left">3.0 </td></tr>
<tr>
<td align="left">4 Buttons</td><td align="left">Wake-on-Proximity</td><td align="left">Self</td><td align="left">8 Hz</td><td align="left">120us</td><td align="left">Crystal</td><td align="left">3.0uA</td><td align="left">750nA</td><td align="left">26</td><td align="left">6.0 </td></tr>
<tr>
<td align="left">4 Buttons</td><td align="left">Wake-on-Proximity</td><td align="left">Self</td><td align="left">8 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">3.8uA</td><td align="left">0.9uA</td><td align="left">21</td><td align="left">4.7 </td></tr>
<tr>
<td align="left">4 Buttons</td><td align="left">Wake-on-Proximity</td><td align="left">Self</td><td align="left">30 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">9.4uA</td><td align="left">2.4uA</td><td align="left">8.5</td><td align="left">1.9 </td></tr>
<tr>
<td align="left">4 Buttons</td><td align="left">Active (CPU)</td><td align="left">Self</td><td align="left">8 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">8.7uA</td><td align="left">2.2uA</td><td align="left">9.2</td><td align="left">2.1 </td></tr>
<tr>
<td align="left">8 Buttons</td><td align="left">Active (CPU)</td><td align="left">Self</td><td align="left">8 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">14.5uA</td><td align="left">1.8uA</td><td align="left">5.5</td><td align="left">1.2 </td></tr>
<tr>
<td align="left">8 Buttons</td><td align="left">Active (CPU)</td><td align="left">Self</td><td align="left">15 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">25.9uA</td><td align="left">3.2uA</td><td align="left">3.0</td><td align="left">0.7 </td></tr>
<tr>
<td align="left">8 Buttons</td><td align="left">Active (CPU)</td><td align="left">Self</td><td align="left">30 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">50.1uA</td><td align="left">6.3uA</td><td align="left">1.5</td><td align="left">0.3 </td></tr>
<tr>
<td align="left">64 Buttons</td><td align="left">Active (CPU)</td><td align="left">Mutual</td><td align="left">8 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">109.2uA</td><td align="left">1.7uA</td><td align="left">0.7</td><td align="left">0.2 </td></tr>
<tr>
<td align="left">64 Buttons</td><td align="left">Active (CPU)</td><td align="left">Mutual</td><td align="left">15 Hz</td><td align="left">145us</td><td align="left">Crystal</td><td align="left">203.5uA</td><td align="left">3.0uA</td><td align="left">0.35</td><td align="left">0.08 </td></tr>
</table>
<p>Note: These measurements were captured using a high resolution source-meter with UART/I2C communications disabled. Battery life was approximated assuming 1000mAh AAA's and 225mAh CR2032 cells with 70% effective usable life.</p>
<div class="image">
<img src="design_poweranalyzer.png" alt="design_poweranalyzer.png"/>
<div class="caption">
Power Characterization Bench</div></div>
  <p>Note how the wake-on-proximity state machine is able to increase the battery life by over a year on a CR2032 coin cell for the proximity sensor, and over 2 years for a basic button.</p>
<h2><a class="anchor" id="ch_design_low_power_optimization"></a>
Optimization Steps</h2>
<p>The following sections discuss how to optimize the design to achieve the 5 goals introduced above.</p>
<h3><a class="anchor" id="ch_design_low_power_optimization_clock"></a>
Selecting a Low Frequency Clock</h3>
<p>The lowest power consumption achievable is limited by the deep sleep current consumption of the MCU. From there, power consumption will rise with the complexity of the panel and rate at which the panel is scanned. In deep sleep (low power mode 3), since it is not possible to achieve a lower average current than the LPM3 current, the low frequency clock that is selected for the application must be considered. Below are the low frequency clock options available for the MSP430FR2633 MCU.</p>
<table class="doxtable">
<tr>
<th align="left">LF Clock Source</th><th align="left">Typical LPM3 Base Current</th><th align="left">Typical Frequency</th><th align="left">Typical Relative Accuracy</th><th align="left">Typical Relative Cost  </th></tr>
<tr>
<td align="left">Crystal</td><td align="left">1.2uA</td><td align="left">32768 Hz</td><td align="left">Best</td><td align="left">External Component (Highest) </td></tr>
<tr>
<td align="left">REFO</td><td align="left">16uA</td><td align="left">32768 Hz</td><td align="left">Good</td><td align="left">Internal (Lowest) </td></tr>
<tr>
<td align="left">VLO</td><td align="left">1uA</td><td align="left">10000 Hz</td><td align="left">Poor</td><td align="left">Internal (Lowest) </td></tr>
</table>
<ul>
<li>If budget and PCB space constraints allow for it, an external 32 kHz crystal provides the best combination of accuracy and low power.</li>
<li>If accuracy is still required but an external crystal cannot be used, then the REFO will provide a decent 32 kHz time base at the expense of higher power consumption.</li>
<li>If an external crystal cannot be used and accuracy is not application critical, than the VLO provides the lowest possible power.</li>
</ul>
<h4>Using the VLO in Wake-on-Proximity Mode</h4>
<p>The CAPT_App layer of the <a class="el" href="ch_lib.html#ch_lib_gettingstarted_starterproj">Starter Project</a> contains a provision for using the VLO as the clock source to the CapTIvate timer. This may be desirable for applications that require very low power but cannot use a crystal for some reason. When the VLO is used as the clock source for the CapTIvate timer, it is possible to run CapTIvate's wake-on-proximity mode while in LPM4, rather than the typical LPM3. When in LPM4, ACLK is turned off completely. This means that if the REFO was the ACLK source, the REFO will also be shut down in LPM4, lowering average power consumption. To enable the VLO+LPM4 combination when in wake-on-proximity mode, define CAPT_WOP_VLO_LPM4 at the top of CAPT_App.c. This will cause the application low power mode to switch to LPM4 when in the wake-on-proximity state. It will also set up the CapTIvate timer to run off of the VLO when in the wake-on-proximity state. Once the application wakes back up and the UI switches to active mode, ACLK and LPM3 will again be used to ensure timing accuracy.</p>
<p>While the VLO can provide low power consumption without the use of a crystal, it is not as accurate as a crystal. Designers should be aware that the VLO clock frequency can drift considerably with voltage and temperature. See the device specific datasheet for more details. The variance in the VLO clock frequency can show up as a change in the response time of the application. For example, of the frequency drifts low, CapTIvate touch sensors may take longer than usual to respond. Likewise, if the frequency drifts high, sensors may respond faster than usual. In the second case, the power consumption may also be higher than expected because the sensors are being measured more frequently than intended. It is possible to improve the usage of the VLO by implementing a calibration routine that trims the scan interval setting by comparing the VLO to a more accurate clock (such as the REFO).</p>
<h3><a class="anchor" id="ch_design_low_power_optimization_scanperiod"></a>
Optimizing the Application Scan Period</h3>
<p>The application <a class="el" href="ch_Glossary.html#ch_glossary_system_report_rate">scan period</a> is the amount of time between each sampling of the user interface. For example, if the period is set to 100ms, then the user interface is sampled every 100ms, or at a rate of 10Hz. If the period is set to 10ms, then the user interface is sampled at a rate of 100Hz. The scan period has a direct effect on the power consumption, as it controls the duty cycle of the application. When a lower period (higher rate) is selected, the CapTIvate analog and possibly the CPU are waking up much more frequently- consuming more power. The design tradeoff here is response time versus power consumption. Scanning less often reduces the power consumption, but also increases the response time of the user interface. The CapTIvate&trade; starter project implements an active mode scan rate and a wake-on-proximity scan rate. This allows for a longer response time to be used when no one is touching the panel, and a shorter response time to be used when someone is touching the panel. The <a class="el" href="ch_evm.html#ch_evm_get_started_sensorpanels_bswp">CAPTIVATE-BSWP</a> demo panel runs at 10 Hz (100ms response time) when in wake-on-proximity mode, and at 30 Hz (33ms response time) when in active mode.</p>
<h3><a class="anchor" id="ch_design_low_power_optimization_parasitics"></a>
Optimizing for the Smallest Parasitic Capacitance</h3>
<p>When a sensor has a low <a class="el" href="ch_basics.html#ch_basic_self_parasitics">parasitic capacitance</a>, it is more sensitive to touch (all else being equal). This means that the sensor may be scanned at a lower resolution to obtain the same resolution and SNR. A lower resolution conversion means a lower measurement time. Battery powered applications typically do not have the same noise immunity requirements as line powered applications, so solid ground fills that limit sensitivity are generally not required. In addition, when sensors have low parasitic capacitance the conversion frequency may be increased while still ensuring good charge transfer.</p>
<h3><a class="anchor" id="ch_design_low_power_optimization_meastime"></a>
Optimizing for the Shortest Measurement Time</h3>
<p>The measurement time for each sensor should be optimized to be as small as possible. When the CapTIvate&trade; analog IP is operational, it draws several 100uA of current. The goal should be to minimize the measurement time so that the analog is only enabled for a brief period of time.</p>
<p>In the CapTIvate&trade; Design Center, the measurement time is a function of the following factors:</p><ol type="1">
<li><a class="el" href="ch_Glossary.html#ch_glossary_frequency_divider">Frequency Divider</a> (Conversion clock frequency selection)</li>
<li><a class="el" href="ch_Glossary.html#ch_glossary_phase_lengths">Phase Lengths</a></li>
<li><a class="el" href="ch_Glossary.html#ch_glossary_conversion_count">Conversion Count</a> (Base number of charge transfers without a touch)</li>
</ol>
<p>The measurement time may be calculated manually per the following formula. It is also <a class="el" href="ch_Glossary.html#ch_glossary_time_estimation">calculated automatically</a> in the CapTIvate&trade; Design Center.</p>
<div class="image">
<img src="design_scantime_formula.png" alt="design_scantime_formula.png"/>
<div class="caption">
Scan Time Calculation</div></div>
  <p><b>Constants</b></p><ul>
<li>STABLETIME=320</li>
<li>CAPOSC[0]=16000000</li>
<li>CAPOSC[1]=14700000</li>
<li>CAPOSC[2]=13100000</li>
<li>CAPOSC[3]=11200000</li>
</ul>
<p>If the sensors have fairly low parasitic capacitance, a conversion frequency of 2MHz for self capacitance and 4MHz for mutual capacitance is a reasonable setting. With phase lengths of 1, this is achieved by setting the frequency divider to /4 and /2, respectively.</p>
<p>The <a class="el" href="ch_Glossary.html#ch_glossary_conversion_count">conversion count</a> controls the resolution of the measurement. Decreasing this value decreases the overall resolution of the measurement (in terms of counts per picofarad). To optimize the resolution, decrease this value until the minimum acceptable delta due to a touch is reached.</p>
<h3><a class="anchor" id="ch_design_low_power_optimization_statemachine"></a>
Using the Wake-on-Proximity State Machine Effectively</h3>
<p>The wake-on-proximity state machine allows for CPU-less measurement and processing for 1 element per measurement block (4 elements total with the MSP430FR2633). Most sensing panels are actually touched &lt;1% of the total time that they are running. 99% or more of the time, they are waiting for a user. The state machine provides a mechanism to handle the latter 99% without the need to involve the CPU, reducing the average current. A sensor may be <a class="el" href="DesignCenter.html#ch_cdc_UsersGuide_sec03_compile_options">selected as a wake-on-proximity sensor</a> in the CapTIvate&trade; Design Center. When a sensor is selected, the starter project that is generated by the CapTIvate&trade; Design Center will transition into a wake-on-proximity mode whenever the inactivity timeout counter expires. In wake-on-proximity mode, the first cycle of the sensor that was selected for wake-on-proximity will be automatically measured by the state machine, and the CPU will not receive an interrupt until one of the following occurs:</p>
<ol type="1">
<li>A proximity or negative touch threshold crossing occurs</li>
<li>A conversion counter interrupt occurs</li>
</ol>
<p>The wake-on-proximity feature is best used with longer-range proximity sensors, such as the one on the <a class="el" href="ch_evm.html#ch_evm_get_started_sensorpanels_bswp">CAPTIVATE-BSWP</a> demo panel. However, if an MSP430FR2633 design has 4 buttons or less, it is possible to use the wake-on-proximity state machine functionality to wake up on any of the four buttons!</p>
<h2><a class="anchor" id="ch_design_low_power_example"></a>
Walking Through the Optimization Process</h2>
<p>In this example, the CAPTIVATE-BSWP panel will be used as a piece of test hardware to look at how to optimize an imaginary application that has 4 buttons. From start to finish, going through this exercise will transform the average current of the solution from 100's of microamps to single digit microamps. To run the completed example, check out the <a class="el" href="ch_evm.html#ch_evm_get_started_sensorpanels_bswp_bonus_ulp4btn">UltraLowPower_4Button</a> example project.</p>
<h3>Step 1: Creating a New Project</h3>
<p>To start, a new CapTIvate&trade; Design Center project will be created that has a button group sensor with 4 buttons. The buttons will be on CAP0.0, CAP1.0, CAP2.0, and CAP3.0. This mapping allows for parallel scanning, which is important for power optimization. All of the default tuning parameters will be kept initially:</p>
<table class="doxtable">
<tr>
<th align="left">Parameter</th><th align="left">Value</th><th align="left">Optimized?  </th></tr>
<tr>
<td align="left">COMM Peripheral</td><td align="left">UART</td><td align="left">No </td></tr>
<tr>
<td align="left">Active Scan Rate</td><td align="left">33</td><td align="left">No </td></tr>
<tr>
<td align="left">Wake-on-Proximity Scan Rate</td><td align="left">N/A</td><td align="left">No </td></tr>
<tr>
<td align="left">Conversion Count</td><td align="left">500</td><td align="left">No </td></tr>
<tr>
<td align="left">Frequency Divider</td><td align="left">f/4</td><td align="left">Yes </td></tr>
</table>
<div class="image">
<img src="design_lowpowerbuttons_canvas.png" alt="design_lowpowerbuttons_canvas.png"/>
<div class="caption">
Design Center Configuration</div></div>
  <p>Out of all the default configuration values, only the frequency divider is optimized (f/4 with phase lengths of 1 for a conversion frequency of 2 MHz). This yields a starting, un-optimized current of approximately <b>310 uA-avg</b>. We can do better than this! Note that LED1 and LED2 of the CAPTIVATE-FR2633 processor module must be disconnected, or the measured power will be higher.</p>
<h3>Step 2: Switch from UART to I2C</h3>
<p>UART requires that SMCLK be active for the baud rate generator to work. By switching to I2C for data transfer, we are able to go to LPM3 instead. This is possible because as a slave, the MSP does not need to provide a clock for I2C to operate.</p>
<table class="doxtable">
<tr>
<th align="left">Parameter</th><th align="left">Value</th><th align="left">Optimized?  </th></tr>
<tr>
<td align="left">COMM Peripheral</td><td align="left">Bulk-I2C (Slave)</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Active Scan Rate</td><td align="left">33</td><td align="left">No </td></tr>
<tr>
<td align="left">Wake-on-Proximity Scan Rate</td><td align="left">N/A</td><td align="left">No </td></tr>
<tr>
<td align="left">Conversion Count</td><td align="left">500</td><td align="left">No </td></tr>
<tr>
<td align="left">Frequency Divider</td><td align="left">f/4</td><td align="left">Yes </td></tr>
</table>
<p>Making this change has lowered the current to <b>68 uA-avg</b>. We can still do better! Note that the Design Center must be connected to see these power numbers, otherwise the I2C requests will time out, using more power.</p>
<h3>Step 3: Optimize the Conversion Count</h3>
<p>The project came with a default conversion count of 500. This provides a delta due to touch of about 80 on the 4 buttons. This is more resolution than is needed. Lowering the conversion count to 200 and the conversion gain to 100 (to boost sensitivity) will cut the measurement time more than in half, and still provide a delta of about 30 counts. 30 counts is significantly less, but for button detection in a battery powered application, it is adequate. The default touch thresholds still work as well.</p>
<table class="doxtable">
<tr>
<th align="left">Parameter</th><th align="left">Value</th><th align="left">Optimized?  </th></tr>
<tr>
<td align="left">COMM Peripheral</td><td align="left">Bulk-I2C (Slave)</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Active Scan Rate</td><td align="left">33</td><td align="left">No </td></tr>
<tr>
<td align="left">Wake-on-Proximity Scan Rate</td><td align="left">N/A</td><td align="left">No </td></tr>
<tr>
<td align="left">Conversion Count</td><td align="left">200</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Frequency Divider</td><td align="left">f/4</td><td align="left">Yes </td></tr>
</table>
<p>These changes lower the current to <b>38 uA-avg</b>. We are getting there.</p>
<h3>Step 4: Adjusting the Active Mode Scan Period</h3>
<p>The default scan period of 33ms provides good response time, but it uses power. Adjusting this down to 83ms (12 Hz) will reduce the power, but not so much that it compromises the ability to pick up a press.</p>
<table class="doxtable">
<tr>
<th align="left">Parameter</th><th align="left">Value</th><th align="left">Optimized?  </th></tr>
<tr>
<td align="left">COMM Peripheral</td><td align="left">Bulk-I2C (Slave)</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Active Scan Rate</td><td align="left">83</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Wake-on-Proximity Scan Rate</td><td align="left">N/A</td><td align="left">No </td></tr>
<tr>
<td align="left">Conversion Count</td><td align="left">200</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Frequency Divider</td><td align="left">f/4</td><td align="left">Yes </td></tr>
</table>
<p>This change lowered the current to <b>26 uA-avg</b>.</p>
<h3>Step 5: Enabling and Adjusting the Wake-on-Proximity Mode</h3>
<p>Now to add the final touches, let's enable the wake-on-proximity state machine functionality to manage states. We only have 4 buttons, with one from each measurement block, so we can measure all 4 buttons and test for proximity without any CPU involvement.</p>
<table class="doxtable">
<tr>
<th align="left">Parameter</th><th align="left">Value</th><th align="left">Optimized?  </th></tr>
<tr>
<td align="left">COMM Peripheral</td><td align="left">Bulk-I2C (Slave)</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Active Scan Rate</td><td align="left">83</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Wake-on-Proximity Scan Rate</td><td align="left">125</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Conversion Count</td><td align="left">200</td><td align="left">Yes </td></tr>
<tr>
<td align="left">Frequency Divider</td><td align="left">f/4</td><td align="left">Yes </td></tr>
</table>
<p>The capture below shows the conversion control tab of the controller customizer, which contains most of the settings that we have been adjusting to optimize for low power.</p>
<div class="image">
<img src="design_lowpower_settings.png" alt="design_lowpower_settings.png"/>
<div class="caption">
Design Center Configuration</div></div>
  <p>This change lowered the current to <b>3 uA-avg</b>, or about 750nA per button when no one is touching the panel. As soon as a user touches a button, the power consumption goes up to 23-26uA-avg with I2C reporting. Once the touch is removed, the UI goes back into wake-on-proximity mode after 32 samples and is back to the 3 uA-avg.</p>
<h2><a class="anchor" id="ch_design_low_power_bias_current"></a>
A Note about Mutual Capacitance and Bias Current</h2>
<p>Mutual capacitance sensors have an extra tuning parameter: the bias current. During a mutual capacitance measurement, a sample-and-hold amplifier cancels out the effects of the parasitic / stray self capacitance on the receive electrode. This sample-and-hold amplifier has an adjustable bias current capability, which allows for the drive strength of the amplifier to be adjusted to suite the application.</p>
<p>For information on bias current settings how to adjust the bias current, see the <a class="el" href="ch_Glossary.html#ch_glossary_bias_current">bias current guide</a>. Note that the bias current control is only available in <a class="el" href="DesignCenter.html#ch_cdc_UsersGuide_sec02_03_02">advanced mode</a>.</p>
<p>A larger bias current setting should be used when the parasitic capacitance to ground of the Rx electrode is large. The default value is the highest possible bias current, which works for the most applications but requires the highest power consumption. During low power optimization, it is desirable to lower the bias current if the layout allows for it. Most button designs with minimal parasitic capacitance work very well with the lowest bias current setting.</p>
<h3>Bias Current Optimization Procedure</h3>
<p>To optimize the bias current setting for a low power application, begin by setting the bias current to the lowest available setting. Test each electrode in the sensor for sensitivity to touch. One effect of setting the bias current too low is that a touch on a sensor will cause a decrease in counts rather than an increase, because the system cannot accurately compensate for the parasitic self capacitance of the receive (Rx) electrode. If this occurs, continue increasing the bias current until the behavior goes away. Note that the bias current performance also varies with the conversion frequency. Higher conversion frequencies will require higher bias current settings for designs with more parasitic capacitance to ground.</p>
<hr/>
 <h1><a class="anchor" id="ch_design_moisture"></a>
Moisture</h1>
<p>This section discusses special considerations for designing products that will come into contact with moisture.</p>
<h2><a class="anchor" id="ch_design_moisture_intro"></a>
Introduction</h2>
<p>The performance of a capacitive touch panel can be affected by moisture spray and build-up, as well as liquid spills. In addition, self capacitance and mutual capacitance exhibit different phenomena depending on the nature of the moisture. For example, small water droplets on a self capacitance electrode may have little effect, but a water droplet on a mutual capacitance electrode may have the effect of improving the mutual coupling and creating a change in the measurement counts that goes the opposite direction of a touch. Interestingly still, a water droplet or spill on a self or a mutual capacitance electrode could cause a change in measurement counts in the direction of (rather than against) a touch, if the droplet or spill is also in contact with a nearby ground plane, power plane, or grounded electrode that is not being measured. This section will introduce the physics behind the effects of moisture, as well as some basic best practices to add a level of moisture resistance and detection to an application.</p>
<h2><a class="anchor" id="ch_design_moisture_expectations"></a>
Expectations</h2>
<p>With careful attention to detail, it is possible to create designs that can reject small amounts of moisture. Through the use of guard channels, it is also possible to create designs that can detect spills and lock out the rest of the interface when a spill is detected.</p>
<h2><a class="anchor" id="ch_design_moisture_physics"></a>
Moisture Physics</h2>
<p>Moisture build-ups and liquid spills that occur on panels in the real world affect capacitive sensing electrodes because the liquid on the panel exhibits electrical conductivity. Water is a polarized molecule, and in addition to its polarization, it is rarely pure and typically contains ions in solution. The amount of ions dissolved directly effects the conductivity of the moisture. Distilled water will appear to have much less of an effect than salt water or sweat, for example.</p>
<p>This conductive property means that moisture can appear to have a similar effect as placing a conductor (such as a piece of metal) on a panel. It's easy to understand how that will cause problems! Making things worse is the fact that moisture is unpredictable in multiple aspects:</p><ol type="1">
<li>Its actual conductivity is extremely variable</li>
<li>The shape and size of droplets and spills are unknown and constantly changing</li>
<li>Changes tend to be fast- making them look more like a touch and less like an environmental change</li>
</ol>
<h2><a class="anchor" id="ch_design_moisture_problems"></a>
Moisture Problems</h2>
<p>At best, build-up of moisture occurs slowly over time and is tracked via environmental filtering. At worst, it happens unpredictably and quickly and triggers a false detection.</p>
<h2><a class="anchor" id="ch_design_moisture_mitigation"></a>
Moisture Mitigation Techniques</h2>
<p>Because of the unpredictable nature of moisture, it is necessary to divide mitigation techniques into two types of applications: <b>moisture tolerance</b> and <b>spill rejection</b>.</p>
<table class="doxtable">
<tr>
<th align="left">Application Type</th><th align="left">Full Touch Detection</th><th align="left">Spill Detection</th><th align="left">Guard Channel Required</th><th align="left">Typical Mechanical Mounting  </th></tr>
<tr>
<td align="left">Moisture Tolerance</td><td align="left">Yes, typically</td><td align="left">No</td><td align="left">No</td><td align="left">Vertical </td></tr>
<tr>
<td align="left">Spill Detection</td><td align="left">No, sensors are masked during a spill</td><td align="left">Yes</td><td align="left">Typically required</td><td align="left">Horizontal </td></tr>
</table>
<h3><a class="anchor" id="ch_design_moisture_mitigation_tolerance"></a>
Moisture Tolerance Applications</h3>
<p>Moisture tolerant applications include those which are able to operate with touch detection in the presence of steam, mist, and spray. Common applications include exterior/interior security panels, E-locks, thermostats, and car access keypads. Whether or not moisture tolerance is feasible for an application depends on the mechanical design and environment. Typically, the following must be true:</p><ol type="1">
<li>The touch sensing panel is installed perpendicular to the earth (vertically or at some angle) such that any moisture that accumulates on the panel will drip away on its own due to gravity</li>
<li>There is no opportunity for moisture/fluids to "pool" or "flood" the sensing panel</li>
</ol>
<h4>Design Tips for Moisture Tolerance</h4>
<p>When designing a moisture tolerant application:</p><ol type="1">
<li>Provide as much spacing as possible between buttons</li>
<li>Provide significant spacing between buttons and nearby ground planes</li>
<li>Route all electrode connection traces on the PCB layer furthest from the surface</li>
<li>Set sensor <a class="el" href="ch_Glossary.html#ch_glossary_idle_state">idle states</a> to High-Z (floating) so that nearby sensors don't provide coupling points that can cause false detections</li>
<li>If possible, use a non-conductive enclosure for the product</li>
</ol>
<h3><a class="anchor" id="ch_design_moisture_mitigation_rejection"></a>
Spill Rejection Applications</h3>
<p>Spill rejection applications include those which are able to detect when a fluid spill has occurred on the sensing panel. Common applications are white goods such as a cooking surface control panel. The goal of spill rejection is not to enable full touch detection (which is extremely difficult when moisture or fluids cover multiple keys and/or ground), but simply to detect the presence of a spill and lock out the keypad until the spill is cleared by a user. This is most commonly achieved with the use of a guard channel, whose purpose is to detect large objects as well as spills.</p>
<h4>Design Tips for Spill Detection</h4>
<p>When designing a spill detection application:</p><ol type="1">
<li>Implement a guard channel to detect when a large unknown object or some kind of spill comes into contact with the sensing panel</li>
<li>In software, utilize the guard channel to mask reporting of touches on other keys when a spill is detected.</li>
</ol>
<p>The <a class="el" href="ch_evm.html#ch_evm_get_started_sensorpanels_phone">CAPTIVATE-PHONE</a> demonstration panel has a guard channel that is used for proximity sensing, palm rejection, and basic moisture rejection.</p>
<hr/>
 <h1><a class="anchor" id="ch_design_noise"></a>
Noise Immunity</h1>
<p>This section discusses how to design for electromagnetic compatibility.</p>
<h2><a class="anchor" id="ch_design_noise_intro"></a>
Introduction</h2>
<p>Capacitive touch sensing involves the measurement of very small changes in capacitance of a sensing electrode. These changes are often on the order of a picofarad or less. Because the quantity being measured is so small, capacitive touch circuits that are going to be used in noisy environments must be designed with noise immunity in mind from the start. Often, potential noise sources may not even be known at the time of design. This chapter is dedicated to providing the necessary guidance to enable immunity to various types of noise. It introduces the most common noise threats to a capacitive touch system. For each threat, it discusses how to reduce the susceptibility of a capacitive touch circuit to that threat when using MSP CapTIvate&trade; MCUs.</p>
<h3><a class="anchor" id="ch_design_noise_intro_howtouse"></a>
How to Use This Section</h3>
<p>If you are designing a system that will exist in a high noise environment, it is best to read and understand this guide before going through the process of schematic capture and layout design. It is strongly recommended that the <a class="el" href="ch_basics.html">Capacitive Sensing Basics</a> chapter be read before reading this chapter.</p>
<p>The <a class="el" href="ch_design.html#ch_design_noise_intro">introduction</a> section of the noise immunity guide establishes a knowledge base that will be used as a backdrop for the rest of the discussion. After the <a class="el" href="ch_design.html#ch_design_noise_intro">introduction</a>, the following section will discuss several different <a class="el" href="ch_design.html#ch_design_noise_types">noise problems</a> (RF susceptibility, for example). Each problem will be introduced so that the phenomenon is understood. Finally, the last section will discuss the <a class="el" href="ch_design.html#ch_design_noise_mitigation">noise mitigation steps</a> to apply to your design to provide robustness to all of the noise types discussed. The noise mitigation steps will be presented in the context of the <a class="el" href="ch_design.html#ch_design_noise_intro_threesidedapproach">Three Sided Approach</a>. The <a class="el" href="ch_design.html#ch_design_noise_mitigation">noise mitigation steps</a> section is the most important section, as it provides a check list of considerations to apply when designing for noise immunity. If you don't read the entire noise immunity guide, be sure to read the <a class="el" href="ch_design.html#ch_design_noise_mitigation">noise mitigation steps</a>.</p>
<h3><a class="anchor" id="ch_design_noise_intro_resources"></a>
Additional Resources</h3>
<p>In addition to the design documentation here, there are several TI Designs and literature available that demonstrate how to achieve noise immunity:</p>
<ul>
<li><a href="http://www.ti.com/lit/wp/slay045/slay045.pdf">Enabling noise-tolerant capacitive-touch HMIs with MSP CapTIvate technology</a></li>
<li><a href="http://www.ti.com/tool/tidm-captouchemcref">Noise Tolerant Capacitive Touch HMI Reference Design TIDM-CAPTOUCHEMCREF</a></li>
<li><a href="http://www.ti.com/tool/tidm-captivate-thermostat-ui">Capacitive Touch Thermostat UI with MSP MCUs Featuring CapTIvate Technology TIDM-CAPTIVATE-THERMOSTAT-UI</a></li>
</ul>
<h3><a class="anchor" id="ch_design_noise_intro_agressorvictim"></a>
Aggressor-Victim Philosophy</h3>
<p>An aggressor-victim approach is taken to understand noise in a system. The diagram below illustrates this concept.</p>
<div class="image">
<img src="design_aggressor_victim_diagram.png" alt="design_aggressor_victim_diagram.png"/>
<div class="caption">
Aggressor-Victim Diagram</div></div>
  <p>The aggressor is the noise source, which generates interference that affects the victim through the coupling medium. Generally speaking, for noise to couple from the aggressor to affect the victim, the following must be true:</p>
<ul>
<li>The noise must be at a frequency at which the victim is vulnerable</li>
<li>The noise must have enough amplitude to affect the victim</li>
<li>The noise must be present at a time when the victim is vulnerable to the noise</li>
</ul>
<p><b>Aggressor</b></p>
<p>The aggressor varies with every application. Common aggressors are poorly designed power supplies with high common-mode and differential-mode emissions, long cables and/or traces that act as antennas to radio frequency (RF) signals, and high-current switched inductive loads that share their power source with the victim at some level. In some cases, the viewpoint is such that the capacitive touch circuit is the aggressor.</p>
<p><b>Coupling Medium</b></p>
<p>The medium through which the noise travels from the aggressor to the victim is often misunderstood. Common mediums include the VCC rail, the VSS rail, the capacitive coupling between traces (in the case of crosstalk), and even users of the capacitive sensing interface themselves.</p>
<p><b>Victim</b></p>
<p>During most of the discussion in this chapter, the capacitive touch circuit is the victim. However, there are times where the capacitive touch circuit becomes the aggressor, at which time a neighboring subsystem may become the victim.</p>
<h2><a class="anchor" id="ch_design_noise_intro_threesidedapproach"></a>
The Three Sided Approach</h2>
<p>Based on this understanding, it becomes clear that to reduce the effects of the aggressor on the victim, it is necessary to fulfil one or more of the following objectives:</p>
<ul>
<li>Change the characteristics of the noise emitted by the aggressor to either change its frequency or reduce its amplitude to a level that does not affect the victim</li>
<li>Reduce the ability of the noise to couple from the aggressor to the victim by modifying the coupling medium</li>
<li>Reduce the susceptibility of the victim to the noise emitted by the aggressor</li>
</ul>
<p>In some cases, it is possible to reduce the noise emitted by the aggressor (per the first bullet above). This is always the best course of action. Reducing the noise simplifies PCB layout and software considerations, and reduces the potential for other issues in the system. This is typically accomplished by designing robust power supplies and IO interfaces that do not generate their own noise nor pass on noise from the outside world. However, many times this is not possible because the aggressor may be outside the control of the system being designed. In that case, a solution must be obtained by <b>reducing the coupling medium</b> and <b>reducing the victim's susceptibility</b>.</p>
<p>Along these lines, to achieve a high level of noise immunity in a capacitive touch design it is necessary to apply the relevant CapTIvate&trade; peripheral features, hardware design principles, and signal processing tools. The basic tools available are listed below.</p>
<ol type="1">
<li><b>CapTIvate&trade; Peripheral EMC Features</b><ul>
<li>Integrator-based charge transfer method</li>
<li>Offset subtraction signal chain block</li>
<li>Frequency hopping</li>
<li>Spread-spectrum clocking</li>
<li>Synchronization input pin to align conversions with AC mains zero-crossing events</li>
</ul>
</li>
<li><b>Hardware Design Principles</b><ul>
<li>Grounding techniques</li>
<li>Filtering techniques</li>
<li>Protection passives</li>
<li>Noise sensing channel</li>
</ul>
</li>
<li><b>Signal Processing Tools</b><ul>
<li>Multi-frequency processing (MFP) algorithm</li>
<li>Dynamic threshold adjustment (DTA) algorithm</li>
<li>IIR noise filtering</li>
<li>De-bounce</li>
</ul>
</li>
</ol>
<p>The general theme of this chapter is how these three main toolboxes (the <b>CapTIvate&trade; peripheral</b>, <b>hardware design principles</b>, and <b>signal processing</b>) may be applied together to solve several noise problems at the same time.</p>
<h3><a class="anchor" id="ch_design_noise_intro_emcstandards"></a>
Introduction to Electromagnetic Compatibility (EMC) Standards</h3>
<p>International standards exist to allow for consistent, repeatable electromagnetic compatibility testing to be applied to different products. The primary international standard concerning system level robustness in the area of EMC is the IEC 61000-4 family. The tests most relevant to capacitive touch circuits are introduced below, and will be addressed in detail later in this chapter.</p>
<ol type="1">
<li><a class="el" href="ch_design.html#ch_design_noise_types_esd">IEC 61000-4-2 Electrostatic Discharge (ESD)</a> describes testing for electrostatic discharge immunity.</li>
<li><a class="el" href="ch_design.html#ch_design_noise_types_rfimmunity">IEC 61000-4-3 Radiated RF Noise</a> describes testing for immunity to radiated RF noise between 80 MHz and 1 GHz.</li>
<li><a class="el" href="ch_design.html#ch_design_noise_types_eft">IEC 61000-4-4 Electrical Fast Transient/Burst (EFT/B)</a> describes testing for immunity to high voltage fast transients.</li>
<li><b>IEC 61000-4-5 Surge</b> Describes immunity to power surge energy levels. This is not discussed here as it is considered a system-level problem that is the responsibility of the power supply.</li>
<li><a class="el" href="ch_design.html#ch_design_noise_types_rfimmunity">IEC 61000-4-6 Conducted RF Noise</a> describes testing for immunity to conducted RF noise between 150kHz and 80 MHz.</li>
<li><a class="el" href="ch_design.html#ch_design_noise_types_rfimmunity">IEC 61000-4-16 LF Conducted Noise</a> describes testing for immunity to conducted disturbances in the frequency range of 0 Hz to 150 kHz.</li>
</ol>
<h3><a class="anchor" id="ch_design_noise_intro_snr"></a>
Signal-to-Noise Ratio</h3>
<p>The signal is the change in capacitance that results in a meaningful change in counts. Noise, on the other hand, is any disturbance that does not change the capacitance but does change the counts. Most often these disturbances are the result of power supply switching noise, electrostatic discharges (ESD), electrical fast transients (EFT), radiated RF noise, or some other type of electrical noise that couples into the system.</p>
<p>SNR is a system-level specification and needs to be tested at the system level. In achieving an acceptable level of SNR, the competing requirements for noise and signal must be addressed. The most common example of competing requirements is seen with ground shields. Ground shields help reduce susceptibility to radiated and conducted interference, and the closer these structures are to the circuit being protected, the more effective they are. However, moving these structures closer to the capacitive touch circuit has an unwanted effect of increasing the parasitic capacitance and consequently lowering the sensitivity.</p>
<p>In addition to managing the competing goals of sensitivity and noise immunity, these goals need to be managed within the overall requirements of the end product. This can mean trying to achieve a solution in a limited space, under a large aesthetic housing, or in the presence of other electrical activity (noise).</p>
<h2><a class="anchor" id="ch_design_noise_types"></a>
Types of Noise</h2>
<p>This section introduces the major types of noise that a capacitive sensing system may encounter. For each topic, the problem, MCU solution, and required design actions are discussed.</p>
<h3><a class="anchor" id="ch_design_noise_types_diffmodesupplynoise"></a>
Differential Mode Supply Rail Noise</h3>
<p>Differential-mode supply rail noise is any noise seen at the DVCC supply rail of the capacitive touch MCU with respect to the DVSS (circuit common) supply rail. Some touch solutions on the market require a dedicated LDO just for the capacitive touch circuit to reduce these issues.</p>
<h4><a class="anchor" id="ch_noiseimmunity_diffmodesupplynoise_problem"></a>
Problem</h4>
<p>Some of the problems associated with a direct reference to DVCC include:</p>
<ol type="1">
<li>Changes in sensitivity as DVCC drifts down as a battery supply discharges</li>
<li>Vulnerability to false detects from ripple voltage on the DVCC supply rail</li>
<li>Increased vulnerability to EFT spikes on the DVCC supply rail</li>
</ol>
<h4><a class="anchor" id="ch_design_noise_types_diffmodesupplynoise_solution"></a>
CapTIvate MCU Solution</h4>
<p>To address these issues, the CapTIvate&trade; peripheral has low drop-out regulator that is dedicated to the capacitive sensing analog circuitry. This regulator provides decoupling from the supply rail (DVCC) as well as digital noise on-chip. Issue 1 above is resolved immediately, as the capacitive touch analog circuitry will always run at a constant, internally regulated voltage that does not drift with DVCC. The regulator is functional across the DVCC supply voltage range of the MCU (see the device datasheet for details). Issues 2 and 3 above are dramatically reduced as a result of the power supply rejection ratio of the dedicated regulator. While a dedicated regulator is not required, it does provide a compounded PSRR in very noisy systems and is still recommended.</p>
<h4><a class="anchor" id="ch_design_noise_types_diffmodesupplynoise_actions"></a>
Design Actions Required</h4>
<p>In general, no specific action is required- the on-chip regulator provides the benefits described above.</p>
<ol type="1">
<li><b>CapTIvate&trade; Peripheral EMC Features</b><ul>
<li>Dedicated CapTIvate&trade; LDO provides a constant voltage across the DVCC input range, and provides a level of PSRR against ripple voltages</li>
</ul>
</li>
<li><b>Hardware Design Principles</b><ul>
<li>Follow all recommendations for DVCC decoupling capacitance (per the device-specific datasheet).</li>
<li>Follow all recommendations for the dedicated voltage regulator (VREG) tank capacitor (per the device specific datasheet).</li>
<li>Place capacitors as close to the IC as possible.</li>
</ul>
</li>
<li><b>Signal Processing Tools</b><ul>
<li><a class="el" href="ch_Glossary.html#ch_glossary_debounce">De-bounce</a> may be applied as necessary if noise spikes are of significant amplitude to be seen in the measurement.</li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="ch_design_noise_types_esd"></a>
Electrostatic Discharge (ESD)</h3>
<p>Electrostatic discharge, if not properly managed, can disrupt a sample or even damage the MCU permanently. Fortunately, many tools exist to prevent this.</p>
<h4><a class="anchor" id="ch_noiseimmunity_esd_problem"></a>
Problem</h4>
<p>An electrostatic discharge involves a sudden flow of current between two charged objects. The flow of current may be caused by the breakdown of a dielectric material (such as plastic or even air), or direct contact. The voltage differential in a discharge may be on the order of several kilovolts (kV) or more. An electrostatic discharge applied to a device pin can permanently damage the device. Since capacitive touch panels by definition are interacted with by users or other objects that may be electrically charged, ESD deserves consideration during the design process.</p>
<h4><a class="anchor" id="ch_design_noise_types_esd_solution"></a>
CapTIvate MCU Solution</h4>
<p>The primary line of defense against ESD is always the touch panel overlay material. The overlay provides electrical isolation between the conductive electrode and any user or outside object that might interact with it. The ability of the overlay material to defend against ESD damage is dependent upon two main factors- the thickness of the material and its breakdown voltage, which is usually specified in terms of breakdown per unit of thickness. It is important to note that even if a discharge breaks down the dielectric material, the stress observed at the electrode (and possibly the device IO) will be less than the original stress on the overlay itself (since the breakdown accounts for some of the energy). Different materials will have different breakdown specifications. Generally speaking, plastics such as acrylic or polycarbonate have a higher breakdown voltage than materials such as glass. However, glass has a higher dielectric constant, which allows for better sensitivity through thicker overlays, allowing for both materials to be used easily.</p>
<p>Care should be taken to account for all places in a system that a discharge could slip through (say around the bezel of a product or through a ventilation gap). This is generally of more concern with products that have plastic enclosures than with those that have metallic enclosures that can be tied to an ESD ground or safety ground.</p>
<p>If it is not possible to obtain the needed protection mechanically, the next best alternative is to employ the use of series resistors on electrode pins, followed by low-capacitance TVS diode clamps if needed.</p>
<h4><a class="anchor" id="ch_design_noise_types_esd_actions"></a>
Design Actions Required</h4>
<ol type="1">
<li><b>CapTIvate&trade; Peripheral EMC Features</b><ul>
<li>Internal protection ESD clamps on the IO provide some chip-level protection during device handling and product assembly, but this should not be solely relied on for system level ESD protection.</li>
</ul>
</li>
<li><b>Hardware Design Principles</b><ul>
<li>Populate a 470-1k ohm resistor in series with the electrode to provide ESD protection, with a protection clamp such as a TVS diode placed between the electrode and ground (return) on the electrode side of the resistor.</li>
<li>Follow recommended <a class="el" href="ch_design.html#ch_design_noise_mitigation_hardware">hardware best practices</a> for noise immunity</li>
</ul>
</li>
<li><b>Signal Processing Tools</b><ul>
<li><a class="el" href="ch_Glossary.html#ch_glossary_debounce">De-bounce</a> of at least one sample is recommended to reduce the possibility of a false detection due to a discharge on an IO during a conversion. ESD transients are fast, and in theory do not affect multiple samples in a periodic way (like RF interference, for example).</li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="ch_design_noise_types_eft"></a>
Electrical Fast Transient (EFT)</h3>
<p>Electrical fast transients are common in industrial environments as well as within commercial products that contain switching inductive loads. These transients are similar in nature to ESD, but exhibit a lower magnitude and longer event length. When high-current inductive loads are switched on and off, high voltage transients may appear on power supply lines. Transients may also appear on signal lines if a system is connected to another system that is generating noise. The transients are a result of the inductance in the load that attempts to maintain the flow of current, and in so doing generates large voltages.</p>
<p>The IEC test simulates these threats by injecting bursts repetitively into the supply or signal lines of a system, in differential or common mode (though common mode is the most typical).</p>
<h4><a class="anchor" id="ch_design_noise_types_eft_expectations"></a>
Expectations</h4>
<p>High voltage transients are one of the issues that must be considered ahead of time when designing the system. They can wreak havoc on simple analog circuits like the MCU reset circuit. However, with proper design techniques it is possible to realize designs with immunity to 4kV per the IEC 61000-4-4 test specification.</p>
<h4><a class="anchor" id="ch_design_noise_types_eft_problem"></a>
Problem</h4>
<p>Fast transients can create effects similar to that of conducted noise, but generally only for brief periods of time as the duration of a transient is often quite short (on the order of 50 nanoseconds). This short burst time often means that not every capacitive touch sample will be affected by a burst. The figure below is data captured from a self capacitance button exposed to 1.5kV EFT bursts that were 50ns each. The 50ns transients were repeated at a 5 kHz burst rate for 15ms. That pattern was then repeated every 300ms, per the IEC test specification. The different effects observed on the electrode can be attributed to the amount of time a sample may have overlapped with a 15ms burst window. There is about a 5% chance of a sample overlapping with a burst, due to the 300ms test period. It is important to note, however, that real world threats will likely not follow this pattern! The IEC test should be used as a tool to understand the implications of EFT on a system- but real world testing in-application is just as if not more valuable.</p>
<div class="image">
<img src="design_SelfCap_EFTSpike.png" alt="design_SelfCap_EFTSpike.png"/>
<div class="caption">
Self Capacitance Button 1.5kV EFT Test</div></div>
  <h4><a class="anchor" id="ch_design_noise_types_eft_solution"></a>
CapTIvate MCU Solution</h4>
<p>The primary line of defense against EFT must be hardware design. The best place to stop transients is at the power supply before they have a chance to effect different components of a product. Chances are good that the capacitive sensing MCU will not be the only component that is vulnerable to fast transients. Supplementing a good power supply, software should be EMC hardened. This includes de-bouncing the device reset pin, as well as implementing a watchdog timer. If EFT is a concern in a safety application, memory integrity self-tests should also be applied periodically for robustness. Heavy de-bounce of the capacitive touch sensor is also extremely valuable- almost more so than IIR filtering in an EFT environment. Take the figure below as an example. The EFT burst only affected a single sample- something a basic de-bounce can easily handle. However, the magnitude of the pulse was significant enough to pull down the IIR filter for more than one sample, overwhelming a de-bounce level of 1 and requiring a de-bounce level of 2+ or a weaker filter coefficient.</p>
<div class="image">
<img src="design_SelfCap_EFTFilterError.png" alt="design_SelfCap_EFTFilterError.png"/>
<div class="caption">
Self Capacitance Button 1.5kV EFT Test - Filter Ineffectiveness</div></div>
  <h4><a class="anchor" id="ch_noiseimmunity_eft_actions"></a>
Design Actions Required</h4>
<ol type="1">
<li><b>CapTIvate&trade; Peripheral EMC Features</b><ul>
<li>Integrator-based charge transfer sensing technology</li>
</ul>
</li>
<li><b>Hardware Design Principles</b><ul>
<li>If possible, design a robust power supply for the system that blocks high frequency transients</li>
<li>Follow the same layout techniques as presented in the RF immunity section</li>
</ul>
</li>
<li><b>Signal Processing Tools</b><ul>
<li><a class="el" href="ch_Glossary.html#ch_glossary_debounce">De-bounce</a></li>
<li>Re-purpose the reset pin as a non-maskable interrupt (NMI) to de-bounce potential IC reset conditions.</li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="ch_design_noise_types_rfimmunity"></a>
RF Susceptibility (Conducted and Radiated)</h3>
<p>Capacitive touch circuits are inherently vulnerable to RF interference, since it can lead to injected noise currents into transmit (Tx) and receive (Rx) sensing IOs. By applying a combination of peripheral features, hardware techniques, and signal processing, it is possible to realize capacitive touch designs that are robust in the presence of RF interference.</p>
<p>RF interference will be broken down into two categories (conducted and radiated) based upon the frequency of the interference. The distinction between the two is important, as it defines the nature of the coupling medium between the aggressor and the victim. The breakdown is as follows:</p>
<ul>
<li>Conducted RF Interference<ul>
<li>10's of kHz to 10's of MHz</li>
<li>Long wavelengths</li>
<li>PCB traces are not efficient antennas</li>
<li>Noise is generally assumed to be coupled into the system via the power supply or through IO cables</li>
<li>Cables are of sufficient length to be efficient antennas</li>
<li>Generally of the most concern for capacitive touch circuits since the frequency range overlaps with the charge transfer frequency range</li>
</ul>
</li>
<li>Radiated RF Interference<ul>
<li>100's of MHz to GHz</li>
<li>Short wavelengths</li>
<li>PCB traces can be efficient antennas</li>
<li>Generally of less concern for capacitive touch circuits</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="ch_design_noise_types_rfimmunity_expectations"></a>
Expectations</h4>
<p>In general, self capacitance sensors will allow for a higher level of noise immunity to be achieved than mutual capacitance sensors. This is a result of the fact that self-capacitance measurements are looking for larger changes (a few pF), whereas mutual capacitance measurements are looking for small changes (less than 1pF). In addition, to realize a mutual capacitance measurement the self-capacitance effect of the Rx must be eliminated from the measurement. This is achieved through the use of a sample-and-hold amplifier which compensates for the receiver (Rx) to ground capacitance to remove it from the measurement. If strong enough noise currents exist, this sample and hold amplifier can become overwhelmed to the point where it is not able to stabilize the Rx. When this happens, a self-capacitance effect (an overall decrease in counts) is observed. For this reason, self capacitance is the recommended method for high levels of immunity above 3Vrms. At or below 3 Vrms (the commercial product test level), mutual capacitance is a very viable sensing method with many advantages, such as higher key density.</p>
<p>The following table breaks down what kind of immunity can be expected when testing a system to the IEC 61000-4-6 specification.</p>
<p><b>Class A Immunity Table (Fully Functional in Presence of Noise)</b> </p><table class="doxtable">
<tr>
<th align="left">Sensing Method</th><th align="left">Sensor Type</th><th align="left">Achievable IEC 61000-4-6(Conducted) Level  </th></tr>
<tr>
<td align="left">Self</td><td align="left">Buttons</td><td align="left">Level 3 (10V RMS) </td></tr>
<tr>
<td align="left">Self</td><td align="left">Sliders/Wheels</td><td align="left">Level 3 (10V RMS) </td></tr>
<tr>
<td align="left">Self</td><td align="left">Proximity</td><td align="left">Level 1 (1V RMS) </td></tr>
<tr>
<td align="left">Mutual</td><td align="left">Buttons</td><td align="left">Level 2 (3V RMS) </td></tr>
<tr>
<td align="left">Mutual</td><td align="left">Sliders/Wheels</td><td align="left">Level 1 (1V RMS) </td></tr>
<tr>
<td align="left">Mutual</td><td align="left">Proximity</td><td align="left">Not Recommended </td></tr>
</table>
<h4><a class="anchor" id="ch_design_noise_types_rfimmunity_testsystem"></a>
Conducted RF Noise Test System</h4>
<p>Conducted noise immunity is most reliably tested with the coupling/decoupling network method as specified in IEC 61000-4-6. A block diagram of the test configuration is shown below.</p>
<div class="image">
<img src="design_IEC6100046_TestBench_BlockDiagram.png" alt="design_IEC6100046_TestBench_BlockDiagram.png"/>
<div class="caption">
Conducted RF Test System</div></div>
  <p>The frequency range tested is typically 150 kHz to 80 MHz, amplitude modulated at 80% depth on a 1 kHz carrier frequency to simulate real threats.</p>
<h4><a class="anchor" id="ch_design_noise_types_rfimmunity_problem"></a>
Problem</h4>
<p>The problem with RF interference is that it leads to injected currents that can couple into receive (Rx) electrodes. Typically, the currents are common mode in nature with respect to some reference (usually earth ground). The adverse effects observed on capacitive touch circuits are different for self capacitance than for mutual capacitance, so the two will be treated separately in the following section.</p>
<h5>Self Capacitance</h5>
<p>Self capacitance sensors experience several different effects in the presence of noise depending upon the following factors:</p><ol type="1">
<li>Frequency of the noise.<ul>
<li>If the noise is centered directly on the conversion frequency or its lower harmonics (+/- 50 kHz), the measurement data will be corrupted positively and negatively, as shown below. This occurs whether or not a touch is present, although the effect is amplified when a touch is present (as shown). <div class="image">
<img src="design_SelfCap_WithAndWithoutNoise_NoAlg.png" alt="design_SelfCap_WithAndWithoutNoise_NoAlg.png"/>
<div class="caption">
Self Capacitance Button with No Noise and 3Vrms Conducted Noise at Conversion Frequency</div></div>
  </li>
<li>If the noise is nearby the conversion frequency, but not directly aligned with it or a low harmonic, the measurement will not be corrupted but it will experience an increase in sensitivity to touch with a time-varying noise component. <div class="image">
<img src="design_SelfCap_WithAndWithoutNoise_NoAlg_Near.png" alt="design_SelfCap_WithAndWithoutNoise_NoAlg_Near.png"/>
<div class="caption">
Self Capacitance Button with No Noise and 3Vrms Conducted Noise at Conversion Frequency</div></div>
   Note that the measurement is stable, and the noise only occurs in one direction. Self capacitance sensors will exhibit susceptibility in this way beginning just below their charge transfer frequency and going out past it with diminishing noise farther out in frequency.</li>
</ul>
</li>
<li>Amplitude of the noise. As the noise amplitude increases, the average delta due to a touch increases. This is a result of injected current into the Rx. This effect shows up as an increase in sensitivity to touch. For example, a button may trigger with a few mm of proximity rather than a full touch.</li>
</ol>
<h5>Mutual Capacitance</h5>
<p>Mutual capacitance sensors exhibit corruption of data if noise is present at the conversion frequency or its lower harmonics. The susceptibility band is typically 100 kHz around the conversion frequency. The effect can be seen in the diagram below.</p>
<div class="image">
<img src="design_MutualCap_WithAndWithoutNoise_NoAlg.png" alt="design_MutualCap_WithAndWithoutNoise_NoAlg.png"/>
<div class="caption">
Mutual Capacitance Button with No Noise and 3Vrms Conducted Noise</div></div>
  <p>Notice how the data captured is completely unusable at this point. If the recommended layout practices are not followed, the result will be a widening of the susceptibility band in frequency beyond the typical value of ~100 kHz. This will limit the performance of the frequency hopping solution described next.</p>
<h4><a class="anchor" id="ch_design_noise_types_rfimmunity_solution"></a>
CapTIvate MCU Solution</h4>
<p>Several methods are employed to improve immunity to conducted and radiated RF interference:</p>
<ul>
<li>Liberal use of ground structures in the PCB layout to reduce the fringe free-space coupling of the electrode and its trace back to earth ground and the user.</li>
<li>Frequency hopping is applied to prevent noise in a given frequency band from corrupting the measurement by aggregating the data from 4 different conversion frequencies with the multi frequency processing (MFP) algorithm</li>
<li>In mutual mode, filter capacitors are placed between Rx lines and circuit common to narrow the susceptibility band in frequency, improving the benefit of frequency hopping</li>
<li>In self mode, spread spectrum clock modulation and the dynamic threshold adjustment (DTA) algorithm are applied to compensate for the increased sensitivity to touch</li>
<li><a class="el" href="ch_Glossary.html#ch_glossary_count_filter">IIR filtering</a> and <a class="el" href="ch_Glossary.html#ch_glossary_debounce">de-bounce</a> may be used to add additional robustness</li>
</ul>
<h5>Self Capacitance</h5>
<p>To achieve self-capacitance immunity, it is imperative that dense grounding structures be applied to limit fringing E-field lines. This has the effect of stabilizing the electrode. Then the use of frequency hopping and spread-spectrum clocking improves the data to a level where it may be processed by an algorithm, as shown below. In the plot below, noise is being injected at F3. Notice how F3 looks the same as the plot shown above in the problem section- it has positive and negative noise. However, F0-F2 are clean when no touch is present, and only exhibit the additional sensitivity in the negative direction when the button is touched. Applying spread-spectrum clock modulation reduces the effect of the noise at F3 to the point where it looks similar to F0-F2.</p>
<div class="image">
<img src="design_SelfCap_3Vrms_Modulation.png" alt="design_SelfCap_3Vrms_Modulation.png"/>
<div class="caption">
Self Capacitance Button with 3Vrms Conducted Noise, 4 Frequency Raw Data Without and With Modulation</div></div>
  <p>Taking that data set and applying the multi-frequency processing algorithm results in a fairly clean signal that may be filtered via the addition of the IIR count filter, as shown below. Notice that the signal still has an increased delta due to the injected noise current.</p>
<div class="image">
<img src="design_SelfCap_3Vrms_Modulation_MFP_IIR.png" alt="design_SelfCap_3Vrms_Modulation_MFP_IIR.png"/>
<div class="caption">
Self Capacitance Button with 3Vrms Conducted Noise, MFP Data Without and With IIR Filtering</div></div>
  <p>Now that a clean signal has been obtained, the noise level that was measured in the original raw data is used to compute a threshold adjustment factor via the dynamic threshold adjustment algorithm (DTA). This provides compensation for the slight gain in sensitivity due to noise in the system. The noise level is also reported, should it be of interest to the application. Below is a comparison of a no-noise touch and a touch in the presence of 3Vrms conducted noise at the base conversion frequency.</p>
<div class="image">
<img src="design_SelfCap_3Vrms_Modulation_MFP_IIR_DTA.png" alt="design_SelfCap_3Vrms_Modulation_MFP_IIR_DTA.png"/>
<div class="caption">
Self Capacitance Button with No Noise and 3Vrms Conducted Noise, with MFP, IIR, and DTA</div></div>
  <p>The application of all these design principles results in a button that dynamically responds to changes in the environment, compensating for noise. These techniques also work quite well on slider and wheel sensors.</p>
<h5>Mutual Capacitance</h5>
<p>As shown below, the application of frequency hopping and filter capacitors in mutual mode produces usable measurements at the auxiliary frequencies (left plot). The multi-frequency processing (MFP) algorithm may then resolve the data set into a usable count value that is fed into the standard element and sensor processing algorithms.</p>
<div class="image">
<img src="design_MutualCap_3Vrms_4Freq_WithAndWithoutAlg_NoiseAt1.png" alt="design_MutualCap_3Vrms_4Freq_WithAndWithoutAlg_NoiseAt1.png"/>
<div class="caption">
Mutual Capacitance Button with 3Vrms Conducted Noise, Raw Data and Processed Data</div></div>
  <p>If the solution is looked at across a frequency sweep, the benefit of the frequency hopping approach becomes evident. This data set corresponds to a button that was not touched during the test.</p>
<div class="image">
<img src="design_MutualCap_NoiseSweep_Untouched.png" alt="design_MutualCap_NoiseSweep_Untouched.png"/>
<div class="caption">
Mutual Capacitance Button with 3Vrms Conducted Noise, No-Touch Noise Sweep</div></div>
  <p>Note how the noise bands are very narrow, and are easily overcome by the frequency hopping algorithm. When touched, the susceptibility band increases and the amplitude of the noise increases. However, usable data is still obtained.</p>
<div class="image">
<img src="design_MutualCap_NoiseSweep_Touched.png" alt="design_MutualCap_NoiseSweep_Touched.png"/>
<div class="caption">
Mutual Capacitance Button with 3Vrms Conducted Noise, Touched Noise Sweep</div></div>
  <p>In both the untouched and touched diagrams, it is easy to pick out the fundamental frequencies at the left, and their corresponding harmonics. It may become obvious from reviewing the above diagrams that noise may affect more than one frequency at a time. In the event that this occurs, the frequency hopping approach is still able to handle most situations. The diagram below shows noise affecting two frequencies at the same time.</p>
<div class="image">
<img src="design_MutualCap_3Vrms_4Freq_WithAndWithoutAlg_NoiseAt2.png" alt="design_MutualCap_3Vrms_4Freq_WithAndWithoutAlg_NoiseAt2.png"/>
<div class="caption">
Mutual Capacitance Button 3Vrms Conducted Noise</div></div>
  <p>In the event that the noise become too great for the algorithm to determine what is happening, it is possible to use the noise threshold and noise status bits of the elements to alert the application and lock out a safety critical function.</p>
<h4><a class="anchor" id="ch_design_noise_types_rfimmunity_actions"></a>
Design Actions Required</h4>
<p>Designing for immunity to RF interference does require hardware and software considerations. Be sure to review the final section of this guide, <a class="el" href="ch_design.html#ch_design_noise_mitigation">Noise Mitigation Steps</a>, for implementation details.</p>
<ol type="1">
<li><b>CapTIvate&trade; Peripheral EMC Features</b><ul>
<li>Integrator-based charge transfer method</li>
<li>Offset subtraction signal chain block</li>
<li>Frequency hopping</li>
<li>Spread-spectrum clocking</li>
</ul>
</li>
<li><b>Hardware Design Principles</b><ul>
<li>Implement conducted noise immunity layout best practices, taking into account the thickness and dielectric of the overlay material</li>
<li>Eliminate or limit use of off-board connectors that carry capacitive sensing lines</li>
</ul>
</li>
<li><b>Signal Processing Tools</b><ul>
<li><a class="el" href="ch_lib.html#ch_lib_emc_algorithms_mfp">CapTIvate&trade; EMC Multi Frequency Processing (MFP)</a> algorithm</li>
<li><a class="el" href="ch_lib.html#ch_lib_emc_algorithms_dta">CapTIvate&trade; EMC Dynamic Threshold Adjustment (DTA)</a> algorithm</li>
<li><a class="el" href="ch_Glossary.html#ch_glossary_count_filter">IIR Count Filtering</a></li>
<li><a class="el" href="ch_Glossary.html#ch_glossary_debounce">De-bounce</a></li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="ch_design_noise_mitigation"></a>
Noise Mitigation Steps</h2>
<p>One of the nice things about designing for EMC is that many of the techniques used to improve a design for one type of noise also tend to improve the design for other types of noise as well. This section steps through noise mitigation steps that should be applied to all designs that require noise immunity. It is best to think of this section as a design check list. All of the items discussed here should be applied when designing a product to have robust noise immunity.</p>
<ol type="1">
<li><a class="el" href="ch_design.html#ch_design_noise_mitigation_selfvmutual">Determine</a> whether the design will be using self or mutual capacitance (or both).</li>
<li>Before beginning a PCB layout, review the <a class="el" href="ch_design.html#ch_design_noise_mitigation_hardware">hardware checklist</a>.</li>
<li>When configuring a project in the CapTIvate&trade; Design Center, review the <a class="el" href="ch_design.html#ch_design_noise_mitigation_tuning">tuning checklist</a>.</li>
</ol>
<h3><a class="anchor" id="ch_design_noise_mitigation_selfvmutual"></a>
Self versus Mutual Capacitance for Noise Immunity</h3>
<p>Self capacitance is the recommended measurement method for designs that require sliders and wheels, as well as designs that need more than the commercial product level of 3Vrms conducted noise immunity. Mutual capacitance is recommended for designs that have higher key densities (16-32 buttons) and only require the commercial product immunity levels.</p>
<h3><a class="anchor" id="ch_design_noise_mitigation_hardware"></a>
Noise Immunity Hardware Check List</h3>
<p>Review this check list before starting a PCB layout.</p>
<ol type="1">
<li>Follow <a class="el" href="ch_design.html#ch_design_noise_mitigation_hardware_electrodes">electrode design best practices</a> for noise immunity.</li>
<li>Utilize dense <a class="el" href="ch_design.html#ch_design_noise_mitigation_hardware_shielding">return (ground) plane structures</a> to limit fringe E-field lines.</li>
<li>For mutual (projected) capacitance sensors, populate a 68pF ceramic capacitor between each Rx and circuit return (ground). This capacitor should be placed close to the MCU. It is also a good idea to allow a provision to populate a capacitor between each Tx and circuit return, should it be needed during qualification. The TI noise immunity reference designs do not require the Tx capacitor.</li>
<li>Avoid routing capacitive sensing lines (Rx's or Tx's) through board-to-board connectors or cables. Connectors can be significant noise receptors.</li>
<li>Optimize the overlay thickness as much as possible. The thicker the overlay material, the higher the chance of a touch on one key affecting a nearby key. With thinner overlays, electrodes will be more susceptible to ESD. The sweet spot is 1.5mm to 4mm for a typical PC/ABS/acrylic overlay.</li>
<li>Use good power supply design principles to limit noise at the entry point. If possible, implement a common mode choke coil with a high impedance to common-mode noise in the range of 100 kHz to 100 MHz.</li>
</ol>
<h4><a class="anchor" id="ch_design_noise_mitigation_hardware_electrodes"></a>
Noise Immunity Electrode Design Best Practices</h4>
<p>When designing for noise immunity, there are several best practices to apply to electrode geometry. Self capacitance and mutual capacitance will be discussed separately.</p>
<h5>Self Capacitance</h5>
<p>In the case of self capacitance, 3Vrms immunity is usually attainable without significant overhaul to the electrode design principles discussed in the <a class="el" href="ch_design.html#ch_design_self_button_shape">button design section</a>.</p>
<p>The following principles should be applied:</p><ol type="1">
<li>Limit the size of the electrodes where possible. Do not oversize electrodes beyond what is needed to achieve the desired sensitivity with the overlay that will be used with the product.</li>
<li>Avoid air gaps in the overlay stackup</li>
<li>Keep traces from the MCU to the electrode as short as possible</li>
<li>If possible, do not place electrodes on the edges of the PCB, as this limits the effectiveness of <a class="el" href="ch_design.html#ch_design_noise_mitigation_hardware_shielding">ground shielding</a></li>
<li>If the design has a thin overlay stackup (&lt;3mm), a special electrode design may be used which has a ground plane in the center of the button. Placing a ground plane in the center of a button has two effects: additional stability for the electrode, and a path for noise currents into the ground plane and not into the electrode during a touch</li>
</ol>
<p>Below is a comparison of a standard button layout with the special button layout discussed in principle #5. The special button layout is really only suitable for designs with overlay stackups less than 3mm. Above 3mm, the sensitivity trade-off becomes too great.</p>
<div class="image">
<img src="design_noise_button_self.png" alt="design_noise_button_self.png"/>
<div class="caption">
Self Buttons (Grid = 0.5mm)</div></div>
  <h5>Mutual Capacitance</h5>
<p>Mutual capacitance requires a specific geometry to achieve immunity. The layout below depicts the recommended geometry. The goals are as follows:</p>
<ol type="1">
<li>Limit the size of the Rx</li>
<li>Overlay stackup air gaps are not permitted for mutual capacitance</li>
<li>Use cutouts in the Rx as shown to improve sensitivity</li>
<li>Place a small ground fill in the center of the electrode to add a path for noise currents into the ground plane and not into the electrode during a touch</li>
<li>Route all Rx signals on the bottom layer if possible to limit their exposure to a touch</li>
<li>Keep the number of Tx lines per Rx as low as possible. This limits the vulnerability of the receiver to noise.</li>
</ol>
<div class="image">
<img src="design_noise_button_mutual.png" alt="design_noise_button_mutual.png"/>
<div class="caption">
Mutual Buttons (Grid = 0.5mm)</div></div>
  <p>The geometry is as follows: </p><table class="doxtable">
<tr>
<th align="left">Parameter</th><th align="left">Value  </th></tr>
<tr>
<td align="left">Overall Geometry</td><td align="left">10mm x 10mm </td></tr>
<tr>
<td align="left">Plane Keepout</td><td align="left">0.5mm from overall geometry on top layer, flooded on bottom layer </td></tr>
<tr>
<td align="left">Tx Thickness</td><td align="left">1mm </td></tr>
<tr>
<td align="left">Rx Thickness</td><td align="left">0.5mm </td></tr>
<tr>
<td align="left">Inner Ground Fill</td><td align="left">3mm x 3mm </td></tr>
<tr>
<td align="left">Tx to Rx Spacing</td><td align="left">1mm </td></tr>
<tr>
<td align="left">Rx Wing Length</td><td align="left">2mm </td></tr>
</table>
<p>This electrode geometry has been proven with overlays between 1mm and 3mm of thickness.</p>
<h4><a class="anchor" id="ch_design_noise_mitigation_hardware_shielding"></a>
Noise Immunity Electrode Shielding Best Practices</h4>
<p>Proper ground shielding of electrodes is required to achieve noise immunity. This applies to both self and mutual capacitance designs.</p>
<h5>Self Capacitance Shielding</h5>
<p>For self capacitance designs, utilize a solid ground or power plane on the top layer of the PCB, and a medium-density hatched power or ground plane on the bottom layer of the PCB. As an example, if the <a class="el" href="ch_evm.html#ch_evm_hardware_bswp">CAPTIVATE-BSWP</a> panel (which was designed for low power battery operation) was modified to attain noise immunity, the following changes would be made:</p>
<ol type="1">
<li>Removal of the proximity sensor</li>
<li>Addition of a solid ground/power plane on the top layer</li>
<li>Expansion of the hatched ground/power plane on the bottom layer to the size of the PCB</li>
</ol>
<p>Below are before and after images of the top and bottom layers, applying the principles described above:</p>
<div class="image">
<img src="design_noise_bswp_mod_top.png" alt="design_noise_bswp_mod_top.png"/>
<div class="caption">
CAPTIVATE-BSWP Modified for Noise Immunity (Top Layer)</div></div>
  <div class="image">
<img src="design_noise_bswp_mod_bottom.png" alt="design_noise_bswp_mod_bottom.png"/>
<div class="caption">
CAPTIVATE-BSWP Modified for Noise Immunity (Bottom Layer)</div></div>
  <p>The addition of these dense ground structures serves to limit fringing E-field lines as much as possible, stabilizing the electrodes. Normally the addition of this much parasitic capacitance is considered bad practice, but in the case of noise immunity the trade-off is extremely beneficial. In addition, the gain and offset subtraction capability of the CapTIvate&trade; technology makes it possible to maintain decent sensitivity even with the ground shield structures.</p>
<h5>Mutual Capacitance Shielding</h5>
<p>For mutual capacitance designs, utilize solid ground or power planes on the top and bottom layer of the PCB. Mutual receive electrodes (Rx's) are extremely sensitive (on the order of &lt;1mV). As a result, they are very vulnerable to noise currents. It is necessary to keep the Rx tracks as short as possible and as well-shielded as possible.</p>
<p>The design below illustrates these concepts for a 4x2 8-button mutual capacitance matrix:</p>
<div class="image">
<img src="design_noise_mutual_board.png" alt="design_noise_mutual_board.png"/>
<div class="caption">
TIDM-CAPTIVATE-THERMOSTAT-UI (Top and Bottom Layer)</div></div>
  <h3><a class="anchor" id="ch_design_noise_mitigation_tuning"></a>
Tuning Check List</h3>
<p>Review this check list when tuning a design that requires noise immunity.</p>
<ol type="1">
<li>If RF immunity is required, enable <a class="el" href="DesignCenter.html#ch_cdc_UsersGuide_sec03_01">noise immunity mode</a> in the CapTIvate&trade; Design Center. This will enable frequency hopping during measurement, and will increase the measurement time for each sensor by just over 4x.</li>
<li>Set strong <a class="el" href="ch_Glossary.html#ch_glossary_debounce">de-bounce settings</a>. A value of 2 or greater is recommended.</li>
<li>Set a strong <a class="el" href="ch_Glossary.html#ch_glossary_count_filter">count filter beta</a>. A value of 2-3 for buttons and 1-2 for sliders/wheels is recommended.</li>
<li>For self capacitance sensors, <b>enable</b> <a class="el" href="ch_Glossary.html#ch_glossary_modulation_enable">modulation</a>. In self mode, the modulation improves the performance of the DTA (dynamic threshold adjustment) algorithm by spreading the conversion clock frequency and reducing noise spikes directly at the conversion frequencies and lower harmonics.</li>
<li>For mutual (projected) capacitance sensors, <b>disable</b> <a class="el" href="ch_Glossary.html#ch_glossary_modulation_enable">modulation</a>. In mutual mode, the modulation interferes with frequency hopping, as it widens the susceptibility bands.</li>
<li>For mutual (projected) capacitance sensors, use a conversion frequency of 2 MHz or greater. If the <a class="el" href="ch_Glossary.html#ch_glossary_phase_lengths">phase lengths</a> are both set to 1, a <a class="el" href="ch_Glossary.html#ch_glossary_frequency_divider">frequency</a> divider of f/4 provides an effective conversion frequency of 2 MHz. Utilizing a faster conversion frequency increases the effectiveness of the frequency hopping mechanism by providing a wider spread between hop points.</li>
<li>Set an error threshold for each sensor. For mutual capacitance, a good rule-of-thumb is to take the conversion count + 2-3x the maximum expected touch strength. For example, if a button has conversion count setting of 400, and a maximum expected delta due to touch of 100, than setting an error threshold of 600-700 would be appropriate. This serves to "cap" every conversion result to a maximum value. If noise in the system attempts to cause a conversion to continue beyond the error threshold, then the conversion will be halted. This prevents rogue samples from having extremely long sample times and effecting the response time / filtering of the system. For self capacitance, a good value is the conversion count * 1.25. For example, a sensor with a conversion count of 800 would have an error threshold of 1000. This allows space for the runtime re-calibration algorithm to kick in (which happens if the LTA drifts outside +/- 1/8th of the conversion count, if enabled).</li>
<li>For mutual (projected) capacitance sensors, set the <a class="el" href="ch_Glossary.html#ch_glossary_bias_current">bias current</a> value to the highest setting.</li>
<li>Become familiar with the <a class="el" href="ch_lib.html#ch_lib_emc">EMC module</a> configuration parameters, should you need to adjust them during development.</li>
</ol>
<hr/>
 <h1><a class="anchor" id="ch_design_references"></a>
References</h1>
<ol type="1">
<li><a href="http://wcalc.sourceforge.net/cgi-wcalc.html">http://wcalc.sourceforge.net/cgi-wcalc.html</a> </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<p>Copyright &#169; 2015, Texas Instruments Incorporated</p>	
    </li>
  </ul>
</div>
</body>
</html>
